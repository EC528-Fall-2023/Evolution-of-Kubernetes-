NAME,INSTALLED,FIXED-IN,TYPE,VULNERABILITY,SEVERITY,DATE,DESCRIPTION,COMBINED
libc6,2.31-13+deb11u4,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-13+deb11u42.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13+deb11u5,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-13+deb11u52.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13+deb11u6,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-13+deb11u62.31-13+deb11u7debCVE-2023-4911High
libc-bin,2.31-13,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc-bin2.31-132.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-132.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13+deb11u3,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-13+deb11u32.31-13+deb11u7debCVE-2023-4911High
libc-bin,2.31-13+deb11u3,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc-bin2.31-13+deb11u32.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13+deb11u2,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.31-13+deb11u22.31-13+deb11u7debCVE-2023-4911High
libc6,2.36-9+deb12u1,2.36-9+deb12u3,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.36-9+deb12u12.36-9+deb12u3debCVE-2023-4911High
libc-bin,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc-bin2.36-92.36-9+deb12u3debCVE-2023-4911High
libc6,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc62.36-92.36-9+deb12u3debCVE-2023-4911High
libc-bin,2.31-13+deb11u2,2.31-13+deb11u7,deb,CVE-2023-4911,High,2023-10-03T18:15:10.463,"""A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.""",libc-bin2.31-13+deb11u22.31-13+deb11u7debCVE-2023-4911High
libc6,2.31-13+deb11u4,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13+deb11u4(won't fix)debCVE-2023-4813Medium
libc6,2.31-13+deb11u5,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13+deb11u5(won't fix)debCVE-2023-4813Medium
libc6,2.31-13+deb11u6,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13+deb11u6(won't fix)debCVE-2023-4813Medium
libc-bin,2.31-13,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc-bin2.31-13(won't fix)debCVE-2023-4813Medium
libc6,2.31-13,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13(won't fix)debCVE-2023-4813Medium
libc6,2.31-13+deb11u3,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13+deb11u3(won't fix)debCVE-2023-4813Medium
libc-bin,2.31-13+deb11u3,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc-bin2.31-13+deb11u3(won't fix)debCVE-2023-4813Medium
libc6,2.31-13+deb11u2,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.31-13+deb11u2(won't fix)debCVE-2023-4813Medium
libc-bin,2.28-10,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc-bin2.28-10(won't fix)debCVE-2023-4813Medium
libc6,2.28-10,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc62.28-10(won't fix)debCVE-2023-4813Medium
libc-bin,2.31-13+deb11u2,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc-bin2.31-13+deb11u2(won't fix)debCVE-2023-4813Medium
libc-dev-bin,2.28-10,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc-dev-bin2.28-10(won't fix)debCVE-2023-4813Medium
libc6-dev,2.28-10,(won't fix),deb,CVE-2023-4813,Medium,2023-09-12T22:15:08.277,"'A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.'",libc6-dev2.28-10(won't fix)debCVE-2023-4813Medium
libc6,2.31-13+deb11u4,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13+deb11u4(won't fix)debCVE-2023-4806Medium
libc6,2.31-13+deb11u5,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13+deb11u5(won't fix)debCVE-2023-4806Medium
libc6,2.31-13+deb11u6,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13+deb11u6(won't fix)debCVE-2023-4806Medium
libc-bin,2.31-13,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-bin2.31-13(won't fix)debCVE-2023-4806Medium
libc6,2.31-13,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13(won't fix)debCVE-2023-4806Medium
libc6,2.31-13+deb11u3,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13+deb11u3(won't fix)debCVE-2023-4806Medium
libc-bin,2.31-13+deb11u3,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-bin2.31-13+deb11u3(won't fix)debCVE-2023-4806Medium
libc6,2.31-13+deb11u2,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.31-13+deb11u2(won't fix)debCVE-2023-4806Medium
libc6,2.36-9+deb12u1,2.36-9+deb12u3,deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.36-9+deb12u12.36-9+deb12u3debCVE-2023-4806Medium
libc-bin,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-bin2.36-92.36-9+deb12u3debCVE-2023-4806Medium
libc6,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.36-92.36-9+deb12u3debCVE-2023-4806Medium
libc-bin,2.28-10,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-bin2.28-10(won't fix)debCVE-2023-4806Medium
libc6,2.28-10,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc62.28-10(won't fix)debCVE-2023-4806Medium
libc-bin,2.31-13+deb11u2,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-bin2.31-13+deb11u2(won't fix)debCVE-2023-4806Medium
libc-dev-bin,2.28-10,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc-dev-bin2.28-10(won't fix)debCVE-2023-4806Medium
libc6-dev,2.28-10,(won't fix),deb,CVE-2023-4806,Medium,2023-09-18T17:15:55.813,"'A flaw was found in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.'",libc6-dev2.28-10(won't fix)debCVE-2023-4806Medium
libc6,2.31-13+deb11u4, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13+deb11u4 debCVE-2019-9192Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13+deb11u5 debCVE-2019-9192Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13+deb11u6 debCVE-2019-9192Negligible
libc-bin,2.31-13, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.31-13 debCVE-2019-9192Negligible
libc6,2.31-13, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13 debCVE-2019-9192Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13+deb11u3 debCVE-2019-9192Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.31-13+deb11u3 debCVE-2019-9192Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.31-13+deb11u2 debCVE-2019-9192Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.36-9+deb12u1 debCVE-2019-9192Negligible
libc-bin,2.36-9, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.36-9 debCVE-2019-9192Negligible
libc6,2.36-9, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.36-9 debCVE-2019-9192Negligible
libc-bin,2.28-10, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.28-10 debCVE-2019-9192Negligible
libc6,2.28-10, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.28-10 debCVE-2019-9192Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.31-13+deb11u2 debCVE-2019-9192Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-bin2.24-11+deb9u4 debCVE-2019-9192Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc62.24-11+deb9u4 debCVE-2019-9192Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",multiarch-support2.24-11+deb9u4 debCVE-2019-9192Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc-dev-bin2.28-10 debCVE-2019-9192Negligible
libc6-dev,2.28-10, ,deb,CVE-2019-9192,Negligible,2019-02-26T18:29:00.340,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern""",libc6-dev2.28-10 debCVE-2019-9192Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13+deb11u4 debCVE-2019-1010025Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13+deb11u5 debCVE-2019-1010025Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13+deb11u6 debCVE-2019-1010025Negligible
libc-bin,2.31-13, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.31-13 debCVE-2019-1010025Negligible
libc6,2.31-13, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13 debCVE-2019-1010025Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13+deb11u3 debCVE-2019-1010025Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.31-13+deb11u3 debCVE-2019-1010025Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.31-13+deb11u2 debCVE-2019-1010025Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.36-9+deb12u1 debCVE-2019-1010025Negligible
libc-bin,2.36-9, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.36-9 debCVE-2019-1010025Negligible
libc6,2.36-9, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.36-9 debCVE-2019-1010025Negligible
libc-bin,2.28-10, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.28-10 debCVE-2019-1010025Negligible
libc6,2.28-10, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.28-10 debCVE-2019-1010025Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.31-13+deb11u2 debCVE-2019-1010025Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-bin2.24-11+deb9u4 debCVE-2019-1010025Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc62.24-11+deb9u4 debCVE-2019-1010025Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",multiarch-support2.24-11+deb9u4 debCVE-2019-1010025Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc-dev-bin2.28-10 debCVE-2019-1010025Negligible
libc6-dev,2.28-10, ,deb,CVE-2019-1010025,Negligible,2019-07-15T04:15:13.537,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor\'s position is ""ASLR bypass itself is not a vulnerability.'",libc6-dev2.28-10 debCVE-2019-1010025Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u4 debCVE-2019-1010024Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u5 debCVE-2019-1010024Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u6 debCVE-2019-1010024Negligible
libc-bin,2.31-13, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13 debCVE-2019-1010024Negligible
libc6,2.31-13, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13 debCVE-2019-1010024Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u3 debCVE-2019-1010024Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u3 debCVE-2019-1010024Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u2 debCVE-2019-1010024Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9+deb12u1 debCVE-2019-1010024Negligible
libc-bin,2.36-9, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.36-9 debCVE-2019-1010024Negligible
libc6,2.36-9, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9 debCVE-2019-1010024Negligible
libc-bin,2.28-10, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.28-10 debCVE-2019-1010024Negligible
libc6,2.28-10, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.28-10 debCVE-2019-1010024Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u2 debCVE-2019-1010024Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.24-11+deb9u4 debCVE-2019-1010024Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.24-11+deb9u4 debCVE-2019-1010024Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",multiarch-support2.24-11+deb9u4 debCVE-2019-1010024Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-dev-bin2.28-10 debCVE-2019-1010024Negligible
libc6-dev,2.28-10, ,deb,CVE-2019-1010024,Negligible,2019-07-15T04:15:13.473,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc6-dev2.28-10 debCVE-2019-1010024Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u4 debCVE-2019-1010023Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u5 debCVE-2019-1010023Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u6 debCVE-2019-1010023Negligible
libc-bin,2.31-13, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13 debCVE-2019-1010023Negligible
libc6,2.31-13, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13 debCVE-2019-1010023Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u3 debCVE-2019-1010023Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u3 debCVE-2019-1010023Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u2 debCVE-2019-1010023Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9+deb12u1 debCVE-2019-1010023Negligible
libc-bin,2.36-9, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.36-9 debCVE-2019-1010023Negligible
libc6,2.36-9, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9 debCVE-2019-1010023Negligible
libc-bin,2.28-10, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.28-10 debCVE-2019-1010023Negligible
libc6,2.28-10, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.28-10 debCVE-2019-1010023Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u2 debCVE-2019-1010023Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.24-11+deb9u4 debCVE-2019-1010023Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.24-11+deb9u4 debCVE-2019-1010023Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",multiarch-support2.24-11+deb9u4 debCVE-2019-1010023Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-dev-bin2.28-10 debCVE-2019-1010023Negligible
libc6-dev,2.28-10, ,deb,CVE-2019-1010023,Negligible,2019-07-15T04:15:13.397,"'GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc6-dev2.28-10 debCVE-2019-1010023Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u4 debCVE-2019-1010022Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u5 debCVE-2019-1010022Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u6 debCVE-2019-1010022Negligible
libc-bin,2.31-13, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13 debCVE-2019-1010022Negligible
libc6,2.31-13, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13 debCVE-2019-1010022Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u3 debCVE-2019-1010022Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u3 debCVE-2019-1010022Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.31-13+deb11u2 debCVE-2019-1010022Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9+deb12u1 debCVE-2019-1010022Negligible
libc-bin,2.36-9, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.36-9 debCVE-2019-1010022Negligible
libc6,2.36-9, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.36-9 debCVE-2019-1010022Negligible
libc-bin,2.28-10, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.28-10 debCVE-2019-1010022Negligible
libc6,2.28-10, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.28-10 debCVE-2019-1010022Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.31-13+deb11u2 debCVE-2019-1010022Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-bin2.24-11+deb9u4 debCVE-2019-1010022Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc62.24-11+deb9u4 debCVE-2019-1010022Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",multiarch-support2.24-11+deb9u4 debCVE-2019-1010022Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc-dev-bin2.28-10 debCVE-2019-1010022Negligible
libc6-dev,2.28-10, ,deb,CVE-2019-1010022,Negligible,2019-07-15T04:15:13.317,"'GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate ""this is being treated as a non-security bug and no real threat.'",libc6-dev2.28-10 debCVE-2019-1010022Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13+deb11u4 debCVE-2018-20796Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13+deb11u5 debCVE-2018-20796Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13+deb11u6 debCVE-2018-20796Negligible
libc-bin,2.31-13, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.31-13 debCVE-2018-20796Negligible
libc6,2.31-13, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13 debCVE-2018-20796Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13+deb11u3 debCVE-2018-20796Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.31-13+deb11u3 debCVE-2018-20796Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.31-13+deb11u2 debCVE-2018-20796Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.36-9+deb12u1 debCVE-2018-20796Negligible
libc-bin,2.36-9, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.36-9 debCVE-2018-20796Negligible
libc6,2.36-9, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.36-9 debCVE-2018-20796Negligible
libc-bin,2.28-10, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.28-10 debCVE-2018-20796Negligible
libc6,2.28-10, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.28-10 debCVE-2018-20796Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.31-13+deb11u2 debCVE-2018-20796Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-bin2.24-11+deb9u4 debCVE-2018-20796Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc62.24-11+deb9u4 debCVE-2018-20796Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",multiarch-support2.24-11+deb9u4 debCVE-2018-20796Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc-dev-bin2.28-10 debCVE-2018-20796Negligible
libc6-dev,2.28-10, ,deb,CVE-2018-20796,Negligible,2019-02-26T02:29:00.450,"""In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.""",libc6-dev2.28-10 debCVE-2018-20796Negligible
libc6,2.31-13+deb11u4, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13+deb11u4 debCVE-2010-4756Negligible
libc6,2.31-13+deb11u5, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13+deb11u5 debCVE-2010-4756Negligible
libc6,2.31-13+deb11u6, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13+deb11u6 debCVE-2010-4756Negligible
libc-bin,2.31-13, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.31-13 debCVE-2010-4756Negligible
libc6,2.31-13, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13 debCVE-2010-4756Negligible
libc6,2.31-13+deb11u3, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13+deb11u3 debCVE-2010-4756Negligible
libc-bin,2.31-13+deb11u3, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.31-13+deb11u3 debCVE-2010-4756Negligible
libc6,2.31-13+deb11u2, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.31-13+deb11u2 debCVE-2010-4756Negligible
libc6,2.36-9+deb12u1, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.36-9+deb12u1 debCVE-2010-4756Negligible
libc-bin,2.36-9, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.36-9 debCVE-2010-4756Negligible
libc6,2.36-9, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.36-9 debCVE-2010-4756Negligible
libc-bin,2.28-10, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.28-10 debCVE-2010-4756Negligible
libc6,2.28-10, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.28-10 debCVE-2010-4756Negligible
libc-bin,2.31-13+deb11u2, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.31-13+deb11u2 debCVE-2010-4756Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-bin2.24-11+deb9u4 debCVE-2010-4756Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc62.24-11+deb9u4 debCVE-2010-4756Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",multiarch-support2.24-11+deb9u4 debCVE-2010-4756Negligible
libc-dev-bin,2.28-10, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc-dev-bin2.28-10 debCVE-2010-4756Negligible
libc6-dev,2.28-10, ,deb,CVE-2010-4756,Negligible,2011-03-02T20:00:01.037,"'The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.'",libc6-dev2.28-10 debCVE-2010-4756Negligible
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-11.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0464High
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0464High
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0464High
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0464High
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0464High
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0464High
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0464High
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0464,High,2023-03-22T17:15:13.130,"""A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0464High
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2023-0286High
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1k-11.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2023-0286High
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2023-0286High
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2023-0286High
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2023-0286High
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2023-0286High
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2023-0286High
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2023-0286High
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2023-0286High
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2023-0286High
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2023-0286High
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2023-0286,High,2023-02-08T20:15:24.267,"'There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2023-0286High
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2023-0215High
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1k-11.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2023-0215High
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2023-0215High
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2023-0215High
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2023-0215High
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2023-0215High
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2023-0215High
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2023-0215High
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2023-0215High
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2023-0215High
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2023-0215High
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2023-0215,High,2023-02-08T20:15:24.107,"'The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.\n\n\n\n'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2023-0215High
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-4450High
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1k-11.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-4450High
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-4450High
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-4450High
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-4450High
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-4450High
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-4450High
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-4450High
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-4450High
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-4450High
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-4450High
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-4450,High,2023-02-08T20:15:23.973,"'The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the ""name"" (e.g. ""CERTIFICATE""), any header data and the payload data.\nIf the function succeeds then the ""name_out"", ""header"" and ""data"" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-4450High
libssl1.1,1.1.1n-0+deb11u3,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1n-0+deb11u31.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1n-0+deb11u3,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1n-0+deb11u31.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1n-0+deb11u5,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1n-0+deb11u51.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1n-0+deb11u5,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1n-0+deb11u51.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1n-0+deb11u4,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1n-0+deb11u41.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1n-0+deb11u4,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1n-0+deb11u41.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1k-1,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1k-11.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1n-0+deb11u21.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1n-0+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1n-0+deb11u21.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1n-0+deb11u11.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1k-1+deb11u11.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1k-1+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1k-1+deb11u11.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1n-0+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1n-0+deb11u11.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1k-1+deb11u21.1.1v-0~deb11u1debCVE-2023-3817Medium
openssl,1.1.1k-1+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1k-1+deb11u21.1.1v-0~deb11u1debCVE-2023-3817Medium
libssl3,3.0.9-1,3.0.10-1~deb12u1,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl33.0.9-13.0.10-1~deb12u1debCVE-2023-3817Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u6debCVE-2023-3817Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u6debCVE-2023-3817Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u6debCVE-2023-3817Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u6debCVE-2023-3817Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u6debCVE-2023-3817Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u6,deb,CVE-2023-3817,Medium,2023-07-31T16:15:10.497,"'Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the ""-check"" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u6debCVE-2023-3817Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1n-0+deb11u31.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1n-0+deb11u3,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1n-0+deb11u31.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1n-0+deb11u5,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1n-0+deb11u51.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1n-0+deb11u5,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1n-0+deb11u51.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1n-0+deb11u4,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1n-0+deb11u41.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1n-0+deb11u4,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1n-0+deb11u41.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1k-1,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1k-11.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1n-0+deb11u21.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1n-0+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1n-0+deb11u21.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1n-0+deb11u11.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1k-1+deb11u11.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1k-1+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1k-1+deb11u11.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1n-0+deb11u1,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1n-0+deb11u11.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1k-1+deb11u21.1.1v-0~deb11u1debCVE-2023-3446Medium
openssl,1.1.1k-1+deb11u2,1.1.1v-0~deb11u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1k-1+deb11u21.1.1v-0~deb11u1debCVE-2023-3446Medium
libssl3,3.0.9-1,3.0.10-1~deb12u1,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl33.0.9-13.0.10-1~deb12u1debCVE-2023-3446Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u6debCVE-2023-3446Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u6debCVE-2023-3446Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u6debCVE-2023-3446Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u6debCVE-2023-3446Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u6debCVE-2023-3446Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u6,deb,CVE-2023-3446,Medium,2023-07-19T12:15:10.003,"""Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.""",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u6debCVE-2023-3446Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1k-11.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-2650Medium
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-2650Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-2650Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-2650Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-2650Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-2650Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-2650Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-2650,Medium,2023-05-30T14:15:09.683,"""Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.""",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-2650Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1k-11.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0466Medium
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0466Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0466Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0466Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0466Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0466Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0466Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0466,Medium,2023-03-28T15:15:06.880,'The function X509_VERIFY_PARAM_add0_policy() is documented to\nimplicitly enable the certificate policy check when doing certificate\nverification. However the implementation of the function does not\nenable the check which allows certificates with invalid or incorrect\npolicies to pass the certificate verification.\n\nAs suddenly enabling the policy check could break existing deployments it was\ndecided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy()\nfunction.\n\nInstead the applications that require OpenSSL to perform certificate\npolicy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly\nenable the policy check by calling X509_VERIFY_PARAM_set_flags() with\nthe X509_V_FLAG_POLICY_CHECK flag argument.\n\nCertificate policy checks are disabled by default in OpenSSL and are not\ncommonly used by applications.',openssl1.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0466Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1n-0+deb11u4,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u41.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-11.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0465Medium
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u5debCVE-2023-0465Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0465Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u5debCVE-2023-0465Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0465Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0465Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u5debCVE-2023-0465Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u5,deb,CVE-2023-0465,Medium,2023-03-28T15:15:06.820,"""Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.""",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u5debCVE-2023-0465Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-4304Medium
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1k-11.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-4304Medium
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-4304Medium
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-4304Medium
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-4304Medium
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-4304Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-4304Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-4304Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-4304Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-4304Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-4304Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-4304,Medium,2023-02-08T20:15:23.887,"'A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n\n'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-4304Medium
libssl1.1,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-2097Medium
openssl,1.1.1n-0+deb11u3,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1n-0+deb11u31.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1k-11.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-2097Medium
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-2097Medium
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u4debCVE-2022-2097Medium
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-2097Medium
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u4debCVE-2022-2097Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-2097Medium
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u4debCVE-2022-2097Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-2097Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-2097Medium
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u4debCVE-2022-2097Medium
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u4,deb,CVE-2022-2097,Medium,2022-07-05T11:15:08.340,"'AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn\'t written. In the special case of ""in place"" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u4debCVE-2022-2097Medium
libssl1.1,1.1.1n-0+deb11u3, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1n-0+deb11u3 debCVE-2010-0928Negligible
openssl,1.1.1n-0+deb11u3, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1n-0+deb11u3 debCVE-2010-0928Negligible
libssl1.1,1.1.1n-0+deb11u5, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1n-0+deb11u5 debCVE-2010-0928Negligible
openssl,1.1.1n-0+deb11u5, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1n-0+deb11u5 debCVE-2010-0928Negligible
libssl1.1,1.1.1n-0+deb11u4, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1n-0+deb11u4 debCVE-2010-0928Negligible
openssl,1.1.1n-0+deb11u4, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1n-0+deb11u4 debCVE-2010-0928Negligible
libssl1.1,1.1.1k-1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1k-1 debCVE-2010-0928Negligible
libssl1.1,1.1.1n-0+deb11u2, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1n-0+deb11u2 debCVE-2010-0928Negligible
openssl,1.1.1n-0+deb11u2, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1n-0+deb11u2 debCVE-2010-0928Negligible
libssl1.1,1.1.1n-0+deb11u1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1n-0+deb11u1 debCVE-2010-0928Negligible
libssl1.1,1.1.1k-1+deb11u1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1k-1+deb11u1 debCVE-2010-0928Negligible
openssl,1.1.1k-1+deb11u1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1k-1+deb11u1 debCVE-2010-0928Negligible
openssl,1.1.1n-0+deb11u1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1n-0+deb11u1 debCVE-2010-0928Negligible
libssl1.1,1.1.1k-1+deb11u2, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1k-1+deb11u2 debCVE-2010-0928Negligible
openssl,1.1.1k-1+deb11u2, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1k-1+deb11u2 debCVE-2010-0928Negligible
libssl3,3.0.9-1, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl33.0.9-1 debCVE-2010-0928Negligible
libssl1.1,1.1.1d-0+deb10u6, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1d-0+deb10u6 debCVE-2010-0928Negligible
openssl,1.1.1d-0+deb10u6, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1d-0+deb10u6 debCVE-2010-0928Negligible
libssl1.1,1.1.1d-0+deb10u7, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1d-0+deb10u7 debCVE-2010-0928Negligible
libssl1.1,1.1.1d-0+deb10u3, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",libssl1.11.1.1d-0+deb10u3 debCVE-2010-0928Negligible
openssl,1.1.1d-0+deb10u3, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1d-0+deb10u3 debCVE-2010-0928Negligible
openssl,1.1.1d-0+deb10u7, ,deb,CVE-2010-0928,Negligible,2010-03-05T19:30:00.797,"'OpenSSL 0.9.8i on the Gaisler Research LEON3 SoC on the Xilinx Virtex-II Pro FPGA uses a Fixed Width Exponentiation (FWE) algorithm for certain signature calculations, and does not verify the signature before providing it to a caller, which makes it easier for physically proximate attackers to determine the private key via a modified supply voltage for the microprocessor, related to a ""fault-based attack.""'",openssl1.1.1d-0+deb10u7 debCVE-2010-0928Negligible
libssl1.1,1.1.1n-0+deb11u3, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1n-0+deb11u3 debCVE-2007-6755Negligible
openssl,1.1.1n-0+deb11u3, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1n-0+deb11u3 debCVE-2007-6755Negligible
libssl1.1,1.1.1n-0+deb11u5, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1n-0+deb11u5 debCVE-2007-6755Negligible
openssl,1.1.1n-0+deb11u5, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1n-0+deb11u5 debCVE-2007-6755Negligible
libssl1.1,1.1.1n-0+deb11u4, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1n-0+deb11u4 debCVE-2007-6755Negligible
openssl,1.1.1n-0+deb11u4, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1n-0+deb11u4 debCVE-2007-6755Negligible
libssl1.1,1.1.1k-1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1k-1 debCVE-2007-6755Negligible
libssl1.1,1.1.1n-0+deb11u2, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1n-0+deb11u2 debCVE-2007-6755Negligible
openssl,1.1.1n-0+deb11u2, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1n-0+deb11u2 debCVE-2007-6755Negligible
libssl1.1,1.1.1n-0+deb11u1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1n-0+deb11u1 debCVE-2007-6755Negligible
libssl1.1,1.1.1k-1+deb11u1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1k-1+deb11u1 debCVE-2007-6755Negligible
openssl,1.1.1k-1+deb11u1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1k-1+deb11u1 debCVE-2007-6755Negligible
openssl,1.1.1n-0+deb11u1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1n-0+deb11u1 debCVE-2007-6755Negligible
libssl1.1,1.1.1k-1+deb11u2, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1k-1+deb11u2 debCVE-2007-6755Negligible
openssl,1.1.1k-1+deb11u2, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1k-1+deb11u2 debCVE-2007-6755Negligible
libssl3,3.0.9-1, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl33.0.9-1 debCVE-2007-6755Negligible
libssl1.1,1.1.1d-0+deb10u6, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1d-0+deb10u6 debCVE-2007-6755Negligible
openssl,1.1.1d-0+deb10u6, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1d-0+deb10u6 debCVE-2007-6755Negligible
libssl1.1,1.1.1d-0+deb10u7, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1d-0+deb10u7 debCVE-2007-6755Negligible
libssl1.1,1.1.1d-0+deb10u3, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",libssl1.11.1.1d-0+deb10u3 debCVE-2007-6755Negligible
openssl,1.1.1d-0+deb10u3, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1d-0+deb10u3 debCVE-2007-6755Negligible
openssl,1.1.1d-0+deb10u7, ,deb,CVE-2007-6755,Negligible,2013-10-11T22:55:33.580,"'The NIST SP 800-90A default statement of the Dual Elliptic Curve Deterministic Random Bit Generation (Dual_EC_DRBG) algorithm contains point Q constants with a possible relationship to certain ""skeleton key"" values, which might allow context-dependent attackers to defeat cryptographic protection mechanisms by leveraging knowledge of those values.  NOTE: this is a preliminary CVE for Dual_EC_DRBG; future research may provide additional details about point Q and associated attacks, and could potentially lead to a RECAST or REJECT of this CVE.'",openssl1.1.1d-0+deb10u7 debCVE-2007-6755Negligible
libssl1.1,1.1.1n-0+deb11u3,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1n-0+deb11u3(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1n-0+deb11u3,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1n-0+deb11u3(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1n-0+deb11u5,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1n-0+deb11u5(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1n-0+deb11u5,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1n-0+deb11u5(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1n-0+deb11u4,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1n-0+deb11u4(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1n-0+deb11u4,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1n-0+deb11u4(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1k-1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1k-1(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1n-0+deb11u2,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1n-0+deb11u2(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1n-0+deb11u2,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1n-0+deb11u2(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1n-0+deb11u1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1n-0+deb11u1(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1k-1+deb11u1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1k-1+deb11u1(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1k-1+deb11u1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1k-1+deb11u1(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1n-0+deb11u1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1n-0+deb11u1(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1k-1+deb11u2,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1k-1+deb11u2(won't fix)debCVE-2023-5678Unknown
openssl,1.1.1k-1+deb11u2,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1k-1+deb11u2(won't fix)debCVE-2023-5678Unknown
libssl3,3.0.9-1,(won't fix),deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl33.0.9-1(won't fix)debCVE-2023-5678Unknown
libssl1.1,1.1.1d-0+deb10u6, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1d-0+deb10u6 debCVE-2023-5678Unknown
openssl,1.1.1d-0+deb10u6, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1d-0+deb10u6 debCVE-2023-5678Unknown
libssl1.1,1.1.1d-0+deb10u7, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1d-0+deb10u7 debCVE-2023-5678Unknown
libssl1.1,1.1.1d-0+deb10u3, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",libssl1.11.1.1d-0+deb10u3 debCVE-2023-5678Unknown
openssl,1.1.1d-0+deb10u3, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1d-0+deb10u3 debCVE-2023-5678Unknown
openssl,1.1.1d-0+deb10u7, ,deb,CVE-2023-5678,Unknown,2023-11-06T16:15:42.670,"'Issue summary: Generating excessively long X9.42 DH keys or checking\nexcessively long X9.42 DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_generate_key() to\ngenerate an X9.42 DH key may experience long delays.  Likewise, applications\nthat use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check()\nto check an X9.42 DH key or X9.42 DH parameters may experience long delays.\nWhere the key or parameters that are being checked have been obtained from\nan untrusted source this may lead to a Denial of Service.\n\nWhile DH_check() performs all the necessary checks (as of CVE-2023-3817),\nDH_check_pub_key() doesn\'t make any of these checks, and is therefore\nvulnerable for excessively large P and Q parameters.\n\nLikewise, while DH_generate_key() performs a check for an excessively large\nP, it doesn\'t check for an excessively large Q.\n\nAn application that calls DH_generate_key() or DH_check_pub_key() and\nsupplies a key or parameters obtained from an untrusted source could be\nvulnerable to a Denial of Service attack.\n\nDH_generate_key() and DH_check_pub_key() are also called by a number of\nother OpenSSL functions.  An application calling any of those other\nfunctions may similarly be affected.  The other functions affected by this\nare DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().\n\nAlso vulnerable are the OpenSSL pkey command line application when using the\n""-pubcheck"" option, as well as the OpenSSL genpkey command line application.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.\n\n'",openssl1.1.1d-0+deb10u7 debCVE-2023-5678Unknown
github.com/docker/distribution,v2.8.1+incompatible,2.8.2-beta.1,go-module,CVE-2023-2253,Medium,2023-06-06T20:15:12.493,"'A flaw was found in the `/v2/_catalog` endpoint in distribution/distribution, which accepts a parameter to control the maximum number of records returned (query string: `n`). This vulnerability allows a malicious user to submit an unreasonably large value for `n,` causing the allocation of a massive string array, possibly causing a denial of service through excessive use of memory.'",github.com/docker/distributionv2.8.1+incompatible2.8.2-beta.1go-moduleCVE-2023-2253Medium
golang.org/x/net,v0.3.1-0.20221206200815-1e63c2f08a10,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.3.1-0.20221206200815-1e63c2f08a100.17.0go-moduleCVE-2023-44487High
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.17.0go-moduleCVE-2023-44487High
google.golang.org/grpc,v1.47.0,1.56.3,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",google.golang.org/grpcv1.47.01.56.3go-moduleCVE-2023-44487High
golang.org/x/net,v0.7.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.7.00.17.0go-moduleCVE-2023-44487High
golang.org/x/net,v0.8.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.8.00.17.0go-moduleCVE-2023-44487High
google.golang.org/grpc,v1.49.0,1.56.3,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",google.golang.org/grpcv1.49.01.56.3go-moduleCVE-2023-44487High
golang.org/x/net,v0.1.1-0.20221027164007-c63010009c80,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.1.1-0.20221027164007-c63010009c800.17.0go-moduleCVE-2023-44487High
golang.org/x/net,v0.13.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.13.00.17.0go-moduleCVE-2023-44487High
google.golang.org/grpc,v1.54.0,1.56.3,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",google.golang.org/grpcv1.54.01.56.3go-moduleCVE-2023-44487High
golang.org/x/net,v0.12.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.12.00.17.0go-moduleCVE-2023-44487High
google.golang.org/grpc,v1.51.0,1.56.3,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",google.golang.org/grpcv1.51.01.56.3go-moduleCVE-2023-44487High
golang.org/x/net,v0.9.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.9.00.17.0go-moduleCVE-2023-44487High
golang.org/x/net,v0.4.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.4.00.17.0go-moduleCVE-2023-44487High
golang.org/x/net,v0.5.0,0.17.0,go-module,CVE-2023-44487,High,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",golang.org/x/netv0.5.00.17.0go-moduleCVE-2023-44487High
libnghttp2-14,1.36.0-2+deb10u1,1.36.0-2+deb10u2,deb,CVE-2023-44487,Negligible,2023-10-10T14:15:10.883,"'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.'",libnghttp2-141.36.0-2+deb10u11.36.0-2+deb10u2debCVE-2023-44487Negligible
golang.org/x/net,v0.3.1-0.20221206200815-1e63c2f08a10,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.3.1-0.20221206200815-1e63c2f08a100.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.7.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.7.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.8.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.8.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.1.1-0.20221027164007-c63010009c80,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.1.1-0.20221027164007-c63010009c800.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.13.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.13.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.12.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.12.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.9.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.9.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.4.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.4.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.5.0,0.17.0,go-module,CVE-2023-39325,High,2023-10-11T22:15:09.880,"'A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2. The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.'",golang.org/x/netv0.5.00.17.0go-moduleCVE-2023-39325High
golang.org/x/net,v0.3.1-0.20221206200815-1e63c2f08a10,0.7.0,go-module,CVE-2022-41723,High,2023-02-28T18:15:09.980,"'A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.'",golang.org/x/netv0.3.1-0.20221206200815-1e63c2f08a100.7.0go-moduleCVE-2022-41723High
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.7.0,go-module,CVE-2022-41723,High,2023-02-28T18:15:09.980,"'A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.7.0go-moduleCVE-2022-41723High
golang.org/x/net,v0.1.1-0.20221027164007-c63010009c80,0.7.0,go-module,CVE-2022-41723,High,2023-02-28T18:15:09.980,"'A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.'",golang.org/x/netv0.1.1-0.20221027164007-c63010009c800.7.0go-moduleCVE-2022-41723High
golang.org/x/net,v0.4.0,0.7.0,go-module,CVE-2022-41723,High,2023-02-28T18:15:09.980,"'A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.'",golang.org/x/netv0.4.00.7.0go-moduleCVE-2022-41723High
golang.org/x/net,v0.5.0,0.7.0,go-module,CVE-2022-41723,High,2023-02-28T18:15:09.980,"'A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.'",golang.org/x/netv0.5.00.7.0go-moduleCVE-2022-41723High
golang.org/x/net,v0.3.1-0.20221206200815-1e63c2f08a10,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.3.1-0.20221206200815-1e63c2f08a100.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.7.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.7.00.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.8.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.8.00.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.1.1-0.20221027164007-c63010009c80,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.1.1-0.20221027164007-c63010009c800.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.12.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.12.00.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.9.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.9.00.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.4.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.4.00.13.0go-moduleCVE-2023-3978Medium
golang.org/x/net,v0.5.0,0.13.0,go-module,CVE-2023-3978,Medium,2023-08-02T20:15:12.097,"'Text nodes not in the HTML namespace are incorrectly literally rendered, causing text which should be escaped to not be. This could lead to an XSS attack.'",golang.org/x/netv0.5.00.13.0go-moduleCVE-2023-3978Medium
k8s.io/kubernetes,v1.26.1,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.11.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.4,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.41.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.9,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.91.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.12,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.121.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.6,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.61.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.0-rc,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.0-rc1.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.5,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.51.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.10,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.101.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.3,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.31.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.8,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.81.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.0,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.01.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.2,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.21.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.0-alpha,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.0-alpha1.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.11,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.111.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.7,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.71.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.25.7,1.25.13,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.25.71.25.13go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.0-beta,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.0-beta1.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.5,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.51.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.4,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.41.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.6,1.26.8,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.26.61.26.8go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.28.0,1.28.1,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.28.01.28.1go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.0-alpha,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.0-alpha1.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.3,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.31.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.0-rc,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.0-rc1.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.2,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.21.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.0,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.01.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.1,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.11.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.4,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.41.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.27.0-beta,1.27.5,go-module,CVE-2023-3955,High,2023-10-31T21:15:08.613,'A security issue was discovered in Kubernetes where a user\n that can create pods on Windows nodes may be able to escalate to admin \nprivileges on those nodes. Kubernetes clusters are only affected if they\n include Windows nodes.\n',k8s.io/kubernetesv1.27.0-beta1.27.5go-moduleCVE-2023-3955High
k8s.io/kubernetes,v1.26.1,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.11.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.4,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.41.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.9,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.91.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.6,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.61.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.0-rc,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-rc1.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.5,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.51.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.10,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.101.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.3,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.31.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.8,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.81.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.0,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.01.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.2,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.21.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.0-alpha,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-alpha1.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.25.7,1.25.11,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.71.25.11go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.0-beta,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-beta1.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.5,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.51.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.4,1.26.6,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.41.26.6go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.0-alpha,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-alpha1.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.0-rc,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-rc1.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.2,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.21.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.0,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.01.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.1,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.11.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.27.0-beta,1.27.3,go-module,CVE-2023-2728,Medium,2023-07-03T21:15:09.557,'Users may be able to launch containers that bypass the mountable secrets policy enforced by the ServiceAccount admission plugin when using ephemeral containers. The policy ensures pods running with a service account may only reference secrets specified in the service accounts secrets field. Kubernetes clusters are only affected if the ServiceAccount admission plugin and the `kubernetes.io/enforce-mountable-secrets` annotation are used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-beta1.27.3go-moduleCVE-2023-2728Medium
k8s.io/kubernetes,v1.26.1,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.11.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.4,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.41.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.9,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.91.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.6,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.61.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.0-rc,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-rc1.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.5,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.51.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.10,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.101.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.3,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.31.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.8,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.81.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.0,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.01.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.2,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.21.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.0-alpha,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-alpha1.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.25.7,1.25.11,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.25.71.25.11go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.0-beta,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.0-beta1.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.5,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.51.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.4,1.26.6,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.26.41.26.6go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.0-alpha,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-alpha1.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.0-rc,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-rc1.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.2,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.21.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.0,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.01.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.1,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.11.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.27.0-beta,1.27.3,go-module,CVE-2023-2727,Medium,2023-07-03T21:15:09.480,'Users may be able to launch containers using images that are restricted by ImagePolicyWebhook when using ephemeral containers. Kubernetes clusters are only affected if the ImagePolicyWebhook admission plugin is used together with ephemeral containers.\n\n',k8s.io/kubernetesv1.27.0-beta1.27.3go-moduleCVE-2023-2727Medium
k8s.io/kubernetes,v1.26.1,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.11.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.4,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.41.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.9,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.91.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.6,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.61.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.0-rc,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.0-rc1.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.5,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.51.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.3,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.31.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.8,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.81.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.0,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.01.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.2,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.21.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.0-alpha,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.0-alpha1.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.25.7,1.25.10,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.25.71.25.10go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.0-beta,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.0-beta1.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.26.4,1.26.5,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.26.41.26.5go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.27.0-alpha,1.27.2,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.27.0-alpha1.27.2go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.27.0-rc,1.27.2,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.27.0-rc1.27.2go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.27.0,1.27.2,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.27.01.27.2go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.27.1,1.27.2,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.27.11.27.2go-moduleCVE-2023-2431Medium
k8s.io/kubernetes,v1.27.0-beta,1.27.2,go-module,CVE-2023-2431,Medium,2023-06-16T08:15:08.770,"'A security issue was discovered in Kubelet that allows pods to bypass the seccomp profile enforcement. Pods that use localhost type for seccomp profile but specify an empty profile field, are affected by this issue. In this scenario, this vulnerability allows the pod to run in unconfined (seccomp disabled) mode. This bug affects Kubelet.'",k8s.io/kubernetesv1.27.0-beta1.27.2go-moduleCVE-2023-2431Medium
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp,v0.20.0,0.44.0,go-module,CVE-2023-45142,High,2023-10-12T17:15:09.990,"""OpenTelemetry-Go Contrib is a collection of third-party packages for OpenTelemetry-Go. A handler wrapper out of the box adds labels `http.user_agent` and `http.method` that have unbound cardinality. It leads to the server's potential memory exhaustion when many malicious requests are sent to it. HTTP header User-Agent or HTTP method for requests can be easily set by an attacker to be random and long. The library internally uses `httpconv.ServerRequest` that records every value for HTTP `method` and `User-Agent`. In order to be affected, a program has to use the `otelhttp.NewHandler` wrapper and not filter any unknown HTTP methods or User agents on the level of CDN, LB, previous middleware, etc. Version 0.44.0 fixed this issue when the values collected for attribute `http.request.method` were changed to be restricted to a set of well-known values and other high cardinality attributes were removed. As a workaround to stop being affected, `otelhttp.WithFilter()` can be used, but it requires manual careful configuration to not log certain requests entirely. For convenience and safe usage of this library, it should by default mark with the label `unknown` non-standard HTTP methods and User agents to show that such requests were made but do not increase cardinality. In case someone wants to stay with the current behavior, library API should allow to enable it.""",go.opentelemetry.io/contrib/instrumentation/net/http/otelhttpv0.20.00.44.0go-moduleCVE-2023-45142High
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp,v0.35.0,0.44.0,go-module,CVE-2023-45142,High,2023-10-12T17:15:09.990,"""OpenTelemetry-Go Contrib is a collection of third-party packages for OpenTelemetry-Go. A handler wrapper out of the box adds labels `http.user_agent` and `http.method` that have unbound cardinality. It leads to the server's potential memory exhaustion when many malicious requests are sent to it. HTTP header User-Agent or HTTP method for requests can be easily set by an attacker to be random and long. The library internally uses `httpconv.ServerRequest` that records every value for HTTP `method` and `User-Agent`. In order to be affected, a program has to use the `otelhttp.NewHandler` wrapper and not filter any unknown HTTP methods or User agents on the level of CDN, LB, previous middleware, etc. Version 0.44.0 fixed this issue when the values collected for attribute `http.request.method` were changed to be restricted to a set of well-known values and other high cardinality attributes were removed. As a workaround to stop being affected, `otelhttp.WithFilter()` can be used, but it requires manual careful configuration to not log certain requests entirely. For convenience and safe usage of this library, it should by default mark with the label `unknown` non-standard HTTP methods and User agents to show that such requests were made but do not increase cardinality. In case someone wants to stay with the current behavior, library API should allow to enable it.""",go.opentelemetry.io/contrib/instrumentation/net/http/otelhttpv0.35.00.44.0go-moduleCVE-2023-45142High
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp,v0.35.1,0.44.0,go-module,CVE-2023-45142,High,2023-10-12T17:15:09.990,"""OpenTelemetry-Go Contrib is a collection of third-party packages for OpenTelemetry-Go. A handler wrapper out of the box adds labels `http.user_agent` and `http.method` that have unbound cardinality. It leads to the server's potential memory exhaustion when many malicious requests are sent to it. HTTP header User-Agent or HTTP method for requests can be easily set by an attacker to be random and long. The library internally uses `httpconv.ServerRequest` that records every value for HTTP `method` and `User-Agent`. In order to be affected, a program has to use the `otelhttp.NewHandler` wrapper and not filter any unknown HTTP methods or User agents on the level of CDN, LB, previous middleware, etc. Version 0.44.0 fixed this issue when the values collected for attribute `http.request.method` were changed to be restricted to a set of well-known values and other high cardinality attributes were removed. As a workaround to stop being affected, `otelhttp.WithFilter()` can be used, but it requires manual careful configuration to not log certain requests entirely. For convenience and safe usage of this library, it should by default mark with the label `unknown` non-standard HTTP methods and User agents to show that such requests were made but do not increase cardinality. In case someone wants to stay with the current behavior, library API should allow to enable it.""",go.opentelemetry.io/contrib/instrumentation/net/http/otelhttpv0.35.10.44.0go-moduleCVE-2023-45142High
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.1.1-0.20221104162952-702349b0e862,go-module,CVE-2022-41721,High,2023-01-13T23:15:09.250,"'A request smuggling attack is possible when using MaxBytesHandler. When using MaxBytesHandler, the body of an HTTP request is not fully consumed. When the server attempts to read HTTP2 frames from the connection, it will instead be reading the body of the HTTP request, which could be attacker-manipulated to represent arbitrary HTTP2 requests.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.1.1-0.20221104162952-702349b0e862go-moduleCVE-2022-41721High
golang.org/x/net,v0.1.1-0.20221027164007-c63010009c80,0.1.1-0.20221104162952-702349b0e862,go-module,CVE-2022-41721,High,2023-01-13T23:15:09.250,"'A request smuggling attack is possible when using MaxBytesHandler. When using MaxBytesHandler, the body of an HTTP request is not fully consumed. When the server attempts to read HTTP2 frames from the connection, it will instead be reading the body of the HTTP request, which could be attacker-manipulated to represent arbitrary HTTP2 requests.'",golang.org/x/netv0.1.1-0.20221027164007-c63010009c800.1.1-0.20221104162952-702349b0e862go-moduleCVE-2022-41721High
golang.org/x/net,v0.0.0-20220722155237-a158d28d115b,0.0.0-20220906165146-f3363e06e74c,go-module,CVE-2022-27664,High,2022-09-06T18:15:12.747,"'In net/http in Go before 1.18.6 and 1.19.x before 1.19.1, attackers can cause a denial of service because an HTTP/2 connection can hang during closing if shutdown were preempted by a fatal error.'",golang.org/x/netv0.0.0-20220722155237-a158d28d115b0.0.0-20220906165146-f3363e06e74cgo-moduleCVE-2022-27664High
golang.org/x/text,v0.3.7,0.3.8,go-module,CVE-2022-32149,High,2022-10-14T15:15:34.543,'An attacker may cause a denial of service by crafting an Accept-Language header which ParseAcceptLanguage will take significant time to parse.',golang.org/x/textv0.3.70.3.8go-moduleCVE-2022-32149High
k8s.io/kubernetes,v1.25.4,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.41.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.9,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.91.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.12,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.121.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.6,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.61.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.5,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.51.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.10,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.101.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.14,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.141.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.13,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.131.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.8,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.81.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.26.0,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.26.01.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.26.0-alpha,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.26.0-alpha1.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.11,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.111.26.0-alpha.3go-moduleCVE-2021-25743Low
k8s.io/kubernetes,v1.25.7,1.26.0-alpha.3,go-module,CVE-2021-25743,Low,2022-01-07T00:15:07.817,"'kubectl does not neutralize escape, meta or control sequences contained in the raw data it outputs to a terminal. This includes but is not limited to the unstructured string fields in objects such as Events.'",k8s.io/kubernetesv1.25.71.26.0-alpha.3go-moduleCVE-2021-25743Low
github.com/opencontainers/runc,v1.1.4,1.1.5,go-module,CVE-2023-28642,High,2023-03-29T19:15:22.397,"'runc is a CLI tool for spawning and running containers according to the OCI specification. It was found that AppArmor can be bypassed when `/proc` inside the container is symlinked with a specific mount configuration. This issue has been fixed in runc version 1.1.5, by prohibiting symlinked `/proc`. See PR #3785 for details. users are advised to upgrade. Users unable to upgrade should avoid using an untrusted container image.\n\n'",github.com/opencontainers/runcv1.1.41.1.5go-moduleCVE-2023-28642High
github.com/opencontainers/runc,v1.1.3,1.1.5,go-module,CVE-2023-28642,High,2023-03-29T19:15:22.397,"'runc is a CLI tool for spawning and running containers according to the OCI specification. It was found that AppArmor can be bypassed when `/proc` inside the container is symlinked with a specific mount configuration. This issue has been fixed in runc version 1.1.5, by prohibiting symlinked `/proc`. See PR #3785 for details. users are advised to upgrade. Users unable to upgrade should avoid using an untrusted container image.\n\n'",github.com/opencontainers/runcv1.1.31.1.5go-moduleCVE-2023-28642High
github.com/opencontainers/runc,v1.1.4,1.1.5,go-module,CVE-2023-27561,High,2023-03-03T19:15:11.330,"'runc through 1.1.4 has Incorrect Access Control leading to Escalation of Privileges, related to libcontainer/rootfs_linux.go. To exploit this, an attacker must be able to spawn two containers with custom volume-mount configurations, and be able to run custom images. NOTE: this issue exists because of a CVE-2019-19921 regression.'",github.com/opencontainers/runcv1.1.41.1.5go-moduleCVE-2023-27561High
github.com/opencontainers/runc,v1.1.3,1.1.5,go-module,CVE-2023-27561,High,2023-03-03T19:15:11.330,"'runc through 1.1.4 has Incorrect Access Control leading to Escalation of Privileges, related to libcontainer/rootfs_linux.go. To exploit this, an attacker must be able to spawn two containers with custom volume-mount configurations, and be able to run custom images. NOTE: this issue exists because of a CVE-2019-19921 regression.'",github.com/opencontainers/runcv1.1.31.1.5go-moduleCVE-2023-27561High
github.com/opencontainers/runc,v1.1.4,1.1.5,go-module,CVE-2023-25809,Medium,2023-03-29T19:15:22.170,"""runc is a CLI tool for spawning and running containers according to the OCI specification. In affected versions it was found that rootless runc makes `/sys/fs/cgroup` writable in following conditons: 1. when runc is executed inside the user namespace, and the `config.json` does not specify the cgroup namespace to be unshared (e.g.., `(docker|podman|nerdctl) run --cgroupns=host`, with Rootless Docker/Podman/nerdctl) or 2. when runc is executed outside the user namespace, and `/sys` is mounted with `rbind, ro` (e.g., `runc spec --rootless`; this condition is very rare). A container may gain the write access to user-owned cgroup hierarchy `/sys/fs/cgroup/user.slice/...` on the host . Other users's cgroup hierarchies are not affected. Users are advised to upgrade to version 1.1.5. Users unable to upgrade may unshare the cgroup namespace (`(docker|podman|nerdctl) run --cgroupns=private)`. This is the default behavior of Docker/Podman/nerdctl on cgroup v2 hosts. or add `/sys/fs/cgroup` to `maskedPaths`.\n""",github.com/opencontainers/runcv1.1.41.1.5go-moduleCVE-2023-25809Medium
github.com/opencontainers/runc,v1.1.3,1.1.5,go-module,CVE-2023-25809,Medium,2023-03-29T19:15:22.170,"""runc is a CLI tool for spawning and running containers according to the OCI specification. In affected versions it was found that rootless runc makes `/sys/fs/cgroup` writable in following conditons: 1. when runc is executed inside the user namespace, and the `config.json` does not specify the cgroup namespace to be unshared (e.g.., `(docker|podman|nerdctl) run --cgroupns=host`, with Rootless Docker/Podman/nerdctl) or 2. when runc is executed outside the user namespace, and `/sys` is mounted with `rbind, ro` (e.g., `runc spec --rootless`; this condition is very rare). A container may gain the write access to user-owned cgroup hierarchy `/sys/fs/cgroup/user.slice/...` on the host . Other users's cgroup hierarchies are not affected. Users are advised to upgrade to version 1.1.5. Users unable to upgrade may unshare the cgroup namespace (`(docker|podman|nerdctl) run --cgroupns=private)`. This is the default behavior of Docker/Podman/nerdctl on cgroup v2 hosts. or add `/sys/fs/cgroup` to `maskedPaths`.\n""",github.com/opencontainers/runcv1.1.31.1.5go-moduleCVE-2023-25809Medium
apt,2.2.4, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",apt2.2.4 debCVE-2011-3374Negligible
libapt-pkg6.0,2.2.4, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",libapt-pkg6.02.2.4 debCVE-2011-3374Negligible
apt,2.6.1, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",apt2.6.1 debCVE-2011-3374Negligible
libapt-pkg6.0,2.6.1, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",libapt-pkg6.02.6.1 debCVE-2011-3374Negligible
apt,1.8.2.3, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",apt1.8.2.3 debCVE-2011-3374Negligible
libapt-pkg5.0,1.8.2.3, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",libapt-pkg5.01.8.2.3 debCVE-2011-3374Negligible
apt,1.8.2.1, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",apt1.8.2.1 debCVE-2011-3374Negligible
libapt-pkg5.0,1.8.2.1, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",libapt-pkg5.01.8.2.1 debCVE-2011-3374Negligible
apt,1.4.11, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",apt1.4.11 debCVE-2011-3374Negligible
libapt-pkg5.0,1.4.11, ,deb,CVE-2011-3374,Negligible,2019-11-26T00:15:11.030,"'It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.'",libapt-pkg5.01.4.11 debCVE-2011-3374Negligible
bsdutils,1:2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",bsdutils1:2.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
libblkid1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",libblkid12.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
libmount1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",libmount12.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
libsmartcols1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",libsmartcols12.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
libuuid1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",libuuid12.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
mount,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",mount2.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
util-linux,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3996,Medium,2022-08-23T20:15:08.560,"""A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.""",util-linux2.36.1-82.36.1-8+deb11u1debCVE-2021-3996Medium
bsdutils,1:2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',bsdutils1:2.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
libblkid1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',libblkid12.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
libmount1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',libmount12.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
libsmartcols1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',libsmartcols12.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
libuuid1,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',libuuid12.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
mount,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',mount2.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
util-linux,2.36.1-8,2.36.1-8+deb11u1,deb,CVE-2021-3995,Medium,2022-08-23T20:15:08.493,'A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.',util-linux2.36.1-82.36.1-8+deb11u1debCVE-2021-3995Medium
bsdutils,1:2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",bsdutils1:2.36.1-8 debCVE-2022-0563Negligible
bsdutils,1:2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",bsdutils1:2.36.1-8+deb11u1 debCVE-2022-0563Negligible
bsdutils,1:2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",bsdutils1:2.38.1-5+b1 debCVE-2022-0563Negligible
libblkid1,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libblkid12.38.1-5+b1 debCVE-2022-0563Negligible
libmount1,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libmount12.38.1-5+b1 debCVE-2022-0563Negligible
libsmartcols1,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libsmartcols12.38.1-5+b1 debCVE-2022-0563Negligible
libuuid1,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libuuid12.38.1-5+b1 debCVE-2022-0563Negligible
mount,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",mount2.38.1-5+b1 debCVE-2022-0563Negligible
util-linux,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux2.38.1-5+b1 debCVE-2022-0563Negligible
util-linux-extra,2.38.1-5+b1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux-extra2.38.1-5+b1 debCVE-2022-0563Negligible
bsdutils,1:2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",bsdutils1:2.33.1-0.1 debCVE-2022-0563Negligible
libblkid1,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libblkid12.36.1-8+deb11u1 debCVE-2022-0563Negligible
libmount1,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libmount12.36.1-8+deb11u1 debCVE-2022-0563Negligible
libsmartcols1,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libsmartcols12.36.1-8+deb11u1 debCVE-2022-0563Negligible
libuuid1,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libuuid12.36.1-8+deb11u1 debCVE-2022-0563Negligible
mount,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",mount2.36.1-8+deb11u1 debCVE-2022-0563Negligible
util-linux,2.36.1-8+deb11u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux2.36.1-8+deb11u1 debCVE-2022-0563Negligible
libblkid1,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libblkid12.36.1-8 debCVE-2022-0563Negligible
libmount1,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libmount12.36.1-8 debCVE-2022-0563Negligible
libsmartcols1,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libsmartcols12.36.1-8 debCVE-2022-0563Negligible
libuuid1,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libuuid12.36.1-8 debCVE-2022-0563Negligible
mount,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",mount2.36.1-8 debCVE-2022-0563Negligible
util-linux,2.36.1-8, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux2.36.1-8 debCVE-2022-0563Negligible
bsdutils,1:2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",bsdutils1:2.29.2-1+deb9u1 debCVE-2022-0563Negligible
libblkid1,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libblkid12.29.2-1+deb9u1 debCVE-2022-0563Negligible
libfdisk1,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libfdisk12.29.2-1+deb9u1 debCVE-2022-0563Negligible
libmount1,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libmount12.29.2-1+deb9u1 debCVE-2022-0563Negligible
libsmartcols1,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libsmartcols12.29.2-1+deb9u1 debCVE-2022-0563Negligible
libuuid1,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libuuid12.29.2-1+deb9u1 debCVE-2022-0563Negligible
mount,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",mount2.29.2-1+deb9u1 debCVE-2022-0563Negligible
util-linux,2.29.2-1+deb9u1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux2.29.2-1+deb9u1 debCVE-2022-0563Negligible
fdisk,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",fdisk2.33.1-0.1 debCVE-2022-0563Negligible
libblkid1,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libblkid12.33.1-0.1 debCVE-2022-0563Negligible
libfdisk1,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libfdisk12.33.1-0.1 debCVE-2022-0563Negligible
libmount1,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libmount12.33.1-0.1 debCVE-2022-0563Negligible
libsmartcols1,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libsmartcols12.33.1-0.1 debCVE-2022-0563Negligible
libuuid1,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",libuuid12.33.1-0.1 debCVE-2022-0563Negligible
mount,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",mount2.33.1-0.1 debCVE-2022-0563Negligible
util-linux,2.33.1-0.1, ,deb,CVE-2022-0563,Negligible,2022-02-21T19:15:08.393,"'A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an ""INPUTRC"" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.'",util-linux2.33.1-0.1 debCVE-2022-0563Negligible
coreutils,8.32-4+b1,(won't fix),deb,CVE-2016-2781,Low,2017-02-07T15:59:00.333,"""chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",coreutils8.32-4+b1(won't fix)debCVE-2016-2781Low
coreutils,8.32-4,(won't fix),deb,CVE-2016-2781,Low,2017-02-07T15:59:00.333,"""chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",coreutils8.32-4(won't fix)debCVE-2016-2781Low
coreutils,9.1-1,(won't fix),deb,CVE-2016-2781,Low,2017-02-07T15:59:00.333,"""chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",coreutils9.1-1(won't fix)debCVE-2016-2781Low
coreutils,8.30-3,(won't fix),deb,CVE-2016-2781,Low,2017-02-07T15:59:00.333,"""chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",coreutils8.30-3(won't fix)debCVE-2016-2781Low
coreutils,8.26-3,(won't fix),deb,CVE-2016-2781,Low,2017-02-07T15:59:00.333,"""chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",coreutils8.26-3(won't fix)debCVE-2016-2781Low
coreutils,8.32-4+b1, ,deb,CVE-2017-18018,Negligible,2018-01-04T04:29:00.190,"'In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX ""-R -L"" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.'",coreutils8.32-4+b1 debCVE-2017-18018Negligible
coreutils,8.32-4, ,deb,CVE-2017-18018,Negligible,2018-01-04T04:29:00.190,"'In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX ""-R -L"" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.'",coreutils8.32-4 debCVE-2017-18018Negligible
coreutils,9.1-1, ,deb,CVE-2017-18018,Negligible,2018-01-04T04:29:00.190,"'In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX ""-R -L"" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.'",coreutils9.1-1 debCVE-2017-18018Negligible
coreutils,8.30-3, ,deb,CVE-2017-18018,Negligible,2018-01-04T04:29:00.190,"'In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX ""-R -L"" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.'",coreutils8.30-3 debCVE-2017-18018Negligible
coreutils,8.26-3, ,deb,CVE-2017-18018,Negligible,2018-01-04T04:29:00.190,"'In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX ""-R -L"" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.'",coreutils8.26-3 debCVE-2017-18018Negligible
dpkg,1.20.9,1.20.10,deb,CVE-2022-1664,Critical,2022-05-26T14:15:08.010,"'Dpkg::Source::Archive in dpkg, the Debian package management system, before version 1.21.8, 1.20.10, 1.19.8, 1.18.26 is prone to a directory traversal vulnerability. When extracting untrusted source packages in v2 and v3 source package formats that include a debian.tar, the in-place extraction can lead to directory traversal situations on specially crafted orig.tar and debian.tar tarballs.'",dpkg1.20.91.20.10debCVE-2022-1664Critical
dpkg,1.19.7,1.19.8,deb,CVE-2022-1664,Critical,2022-05-26T14:15:08.010,"'Dpkg::Source::Archive in dpkg, the Debian package management system, before version 1.21.8, 1.20.10, 1.19.8, 1.18.26 is prone to a directory traversal vulnerability. When extracting untrusted source packages in v2 and v3 source package formats that include a debian.tar, the in-place extraction can lead to directory traversal situations on specially crafted orig.tar and debian.tar tarballs.'",dpkg1.19.71.19.8debCVE-2022-1664Critical
dpkg,1.18.25,1.18.26,deb,CVE-2022-1664,Critical,2022-05-26T14:15:08.010,"'Dpkg::Source::Archive in dpkg, the Debian package management system, before version 1.21.8, 1.20.10, 1.19.8, 1.18.26 is prone to a directory traversal vulnerability. When extracting untrusted source packages in v2 and v3 source package formats that include a debian.tar, the in-place extraction can lead to directory traversal situations on specially crafted orig.tar and debian.tar tarballs.'",dpkg1.18.251.18.26debCVE-2022-1664Critical
gcc-10-base,10.2.1-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",gcc-10-base10.2.1-6(won't fix)debCVE-2023-4039Medium
gcc-9-base,9.3.0-22,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",gcc-9-base9.3.0-22(won't fix)debCVE-2023-4039Medium
libgcc-s1,10.2.1-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libgcc-s110.2.1-6(won't fix)debCVE-2023-4039Medium
libstdc++6,10.2.1-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libstdc++610.2.1-6(won't fix)debCVE-2023-4039Medium
gcc-12-base,12.2.0-14,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",gcc-12-base12.2.0-14(won't fix)debCVE-2023-4039Medium
libgcc-s1,12.2.0-14,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libgcc-s112.2.0-14(won't fix)debCVE-2023-4039Medium
libstdc++6,12.2.0-14,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libstdc++612.2.0-14(won't fix)debCVE-2023-4039Medium
gcc-8-base,8.3.0-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",gcc-8-base8.3.0-6(won't fix)debCVE-2023-4039Medium
libgcc1,1:8.3.0-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libgcc11:8.3.0-6(won't fix)debCVE-2023-4039Medium
libstdc++6,8.3.0-6,(won't fix),deb,CVE-2023-4039,Medium,2023-09-13T09:15:15.690,"'\n\nA failure in the -fstack-protector feature in GCC-based toolchains \nthat target AArch64 allows an attacker to exploit an existing buffer \noverflow in dynamically-sized local variables in your application \nwithout this being detected. This stack-protector failure only applies \nto C99-style dynamically-sized local variables or those created using \nalloca(). The stack-protector operates as intended for statically-sized \nlocal variables.\n\nThe default behavior when the stack-protector \ndetects an overflow is to terminate your application, resulting in \ncontrolled loss of availability. An attacker who can exploit a buffer \noverflow without triggering the stack-protector might be able to change \nprogram flow control to cause an uncontrolled loss of availability or to\n go further and affect confidentiality or integrity.\n\n\n\n\n\n'",libstdc++68.3.0-6(won't fix)debCVE-2023-4039Medium
gpgv,2.2.27-2,2.2.27-2+deb11u2,deb,CVE-2022-34903,Medium,2022-07-01T22:15:08.120,"""GnuPG through 2.3.6, in unusual situations where an attacker possesses any secret-key information from a victim's keyring and other constraints (e.g., use of GPGME) are met, allows signature forgery via injection into the status line.""",gpgv2.2.27-22.2.27-2+deb11u2debCVE-2022-34903Medium
gpgv,2.2.27-2+deb11u1,2.2.27-2+deb11u2,deb,CVE-2022-34903,Medium,2022-07-01T22:15:08.120,"""GnuPG through 2.3.6, in unusual situations where an attacker possesses any secret-key information from a victim's keyring and other constraints (e.g., use of GPGME) are met, allows signature forgery via injection into the status line.""",gpgv2.2.27-2+deb11u12.2.27-2+deb11u2debCVE-2022-34903Medium
gpgv,2.2.12-1+deb10u1,2.2.12-1+deb10u2,deb,CVE-2022-34903,Medium,2022-07-01T22:15:08.120,"""GnuPG through 2.3.6, in unusual situations where an attacker possesses any secret-key information from a victim's keyring and other constraints (e.g., use of GPGME) are met, allows signature forgery via injection into the status line.""",gpgv2.2.12-1+deb10u12.2.12-1+deb10u2debCVE-2022-34903Medium
gpgv,2.1.18-8~deb9u4, ,deb,CVE-2022-34903,Medium,2022-07-01T22:15:08.120,"""GnuPG through 2.3.6, in unusual situations where an attacker possesses any secret-key information from a victim's keyring and other constraints (e.g., use of GPGME) are met, allows signature forgery via injection into the status line.""",gpgv2.1.18-8~deb9u4 debCVE-2022-34903Medium
gpgv,2.2.27-2, ,deb,CVE-2022-3219,Negligible,2023-02-23T20:15:12.393,"'GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.'",gpgv2.2.27-2 debCVE-2022-3219Negligible
gpgv,2.2.27-2+deb11u1, ,deb,CVE-2022-3219,Negligible,2023-02-23T20:15:12.393,"'GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.'",gpgv2.2.27-2+deb11u1 debCVE-2022-3219Negligible
gpgv,2.2.40-1.1, ,deb,CVE-2022-3219,Negligible,2023-02-23T20:15:12.393,"'GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.'",gpgv2.2.40-1.1 debCVE-2022-3219Negligible
gpgv,2.2.12-1+deb10u1, ,deb,CVE-2022-3219,Negligible,2023-02-23T20:15:12.393,"'GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.'",gpgv2.2.12-1+deb10u1 debCVE-2022-3219Negligible
gzip,1.10-4,1.10-4+deb11u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",gzip1.10-41.10-4+deb11u1debCVE-2022-1271High
liblzma5,5.2.5-2,5.2.5-2.1~deb11u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",liblzma55.2.5-25.2.5-2.1~deb11u1debCVE-2022-1271High
gzip,1.9-3,1.9-3+deb10u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",gzip1.9-31.9-3+deb10u1debCVE-2022-1271High
liblzma5,5.2.4-1,5.2.4-1+deb10u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",liblzma55.2.4-15.2.4-1+deb10u1debCVE-2022-1271High
gzip,1.6-5+b1,1.6-5+deb9u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",gzip1.6-5+b11.6-5+deb9u1debCVE-2022-1271High
liblzma5,5.2.2-1.2+b1,5.2.2-1.2+deb9u1,deb,CVE-2022-1271,High,2022-08-31T16:15:09.347,"""An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.""",liblzma55.2.2-1.2+b15.2.2-1.2+deb9u1debCVE-2022-1271High
iptables,1.8.7-1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",iptables1.8.7-1 debCVE-2012-2663Negligible
libip4tc2,1.8.7-1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip4tc21.8.7-1 debCVE-2012-2663Negligible
libip6tc2,1.8.7-1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip6tc21.8.7-1 debCVE-2012-2663Negligible
libxtables12,1.8.7-1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libxtables121.8.7-1 debCVE-2012-2663Negligible
iptables,1.8.9-2, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",iptables1.8.9-2 debCVE-2012-2663Negligible
libip4tc2,1.8.9-2, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip4tc21.8.9-2 debCVE-2012-2663Negligible
libip6tc2,1.8.9-2, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip6tc21.8.9-2 debCVE-2012-2663Negligible
libxtables12,1.8.9-2, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libxtables121.8.9-2 debCVE-2012-2663Negligible
iptables,1.8.5-3~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",iptables1.8.5-3~bpo10+1 debCVE-2012-2663Negligible
libip4tc2,1.8.5-3~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip4tc21.8.5-3~bpo10+1 debCVE-2012-2663Negligible
libip6tc2,1.8.5-3~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip6tc21.8.5-3~bpo10+1 debCVE-2012-2663Negligible
libxtables12,1.8.5-3~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libxtables121.8.5-3~bpo10+1 debCVE-2012-2663Negligible
iptables,1.8.3-2~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",iptables1.8.3-2~bpo10+1 debCVE-2012-2663Negligible
libip4tc2,1.8.3-2~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip4tc21.8.3-2~bpo10+1 debCVE-2012-2663Negligible
libip6tc2,1.8.3-2~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libip6tc21.8.3-2~bpo10+1 debCVE-2012-2663Negligible
libiptc0,1.8.3-2~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libiptc01.8.3-2~bpo10+1 debCVE-2012-2663Negligible
libxtables12,1.8.3-2~bpo10+1, ,deb,CVE-2012-2663,Negligible,2014-02-15T14:57:07.423,"'extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.'",libxtables121.8.3-2~bpo10+1 debCVE-2012-2663Negligible
libc-bin,2.31-13,2.31-13+deb11u3,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.31-132.31-13+deb11u3debCVE-2022-23219Critical
libc6,2.31-13,2.31-13+deb11u3,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.31-132.31-13+deb11u3debCVE-2022-23219Critical
libc6,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.31-13+deb11u22.31-13+deb11u3debCVE-2022-23219Critical
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.28-102.28-10+deb10u2debCVE-2022-23219Critical
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.28-102.28-10+deb10u2debCVE-2022-23219Critical
libc-bin,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.31-13+deb11u22.31-13+deb11u3debCVE-2022-23219Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2022-23219Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.24-11+deb9u4(won't fix)debCVE-2022-23219Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2022-23219Critical
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2022-23219Critical
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23219,Critical,2022-01-14T07:15:08.867,"'The deprecated compatibility function clnt_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its hostname argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2022-23219Critical
libc-bin,2.31-13,2.31-13+deb11u3,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.31-132.31-13+deb11u3debCVE-2022-23218Critical
libc6,2.31-13,2.31-13+deb11u3,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.31-132.31-13+deb11u3debCVE-2022-23218Critical
libc6,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.31-13+deb11u22.31-13+deb11u3debCVE-2022-23218Critical
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.28-102.28-10+deb10u2debCVE-2022-23218Critical
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.28-102.28-10+deb10u2debCVE-2022-23218Critical
libc-bin,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.31-13+deb11u22.31-13+deb11u3debCVE-2022-23218Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2022-23218Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc62.24-11+deb9u4(won't fix)debCVE-2022-23218Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2022-23218Critical
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2022-23218Critical
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2022-23218,Critical,2022-01-14T07:15:08.800,"'The deprecated compatibility function svcunix_create in the sunrpc module of the GNU C Library (aka glibc) through 2.34 copies its path argument on the stack without validating its length, which may result in a buffer overflow, potentially resulting in a denial of service or (if an application is not built with a stack protector enabled) arbitrary code execution.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2022-23218Critical
libc-bin,2.31-13,2.31-13+deb11u3,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc-bin2.31-132.31-13+deb11u3debCVE-2021-33574Critical
libc6,2.31-13,2.31-13+deb11u3,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc62.31-132.31-13+deb11u3debCVE-2021-33574Critical
libc6,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc62.31-13+deb11u22.31-13+deb11u3debCVE-2021-33574Critical
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc-bin2.28-102.28-10+deb10u2debCVE-2021-33574Critical
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc62.28-102.28-10+deb10u2debCVE-2021-33574Critical
libc-bin,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc-bin2.31-13+deb11u22.31-13+deb11u3debCVE-2021-33574Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2021-33574Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc62.24-11+deb9u4(won't fix)debCVE-2021-33574Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2021-33574Critical
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2021-33574Critical
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2021-33574,Critical,2021-05-25T22:15:10.410,"'The mq_notify function in the GNU C Library (aka glibc) versions 2.32 and 2.33 has a use-after-free. It may use the notification thread attributes object (passed through its struct sigevent parameter) after it has been freed by the caller, leading to a denial of service (application crash) or possibly unspecified other impact.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2021-33574Critical
libc-bin,2.31-13,2.31-13+deb11u3,deb,CVE-2021-43396,High,2021-11-04T20:15:09.223,"'In iconvdata/iso-2022-jp-3.c in the GNU C Library (aka glibc) 2.34, remote attackers can force iconv() to emit a spurious \'\\0\' character via crafted ISO-2022-JP-3 data that is accompanied by an internal state reset. This may affect data integrity in certain iconv() use cases. NOTE: the vendor states ""the bug cannot be invoked through user input and requires iconv to be invoked with a NULL inbuf, which ought to require a separate application bug to do so unintentionally. Hence there\'s no security impact to the bug.'",libc-bin2.31-132.31-13+deb11u3debCVE-2021-43396High
libc6,2.31-13,2.31-13+deb11u3,deb,CVE-2021-43396,High,2021-11-04T20:15:09.223,"'In iconvdata/iso-2022-jp-3.c in the GNU C Library (aka glibc) 2.34, remote attackers can force iconv() to emit a spurious \'\\0\' character via crafted ISO-2022-JP-3 data that is accompanied by an internal state reset. This may affect data integrity in certain iconv() use cases. NOTE: the vendor states ""the bug cannot be invoked through user input and requires iconv to be invoked with a NULL inbuf, which ought to require a separate application bug to do so unintentionally. Hence there\'s no security impact to the bug.'",libc62.31-132.31-13+deb11u3debCVE-2021-43396High
libc6,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2021-43396,High,2021-11-04T20:15:09.223,"'In iconvdata/iso-2022-jp-3.c in the GNU C Library (aka glibc) 2.34, remote attackers can force iconv() to emit a spurious \'\\0\' character via crafted ISO-2022-JP-3 data that is accompanied by an internal state reset. This may affect data integrity in certain iconv() use cases. NOTE: the vendor states ""the bug cannot be invoked through user input and requires iconv to be invoked with a NULL inbuf, which ought to require a separate application bug to do so unintentionally. Hence there\'s no security impact to the bug.'",libc62.31-13+deb11u22.31-13+deb11u3debCVE-2021-43396High
libc-bin,2.31-13+deb11u2,2.31-13+deb11u3,deb,CVE-2021-43396,High,2021-11-04T20:15:09.223,"'In iconvdata/iso-2022-jp-3.c in the GNU C Library (aka glibc) 2.34, remote attackers can force iconv() to emit a spurious \'\\0\' character via crafted ISO-2022-JP-3 data that is accompanied by an internal state reset. This may affect data integrity in certain iconv() use cases. NOTE: the vendor states ""the bug cannot be invoked through user input and requires iconv to be invoked with a NULL inbuf, which ought to require a separate application bug to do so unintentionally. Hence there\'s no security impact to the bug.'",libc-bin2.31-13+deb11u22.31-13+deb11u3debCVE-2021-43396High
libc-bin,2.31-13,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-bin2.31-132.31-13+deb11u4debCVE-2021-3999High
libc6,2.31-13,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc62.31-132.31-13+deb11u4debCVE-2021-3999High
libc6,2.31-13+deb11u3,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc62.31-13+deb11u32.31-13+deb11u4debCVE-2021-3999High
libc-bin,2.31-13+deb11u3,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-bin2.31-13+deb11u32.31-13+deb11u4debCVE-2021-3999High
libc6,2.31-13+deb11u2,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc62.31-13+deb11u22.31-13+deb11u4debCVE-2021-3999High
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-bin2.28-102.28-10+deb10u2debCVE-2021-3999High
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc62.28-102.28-10+deb10u2debCVE-2021-3999High
libc-bin,2.31-13+deb11u2,2.31-13+deb11u4,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-bin2.31-13+deb11u22.31-13+deb11u4debCVE-2021-3999High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-bin2.24-11+deb9u4(won't fix)debCVE-2021-3999High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc62.24-11+deb9u4(won't fix)debCVE-2021-3999High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',multiarch-support2.24-11+deb9u4(won't fix)debCVE-2021-3999High
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc-dev-bin2.28-102.28-10+deb10u2debCVE-2021-3999High
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3999,High,2022-08-24T16:15:09.077,'A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.',libc6-dev2.28-102.28-10+deb10u2debCVE-2021-3999High
libcom-err2,1.46.2-2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libcom-err21.46.2-2(won't fix)debCVE-2022-1304High
e2fsprogs,1.46.2-2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',e2fsprogs1.46.2-2(won't fix)debCVE-2022-1304High
libext2fs2,1.46.2-2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libext2fs21.46.2-2(won't fix)debCVE-2022-1304High
libss2,1.46.2-2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libss21.46.2-2(won't fix)debCVE-2022-1304High
logsave,1.46.2-2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',logsave1.46.2-2(won't fix)debCVE-2022-1304High
e2fslibs,1.43.4-2+deb9u2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',e2fslibs1.43.4-2+deb9u2(won't fix)debCVE-2022-1304High
e2fsprogs,1.43.4-2+deb9u2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',e2fsprogs1.43.4-2+deb9u2(won't fix)debCVE-2022-1304High
libcomerr2,1.43.4-2+deb9u2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libcomerr21.43.4-2+deb9u2(won't fix)debCVE-2022-1304High
libss2,1.43.4-2+deb9u2,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libss21.43.4-2+deb9u2(won't fix)debCVE-2022-1304High
e2fsprogs,1.44.5-1+deb10u3,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',e2fsprogs1.44.5-1+deb10u3(won't fix)debCVE-2022-1304High
libcom-err2,1.44.5-1+deb10u3,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libcom-err21.44.5-1+deb10u3(won't fix)debCVE-2022-1304High
libext2fs2,1.44.5-1+deb10u3,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libext2fs21.44.5-1+deb10u3(won't fix)debCVE-2022-1304High
libss2,1.44.5-1+deb10u3,(won't fix),deb,CVE-2022-1304,High,2022-04-14T21:15:08.490,'An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.',libss21.44.5-1+deb10u3(won't fix)debCVE-2022-1304High
libdb5.3,5.3.28+dfsg1-0.8,(won't fix),deb,CVE-2019-8457,Critical,2019-05-30T16:29:01.840,'SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.',libdb5.35.3.28+dfsg1-0.8(won't fix)debCVE-2019-8457Critical
libdb5.3,5.3.28+dfsg1-0.5,(won't fix),deb,CVE-2019-8457,Negligible,2019-05-30T16:29:01.840,'SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.',libdb5.35.3.28+dfsg1-0.5(won't fix)debCVE-2019-8457Negligible
libdb5.3,5.3.28-12+deb9u1,(won't fix),deb,CVE-2019-8457,Critical,2019-05-30T16:29:01.840,'SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.',libdb5.35.3.28-12+deb9u1(won't fix)debCVE-2019-8457Critical
libgcrypt20,1.8.7-6,(won't fix),deb,CVE-2021-33560,High,2021-06-08T11:15:07.767,"'Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.'",libgcrypt201.8.7-6(won't fix)debCVE-2021-33560High
libgcrypt20,1.8.4-5+deb10u1,(won't fix),deb,CVE-2021-33560,High,2021-06-08T11:15:07.767,"'Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.'",libgcrypt201.8.4-5+deb10u1(won't fix)debCVE-2021-33560High
libgcrypt20,1.8.4-5,(won't fix),deb,CVE-2021-33560,High,2021-06-08T11:15:07.767,"'Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.'",libgcrypt201.8.4-5(won't fix)debCVE-2021-33560High
libgcrypt20,1.7.6-2+deb9u4,(won't fix),deb,CVE-2021-33560,High,2021-06-08T11:15:07.767,"'Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.'",libgcrypt201.7.6-2+deb9u4(won't fix)debCVE-2021-33560High
libgcrypt20,1.7.6-2+deb9u3,(won't fix),deb,CVE-2021-33560,High,2021-06-08T11:15:07.767,"'Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.'",libgcrypt201.7.6-2+deb9u3(won't fix)debCVE-2021-33560High
libgmp10,2:6.2.1+dfsg-1,2:6.2.1+dfsg-1+deb11u1,deb,CVE-2021-43618,High,2021-11-15T04:15:06.873,"'GNU Multiple Precision Arithmetic Library (GMP) through 6.2.1 has an mpz/inp_raw.c integer overflow and resultant buffer overflow via crafted input, leading to a segmentation fault on 32-bit platforms.'",libgmp102:6.2.1+dfsg-12:6.2.1+dfsg-1+deb11u1debCVE-2021-43618High
libgmp10,2:6.1.2+dfsg-4,2:6.1.2+dfsg-4+deb10u1,deb,CVE-2021-43618,High,2021-11-15T04:15:06.873,"'GNU Multiple Precision Arithmetic Library (GMP) through 6.2.1 has an mpz/inp_raw.c integer overflow and resultant buffer overflow via crafted input, leading to a segmentation fault on 32-bit platforms.'",libgmp102:6.1.2+dfsg-42:6.1.2+dfsg-4+deb10u1debCVE-2021-43618High
libgnutls30,3.7.1-5,3.7.1-5+deb11u3,deb,CVE-2023-0361,High,2023-02-15T18:15:11.683,"'A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.'",libgnutls303.7.1-53.7.1-5+deb11u3debCVE-2023-0361High
libgnutls30,3.6.7-4+deb10u7,3.6.7-4+deb10u10,deb,CVE-2023-0361,High,2023-02-15T18:15:11.683,"'A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.'",libgnutls303.6.7-4+deb10u73.6.7-4+deb10u10debCVE-2023-0361High
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u10,deb,CVE-2023-0361,High,2023-02-15T18:15:11.683,"'A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.'",libgnutls303.6.7-4+deb10u63.6.7-4+deb10u10debCVE-2023-0361High
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u10,deb,CVE-2023-0361,High,2023-02-15T18:15:11.683,"'A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.'",libgnutls303.6.7-4+deb10u53.6.7-4+deb10u10debCVE-2023-0361High
libgnutls30,3.7.1-5,3.7.1-5+deb11u2,deb,CVE-2022-2509,High,2022-08-01T14:15:09.890,'A vulnerability found in gnutls. This security flaw happens because of a double free error occurs during verification of pkcs7 signatures in gnutls_pkcs7_verify function.',libgnutls303.7.1-53.7.1-5+deb11u2debCVE-2022-2509High
libgnutls30,3.6.7-4+deb10u7,3.6.7-4+deb10u9,deb,CVE-2022-2509,High,2022-08-01T14:15:09.890,'A vulnerability found in gnutls. This security flaw happens because of a double free error occurs during verification of pkcs7 signatures in gnutls_pkcs7_verify function.',libgnutls303.6.7-4+deb10u73.6.7-4+deb10u9debCVE-2022-2509High
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u9,deb,CVE-2022-2509,High,2022-08-01T14:15:09.890,'A vulnerability found in gnutls. This security flaw happens because of a double free error occurs during verification of pkcs7 signatures in gnutls_pkcs7_verify function.',libgnutls303.6.7-4+deb10u63.6.7-4+deb10u9debCVE-2022-2509High
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u9,deb,CVE-2022-2509,High,2022-08-01T14:15:09.890,'A vulnerability found in gnutls. This security flaw happens because of a double free error occurs during verification of pkcs7 signatures in gnutls_pkcs7_verify function.',libgnutls303.6.7-4+deb10u53.6.7-4+deb10u9debCVE-2022-2509High
libgnutls30,3.7.1-5,3.7.1-5+deb11u1,deb,CVE-2021-4209,Medium,2022-08-24T16:15:09.927,"""A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update functions internally call memcpy, providing zero-length input may cause undefined behavior. This flaw leads to a denial of service after authentication in rare circumstances.""",libgnutls303.7.1-53.7.1-5+deb11u1debCVE-2021-4209Medium
libgnutls30,3.6.7-4+deb10u7,3.6.7-4+deb10u9,deb,CVE-2021-4209,Medium,2022-08-24T16:15:09.927,"""A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update functions internally call memcpy, providing zero-length input may cause undefined behavior. This flaw leads to a denial of service after authentication in rare circumstances.""",libgnutls303.6.7-4+deb10u73.6.7-4+deb10u9debCVE-2021-4209Medium
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u9,deb,CVE-2021-4209,Medium,2022-08-24T16:15:09.927,"""A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update functions internally call memcpy, providing zero-length input may cause undefined behavior. This flaw leads to a denial of service after authentication in rare circumstances.""",libgnutls303.6.7-4+deb10u63.6.7-4+deb10u9debCVE-2021-4209Medium
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u9,deb,CVE-2021-4209,Medium,2022-08-24T16:15:09.927,"""A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update functions internally call memcpy, providing zero-length input may cause undefined behavior. This flaw leads to a denial of service after authentication in rare circumstances.""",libgnutls303.6.7-4+deb10u53.6.7-4+deb10u9debCVE-2021-4209Medium
libgnutls30,3.7.1-5, ,deb,CVE-2011-3389,Negligible,2011-09-06T19:55:03.197,"'The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a ""BEAST"" attack.'",libgnutls303.7.1-5 debCVE-2011-3389Negligible
libgnutls30,3.7.9-2, ,deb,CVE-2011-3389,Negligible,2011-09-06T19:55:03.197,"'The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a ""BEAST"" attack.'",libgnutls303.7.9-2 debCVE-2011-3389Negligible
libgnutls30,3.6.7-4+deb10u7, ,deb,CVE-2011-3389,Negligible,2011-09-06T19:55:03.197,"'The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a ""BEAST"" attack.'",libgnutls303.6.7-4+deb10u7 debCVE-2011-3389Negligible
libgnutls30,3.6.7-4+deb10u6, ,deb,CVE-2011-3389,Negligible,2011-09-06T19:55:03.197,"'The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a ""BEAST"" attack.'",libgnutls303.6.7-4+deb10u6 debCVE-2011-3389Negligible
libgnutls30,3.6.7-4+deb10u5, ,deb,CVE-2011-3389,Negligible,2011-09-06T19:55:03.197,"'The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a ""BEAST"" attack.'",libgnutls303.6.7-4+deb10u5 debCVE-2011-3389Negligible
libgssapi-krb5-2,1.18.3-6,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libgssapi-krb5-21.18.3-61.18.3-6+deb11u3debCVE-2022-42898High
libk5crypto3,1.18.3-6,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libk5crypto31.18.3-61.18.3-6+deb11u3debCVE-2022-42898High
libkrb5-3,1.18.3-6,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5-31.18.3-61.18.3-6+deb11u3debCVE-2022-42898High
libkrb5support0,1.18.3-6,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5support01.18.3-61.18.3-6+deb11u3debCVE-2022-42898High
libgssapi-krb5-2,1.18.3-6+deb11u1,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libgssapi-krb5-21.18.3-6+deb11u11.18.3-6+deb11u3debCVE-2022-42898High
libk5crypto3,1.18.3-6+deb11u1,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libk5crypto31.18.3-6+deb11u11.18.3-6+deb11u3debCVE-2022-42898High
libkrb5-3,1.18.3-6+deb11u1,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5-31.18.3-6+deb11u11.18.3-6+deb11u3debCVE-2022-42898High
libkrb5support0,1.18.3-6+deb11u1,1.18.3-6+deb11u3,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5support01.18.3-6+deb11u11.18.3-6+deb11u3debCVE-2022-42898High
libgssapi-krb5-2,1.17-3,1.17-3+deb10u5,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libgssapi-krb5-21.17-31.17-3+deb10u5debCVE-2022-42898High
libk5crypto3,1.17-3,1.17-3+deb10u5,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libk5crypto31.17-31.17-3+deb10u5debCVE-2022-42898High
libkrb5-3,1.17-3,1.17-3+deb10u5,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5-31.17-31.17-3+deb10u5debCVE-2022-42898High
libkrb5support0,1.17-3,1.17-3+deb10u5,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libkrb5support01.17-31.17-3+deb10u5debCVE-2022-42898High
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-42898,High,2022-12-25T06:15:09.427,"'PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-42898High
libgssapi-krb5-2,1.18.3-6,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libgssapi-krb5-21.18.3-61.18.3-6+deb11u4debCVE-2023-36054Medium
libk5crypto3,1.18.3-6,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libk5crypto31.18.3-61.18.3-6+deb11u4debCVE-2023-36054Medium
libkrb5-3,1.18.3-6,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5-31.18.3-61.18.3-6+deb11u4debCVE-2023-36054Medium
libkrb5support0,1.18.3-6,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5support01.18.3-61.18.3-6+deb11u4debCVE-2023-36054Medium
libgssapi-krb5-2,1.18.3-6+deb11u1,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libgssapi-krb5-21.18.3-6+deb11u11.18.3-6+deb11u4debCVE-2023-36054Medium
libk5crypto3,1.18.3-6+deb11u1,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libk5crypto31.18.3-6+deb11u11.18.3-6+deb11u4debCVE-2023-36054Medium
libkrb5-3,1.18.3-6+deb11u1,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5-31.18.3-6+deb11u11.18.3-6+deb11u4debCVE-2023-36054Medium
libkrb5support0,1.18.3-6+deb11u1,1.18.3-6+deb11u4,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5support01.18.3-6+deb11u11.18.3-6+deb11u4debCVE-2023-36054Medium
libgssapi-krb5-2,1.17-3,1.17-3+deb10u6,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libgssapi-krb5-21.17-31.17-3+deb10u6debCVE-2023-36054Medium
libk5crypto3,1.17-3,1.17-3+deb10u6,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libk5crypto31.17-31.17-3+deb10u6debCVE-2023-36054Medium
libkrb5-3,1.17-3,1.17-3+deb10u6,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5-31.17-31.17-3+deb10u6debCVE-2023-36054Medium
libkrb5support0,1.17-3,1.17-3+deb10u6,deb,CVE-2023-36054,Medium,2023-08-07T19:15:09.840,'lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.',libkrb5support01.17-31.17-3+deb10u6debCVE-2023-36054Medium
libgssapi-krb5-2,1.18.3-6,1.18.3-6+deb11u1,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libgssapi-krb5-21.18.3-61.18.3-6+deb11u1debCVE-2021-37750Medium
libk5crypto3,1.18.3-6,1.18.3-6+deb11u1,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libk5crypto31.18.3-61.18.3-6+deb11u1debCVE-2021-37750Medium
libkrb5-3,1.18.3-6,1.18.3-6+deb11u1,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libkrb5-31.18.3-61.18.3-6+deb11u1debCVE-2021-37750Medium
libkrb5support0,1.18.3-6,1.18.3-6+deb11u1,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libkrb5support01.18.3-61.18.3-6+deb11u1debCVE-2021-37750Medium
libgssapi-krb5-2,1.17-3,1.17-3+deb10u3,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libgssapi-krb5-21.17-31.17-3+deb10u3debCVE-2021-37750Medium
libk5crypto3,1.17-3,1.17-3+deb10u3,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libk5crypto31.17-31.17-3+deb10u3debCVE-2021-37750Medium
libkrb5-3,1.17-3,1.17-3+deb10u3,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libkrb5-31.17-31.17-3+deb10u3debCVE-2021-37750Medium
libkrb5support0,1.17-3,1.17-3+deb10u3,deb,CVE-2021-37750,Medium,2021-08-23T05:15:08.063,'The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.',libkrb5support01.17-31.17-3+deb10u3debCVE-2021-37750Medium
libgssapi-krb5-2,1.18.3-6, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libgssapi-krb5-21.18.3-6 debCVE-2018-5709Negligible
libk5crypto3,1.18.3-6, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libk5crypto31.18.3-6 debCVE-2018-5709Negligible
libkrb5-3,1.18.3-6, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5-31.18.3-6 debCVE-2018-5709Negligible
libkrb5support0,1.18.3-6, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5support01.18.3-6 debCVE-2018-5709Negligible
libgssapi-krb5-2,1.18.3-6+deb11u1, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libgssapi-krb5-21.18.3-6+deb11u1 debCVE-2018-5709Negligible
libk5crypto3,1.18.3-6+deb11u1, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libk5crypto31.18.3-6+deb11u1 debCVE-2018-5709Negligible
libkrb5-3,1.18.3-6+deb11u1, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5-31.18.3-6+deb11u1 debCVE-2018-5709Negligible
libkrb5support0,1.18.3-6+deb11u1, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5support01.18.3-6+deb11u1 debCVE-2018-5709Negligible
libgssapi-krb5-2,1.17-3, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libgssapi-krb5-21.17-3 debCVE-2018-5709Negligible
libk5crypto3,1.17-3, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libk5crypto31.17-3 debCVE-2018-5709Negligible
libkrb5-3,1.17-3, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5-31.17-3 debCVE-2018-5709Negligible
libkrb5support0,1.17-3, ,deb,CVE-2018-5709,Negligible,2018-01-16T09:29:00.500,"'An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable ""dbentry->n_key_data"" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a ""u4"" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.'",libkrb5support01.17-3 debCVE-2018-5709Negligible
libpcre2-8-0,10.36-2,10.36-2+deb11u1,deb,CVE-2022-1587,Critical,2022-05-16T21:15:07.847,'An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.',libpcre2-8-010.36-210.36-2+deb11u1debCVE-2022-1587Critical
libpcre2-8-0,10.32-5,10.32-5+deb10u1,deb,CVE-2022-1587,Critical,2022-05-16T21:15:07.847,'An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.',libpcre2-8-010.32-510.32-5+deb10u1debCVE-2022-1587Critical
libpcre2-8-0,10.36-2,10.36-2+deb11u1,deb,CVE-2022-1586,Critical,2022-05-16T21:15:07.793,'An out-of-bounds read vulnerability was discovered in the PCRE2 library in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This involves a unicode property matching issue in JIT-compiled regular expressions. The issue occurs because the character was not fully read in case-less matching within JIT.',libpcre2-8-010.36-210.36-2+deb11u1debCVE-2022-1586Critical
libpcre2-8-0,10.32-5,10.32-5+deb10u1,deb,CVE-2022-1586,Critical,2022-05-16T21:15:07.793,'An out-of-bounds read vulnerability was discovered in the PCRE2 library in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This involves a unicode property matching issue in JIT-compiled regular expressions. The issue occurs because the character was not fully read in case-less matching within JIT.',libpcre2-8-010.32-510.32-5+deb10u1debCVE-2022-1586Critical
libpcre2-8-0,10.36-2, ,deb,CVE-2022-41409,Negligible,2023-07-18T14:15:12.197,'Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.',libpcre2-8-010.36-2 debCVE-2022-41409Negligible
libpcre2-8-0,10.32-5, ,deb,CVE-2022-41409,Negligible,2023-07-18T14:15:12.197,'Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.',libpcre2-8-010.32-5 debCVE-2022-41409Negligible
libpcre3,2:8.39-13, ,deb,CVE-2019-20838,Negligible,2020-06-15T17:15:09.683,"'libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.'",libpcre32:8.39-13 debCVE-2019-20838Negligible
libpcre3,2:8.39-12, ,deb,CVE-2019-20838,Negligible,2020-06-15T17:15:09.683,"'libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.'",libpcre32:8.39-12 debCVE-2019-20838Negligible
libpcre3,2:8.39-3, ,deb,CVE-2019-20838,Negligible,2020-06-15T17:15:09.683,"'libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.'",libpcre32:8.39-3 debCVE-2019-20838Negligible
libpcre3,2:8.39-13, ,deb,CVE-2017-7246,Negligible,2017-03-23T21:59:00.223,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-13 debCVE-2017-7246Negligible
libpcre3,2:8.39-12, ,deb,CVE-2017-7246,Negligible,2017-03-23T21:59:00.223,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-12 debCVE-2017-7246Negligible
libpcre3,2:8.39-3, ,deb,CVE-2017-7246,Negligible,2017-03-23T21:59:00.223,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-3 debCVE-2017-7246Negligible
libpcre3,2:8.39-13, ,deb,CVE-2017-7245,Negligible,2017-03-23T21:59:00.193,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-13 debCVE-2017-7245Negligible
libpcre3,2:8.39-12, ,deb,CVE-2017-7245,Negligible,2017-03-23T21:59:00.193,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-12 debCVE-2017-7245Negligible
libpcre3,2:8.39-3, ,deb,CVE-2017-7245,Negligible,2017-03-23T21:59:00.193,'Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.',libpcre32:8.39-3 debCVE-2017-7245Negligible
libpcre3,2:8.39-13, ,deb,CVE-2017-16231,Negligible,2019-03-21T15:59:56.217,"'In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used'",libpcre32:8.39-13 debCVE-2017-16231Negligible
libpcre3,2:8.39-12, ,deb,CVE-2017-16231,Negligible,2019-03-21T15:59:56.217,"'In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used'",libpcre32:8.39-12 debCVE-2017-16231Negligible
libpcre3,2:8.39-3, ,deb,CVE-2017-16231,Negligible,2019-03-21T15:59:56.217,"'In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used'",libpcre32:8.39-3 debCVE-2017-16231Negligible
libpcre3,2:8.39-13, ,deb,CVE-2017-11164,Negligible,2017-07-11T03:29:00.277,"'In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.'",libpcre32:8.39-13 debCVE-2017-11164Negligible
libpcre3,2:8.39-12, ,deb,CVE-2017-11164,Negligible,2017-07-11T03:29:00.277,"'In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.'",libpcre32:8.39-12 debCVE-2017-11164Negligible
libpcre3,2:8.39-3, ,deb,CVE-2017-11164,Negligible,2017-07-11T03:29:00.277,"'In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.'",libpcre32:8.39-3 debCVE-2017-11164Negligible
libsepol1,3.1-1,(won't fix),deb,CVE-2021-36087,Low,2021-07-01T03:15:08.817,'The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.',libsepol13.1-1(won't fix)debCVE-2021-36087Low
libsepol1,2.8-1,(won't fix),deb,CVE-2021-36087,Low,2021-07-01T03:15:08.817,'The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.',libsepol12.8-1(won't fix)debCVE-2021-36087Low
libsepol1,2.6-2,(won't fix),deb,CVE-2021-36087,Low,2021-07-01T03:15:08.817,'The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.',libsepol12.6-2(won't fix)debCVE-2021-36087Low
libsepol1,3.1-1,(won't fix),deb,CVE-2021-36086,Low,2021-07-01T03:15:08.783,'The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).',libsepol13.1-1(won't fix)debCVE-2021-36086Low
libsepol1,2.8-1,(won't fix),deb,CVE-2021-36086,Low,2021-07-01T03:15:08.783,'The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).',libsepol12.8-1(won't fix)debCVE-2021-36086Low
libsepol1,2.6-2,(won't fix),deb,CVE-2021-36086,Low,2021-07-01T03:15:08.783,'The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).',libsepol12.6-2(won't fix)debCVE-2021-36086Low
libsepol1,3.1-1,(won't fix),deb,CVE-2021-36085,Low,2021-07-01T03:15:08.750,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).',libsepol13.1-1(won't fix)debCVE-2021-36085Low
libsepol1,2.8-1,(won't fix),deb,CVE-2021-36085,Low,2021-07-01T03:15:08.750,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).',libsepol12.8-1(won't fix)debCVE-2021-36085Low
libsepol1,2.6-2,(won't fix),deb,CVE-2021-36085,Low,2021-07-01T03:15:08.750,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).',libsepol12.6-2(won't fix)debCVE-2021-36085Low
libsepol1,3.1-1,(won't fix),deb,CVE-2021-36084,Low,2021-07-01T03:15:08.717,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).',libsepol13.1-1(won't fix)debCVE-2021-36084Low
libsepol1,2.8-1,(won't fix),deb,CVE-2021-36084,Low,2021-07-01T03:15:08.717,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).',libsepol12.8-1(won't fix)debCVE-2021-36084Low
libsepol1,2.6-2,(won't fix),deb,CVE-2021-36084,Low,2021-07-01T03:15:08.717,'The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).',libsepol12.6-2(won't fix)debCVE-2021-36084Low
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1k-11.1.1n-0+deb11u3debCVE-2022-2068Critical
libssl1.1,1.1.1n-0+deb11u2,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1n-0+deb11u21.1.1n-0+deb11u3debCVE-2022-2068Critical
openssl,1.1.1n-0+deb11u2,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1n-0+deb11u21.1.1n-0+deb11u3debCVE-2022-2068Critical
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u3debCVE-2022-2068Critical
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u3debCVE-2022-2068Critical
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u3debCVE-2022-2068Critical
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u3debCVE-2022-2068Critical
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u3debCVE-2022-2068Critical
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u3debCVE-2022-2068Critical
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u3debCVE-2022-2068Critical
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u3debCVE-2022-2068Critical
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u3debCVE-2022-2068Critical
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u3debCVE-2022-2068Critical
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u3debCVE-2022-2068Critical
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u3,deb,CVE-2022-2068,Critical,2022-06-21T15:15:09.060,"'In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u3debCVE-2022-2068Critical
libssl1.1,1.1.1k-1,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1k-11.1.1n-0+deb11u2debCVE-2022-1292Critical
libssl1.1,1.1.1n-0+deb11u1,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1n-0+deb11u11.1.1n-0+deb11u2debCVE-2022-1292Critical
libssl1.1,1.1.1k-1+deb11u1,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1k-1+deb11u11.1.1n-0+deb11u2debCVE-2022-1292Critical
openssl,1.1.1k-1+deb11u1,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1k-1+deb11u11.1.1n-0+deb11u2debCVE-2022-1292Critical
openssl,1.1.1n-0+deb11u1,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1n-0+deb11u11.1.1n-0+deb11u2debCVE-2022-1292Critical
libssl1.1,1.1.1k-1+deb11u2,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1k-1+deb11u21.1.1n-0+deb11u2debCVE-2022-1292Critical
openssl,1.1.1k-1+deb11u2,1.1.1n-0+deb11u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1k-1+deb11u21.1.1n-0+deb11u2debCVE-2022-1292Critical
libssl1.1,1.1.1d-0+deb10u6,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1d-0+deb10u61.1.1n-0+deb10u2debCVE-2022-1292Critical
openssl,1.1.1d-0+deb10u6,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1d-0+deb10u61.1.1n-0+deb10u2debCVE-2022-1292Critical
libssl1.1,1.1.1d-0+deb10u7,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1d-0+deb10u71.1.1n-0+deb10u2debCVE-2022-1292Critical
libssl1.1,1.1.1d-0+deb10u3,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",libssl1.11.1.1d-0+deb10u31.1.1n-0+deb10u2debCVE-2022-1292Critical
openssl,1.1.1d-0+deb10u3,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1d-0+deb10u31.1.1n-0+deb10u2debCVE-2022-1292Critical
openssl,1.1.1d-0+deb10u7,1.1.1n-0+deb10u2,deb,CVE-2022-1292,Critical,2022-05-03T16:15:18.823,"'The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).'",openssl1.1.1d-0+deb10u71.1.1n-0+deb10u2debCVE-2022-1292Critical
libssl1.1,1.1.1k-1,1.1.1k-1+deb11u1,deb,CVE-2021-3711,Critical,2021-08-24T15:15:09.133,"'In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the ""out"" parameter can be NULL and, on exit, the ""outlen"" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the ""out"" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).'",libssl1.11.1.1k-11.1.1k-1+deb11u1debCVE-2021-3711Critical
libssl1.1,1.1.1d-0+deb10u6,1.1.1d-0+deb10u7,deb,CVE-2021-3711,Critical,2021-08-24T15:15:09.133,"'In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the ""out"" parameter can be NULL and, on exit, the ""outlen"" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the ""out"" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).'",libssl1.11.1.1d-0+deb10u61.1.1d-0+deb10u7debCVE-2021-3711Critical
openssl,1.1.1d-0+deb10u6,1.1.1d-0+deb10u7,deb,CVE-2021-3711,Critical,2021-08-24T15:15:09.133,"'In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the ""out"" parameter can be NULL and, on exit, the ""outlen"" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the ""out"" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).'",openssl1.1.1d-0+deb10u61.1.1d-0+deb10u7debCVE-2021-3711Critical
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u7,deb,CVE-2021-3711,Critical,2021-08-24T15:15:09.133,"'In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the ""out"" parameter can be NULL and, on exit, the ""outlen"" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the ""out"" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u7debCVE-2021-3711Critical
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u7,deb,CVE-2021-3711,Critical,2021-08-24T15:15:09.133,"'In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the ""out"" parameter can be NULL and, on exit, the ""outlen"" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the ""out"" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u7debCVE-2021-3711Critical
libssl1.1,1.1.1k-1,1.1.1k-1+deb11u2,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",libssl1.11.1.1k-11.1.1k-1+deb11u2debCVE-2022-0778High
libssl1.1,1.1.1k-1+deb11u1,1.1.1k-1+deb11u2,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",libssl1.11.1.1k-1+deb11u11.1.1k-1+deb11u2debCVE-2022-0778High
openssl,1.1.1k-1+deb11u1,1.1.1k-1+deb11u2,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",openssl1.1.1k-1+deb11u11.1.1k-1+deb11u2debCVE-2022-0778High
libssl1.1,1.1.1d-0+deb10u6,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",libssl1.11.1.1d-0+deb10u61.1.1d-0+deb10u8debCVE-2022-0778High
openssl,1.1.1d-0+deb10u6,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",openssl1.1.1d-0+deb10u61.1.1d-0+deb10u8debCVE-2022-0778High
libssl1.1,1.1.1d-0+deb10u7,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",libssl1.11.1.1d-0+deb10u71.1.1d-0+deb10u8debCVE-2022-0778High
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u8debCVE-2022-0778High
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u8debCVE-2022-0778High
openssl,1.1.1d-0+deb10u7,1.1.1d-0+deb10u8,deb,CVE-2022-0778,High,2022-03-15T17:15:08.513,"'The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).'",openssl1.1.1d-0+deb10u71.1.1d-0+deb10u8debCVE-2022-0778High
libssl1.1,1.1.1k-1,1.1.1k-1+deb11u1,deb,CVE-2021-3712,High,2021-08-24T15:15:09.533,"'ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL\'s own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).'",libssl1.11.1.1k-11.1.1k-1+deb11u1debCVE-2021-3712High
libssl1.1,1.1.1d-0+deb10u6,1.1.1d-0+deb10u7,deb,CVE-2021-3712,High,2021-08-24T15:15:09.533,"'ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL\'s own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).'",libssl1.11.1.1d-0+deb10u61.1.1d-0+deb10u7debCVE-2021-3712High
openssl,1.1.1d-0+deb10u6,1.1.1d-0+deb10u7,deb,CVE-2021-3712,High,2021-08-24T15:15:09.533,"'ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL\'s own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).'",openssl1.1.1d-0+deb10u61.1.1d-0+deb10u7debCVE-2021-3712High
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u7,deb,CVE-2021-3712,High,2021-08-24T15:15:09.533,"'ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL\'s own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u7debCVE-2021-3712High
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u7,deb,CVE-2021-3712,High,2021-08-24T15:15:09.533,"'ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL\'s own ""d2i"" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the ""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the ""data"" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u7debCVE-2021-3712High
libssl1.1,1.1.1k-1,1.1.1k-1+deb11u2,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",libssl1.11.1.1k-11.1.1k-1+deb11u2debCVE-2021-4160Medium
libssl1.1,1.1.1k-1+deb11u1,1.1.1k-1+deb11u2,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",libssl1.11.1.1k-1+deb11u11.1.1k-1+deb11u2debCVE-2021-4160Medium
openssl,1.1.1k-1+deb11u1,1.1.1k-1+deb11u2,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",openssl1.1.1k-1+deb11u11.1.1k-1+deb11u2debCVE-2021-4160Medium
libssl1.1,1.1.1d-0+deb10u6,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",libssl1.11.1.1d-0+deb10u61.1.1d-0+deb10u8debCVE-2021-4160Medium
openssl,1.1.1d-0+deb10u6,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",openssl1.1.1d-0+deb10u61.1.1d-0+deb10u8debCVE-2021-4160Medium
libssl1.1,1.1.1d-0+deb10u7,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",libssl1.11.1.1d-0+deb10u71.1.1d-0+deb10u8debCVE-2021-4160Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u8debCVE-2021-4160Medium
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u8debCVE-2021-4160Medium
openssl,1.1.1d-0+deb10u7,1.1.1d-0+deb10u8,deb,CVE-2021-4160,Medium,2022-01-28T22:15:15.133,"'There is a carry propagation bug in the MIPS32 and MIPS64 squaring procedure. Many EC algorithms are affected, including some of the TLS 1.3 default curves. Impact was not analyzed in detail, because the pre-requisites for attack are considered unlikely and include reusing private keys. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH private key among multiple clients, which is no longer an option since CVE-2016-0701. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0.0. It was addressed in the releases of 1.1.1m and 3.0.1 on the 15th of December 2021. For the 1.0.2 release it is addressed in git commit 6fc1aaaf3 that is available to premium support customers only. It will be made available in 1.0.2zc when it is released. The issue only affects OpenSSL on MIPS platforms. Fixed in OpenSSL 3.0.1 (Affected 3.0.0). Fixed in OpenSSL 1.1.1m (Affected 1.1.1-1.1.1l). Fixed in OpenSSL 1.0.2zc-dev (Affected 1.0.2-1.0.2zb).'",openssl1.1.1d-0+deb10u71.1.1d-0+deb10u8debCVE-2021-4160Medium
libsystemd0,247.3-6,247.3-7+deb11u2,deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libsystemd0247.3-6247.3-7+deb11u2debCVE-2022-4415Medium
libudev1,247.3-6,247.3-7+deb11u2,deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libudev1247.3-6247.3-7+deb11u2debCVE-2022-4415Medium
libsystemd0,247.3-7,247.3-7+deb11u2,deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libsystemd0247.3-7247.3-7+deb11u2debCVE-2022-4415Medium
libudev1,247.3-7,247.3-7+deb11u2,deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libudev1247.3-7247.3-7+deb11u2debCVE-2022-4415Medium
libsystemd0,241-7~deb10u7,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libsystemd0241-7~deb10u7(won't fix)debCVE-2022-4415Medium
libudev1,241-7~deb10u7,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libudev1241-7~deb10u7(won't fix)debCVE-2022-4415Medium
libsystemd0,241-7~deb10u8,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libsystemd0241-7~deb10u8(won't fix)debCVE-2022-4415Medium
libudev1,241-7~deb10u8,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libudev1241-7~deb10u8(won't fix)debCVE-2022-4415Medium
libsystemd0,241-7~deb10u4,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libsystemd0241-7~deb10u4(won't fix)debCVE-2022-4415Medium
libudev1,241-7~deb10u4,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',libudev1241-7~deb10u4(won't fix)debCVE-2022-4415Medium
udev,241-7~deb10u4,(won't fix),deb,CVE-2022-4415,Medium,2023-01-11T15:15:09.590,'A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.',udev241-7~deb10u4(won't fix)debCVE-2022-4415Medium
libsystemd0,247.3-6,247.3-7+deb11u2,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libsystemd0247.3-6247.3-7+deb11u2debCVE-2022-3821Medium
libudev1,247.3-6,247.3-7+deb11u2,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libudev1247.3-6247.3-7+deb11u2debCVE-2022-3821Medium
libsystemd0,247.3-7,247.3-7+deb11u2,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libsystemd0247.3-7247.3-7+deb11u2debCVE-2022-3821Medium
libudev1,247.3-7,247.3-7+deb11u2,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libudev1247.3-7247.3-7+deb11u2debCVE-2022-3821Medium
libsystemd0,241-7~deb10u7,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libsystemd0241-7~deb10u7241-7~deb10u10debCVE-2022-3821Medium
libudev1,241-7~deb10u7,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libudev1241-7~deb10u7241-7~deb10u10debCVE-2022-3821Medium
libsystemd0,241-7~deb10u8,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libsystemd0241-7~deb10u8241-7~deb10u10debCVE-2022-3821Medium
libudev1,241-7~deb10u8,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libudev1241-7~deb10u8241-7~deb10u10debCVE-2022-3821Medium
libsystemd0,241-7~deb10u4,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libsystemd0241-7~deb10u4241-7~deb10u10debCVE-2022-3821Medium
libudev1,241-7~deb10u4,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",libudev1241-7~deb10u4241-7~deb10u10debCVE-2022-3821Medium
udev,241-7~deb10u4,241-7~deb10u10,deb,CVE-2022-3821,Medium,2022-11-08T22:15:16.700,"'An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.'",udev241-7~deb10u4241-7~deb10u10debCVE-2022-3821Medium
libsystemd0,247.3-6,247.3-7,deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0247.3-6247.3-7debCVE-2021-3997Medium
libudev1,247.3-6,247.3-7,deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1247.3-6247.3-7debCVE-2021-3997Medium
libsystemd0,241-7~deb10u7,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0241-7~deb10u7(won't fix)debCVE-2021-3997Medium
libudev1,241-7~deb10u7,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1241-7~deb10u7(won't fix)debCVE-2021-3997Medium
libsystemd0,241-7~deb10u8,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0241-7~deb10u8(won't fix)debCVE-2021-3997Medium
libudev1,241-7~deb10u8,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1241-7~deb10u8(won't fix)debCVE-2021-3997Medium
libsystemd0,241-7~deb10u4,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0241-7~deb10u4(won't fix)debCVE-2021-3997Medium
libudev1,241-7~deb10u4,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1241-7~deb10u4(won't fix)debCVE-2021-3997Medium
libsystemd0,232-25+deb9u13,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0232-25+deb9u13(won't fix)debCVE-2021-3997Medium
libudev1,232-25+deb9u13,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1232-25+deb9u13(won't fix)debCVE-2021-3997Medium
udev,241-7~deb10u4,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',udev241-7~deb10u4(won't fix)debCVE-2021-3997Medium
libsystemd0,232-25+deb9u12,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libsystemd0232-25+deb9u12(won't fix)debCVE-2021-3997Medium
libudev1,232-25+deb9u12,(won't fix),deb,CVE-2021-3997,Medium,2022-08-23T20:15:08.670,'A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.',libudev1232-25+deb9u12(won't fix)debCVE-2021-3997Medium
libsystemd0,247.3-6, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-6 debCVE-2023-31439Negligible
libudev1,247.3-6, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-6 debCVE-2023-31439Negligible
libsystemd0,247.3-7, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-7 debCVE-2023-31439Negligible
libudev1,247.3-7, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-7 debCVE-2023-31439Negligible
libsystemd0,252.6-1, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0252.6-1 debCVE-2023-31439Negligible
libudev1,252.6-1, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1252.6-1 debCVE-2023-31439Negligible
libsystemd0,241-7~deb10u7, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u7 debCVE-2023-31439Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u7 debCVE-2023-31439Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u8 debCVE-2023-31439Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u8 debCVE-2023-31439Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u4 debCVE-2023-31439Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u4 debCVE-2023-31439Negligible
udev,241-7~deb10u4, ,deb,CVE-2023-31439,Negligible,2023-06-13T17:15:14.753,"'An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",udev241-7~deb10u4 debCVE-2023-31439Negligible
libsystemd0,247.3-6, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-6 debCVE-2023-31438Negligible
libudev1,247.3-6, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-6 debCVE-2023-31438Negligible
libsystemd0,247.3-7, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-7 debCVE-2023-31438Negligible
libudev1,247.3-7, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-7 debCVE-2023-31438Negligible
libsystemd0,252.6-1, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0252.6-1 debCVE-2023-31438Negligible
libudev1,252.6-1, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1252.6-1 debCVE-2023-31438Negligible
libsystemd0,241-7~deb10u7, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u7 debCVE-2023-31438Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u7 debCVE-2023-31438Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u8 debCVE-2023-31438Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u8 debCVE-2023-31438Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u4 debCVE-2023-31438Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u4 debCVE-2023-31438Negligible
udev,241-7~deb10u4, ,deb,CVE-2023-31438,Negligible,2023-06-13T17:15:14.707,"'An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",udev241-7~deb10u4 debCVE-2023-31438Negligible
libsystemd0,247.3-6, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-6 debCVE-2023-31437Negligible
libudev1,247.3-6, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-6 debCVE-2023-31437Negligible
libsystemd0,247.3-7, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0247.3-7 debCVE-2023-31437Negligible
libudev1,247.3-7, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1247.3-7 debCVE-2023-31437Negligible
libsystemd0,252.6-1, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0252.6-1 debCVE-2023-31437Negligible
libudev1,252.6-1, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1252.6-1 debCVE-2023-31437Negligible
libsystemd0,241-7~deb10u7, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u7 debCVE-2023-31437Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u7 debCVE-2023-31437Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u8 debCVE-2023-31437Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u8 debCVE-2023-31437Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libsystemd0241-7~deb10u4 debCVE-2023-31437Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",libudev1241-7~deb10u4 debCVE-2023-31437Negligible
udev,241-7~deb10u4, ,deb,CVE-2023-31437,Negligible,2023-06-13T17:15:14.657,"'An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent ""a reply denying that any of the finding was a security vulnerability.""'",udev241-7~deb10u4 debCVE-2023-31437Negligible
libsystemd0,247.3-6, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0247.3-6 debCVE-2020-13529Negligible
libudev1,247.3-6, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1247.3-6 debCVE-2020-13529Negligible
libsystemd0,247.3-7, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0247.3-7 debCVE-2020-13529Negligible
libudev1,247.3-7, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1247.3-7 debCVE-2020-13529Negligible
libsystemd0,241-7~deb10u7, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0241-7~deb10u7 debCVE-2020-13529Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1241-7~deb10u7 debCVE-2020-13529Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0241-7~deb10u8 debCVE-2020-13529Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1241-7~deb10u8 debCVE-2020-13529Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0241-7~deb10u4 debCVE-2020-13529Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1241-7~deb10u4 debCVE-2020-13529Negligible
libsystemd0,232-25+deb9u13, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0232-25+deb9u13 debCVE-2020-13529Negligible
libudev1,232-25+deb9u13, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1232-25+deb9u13 debCVE-2020-13529Negligible
udev,241-7~deb10u4, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',udev241-7~deb10u4 debCVE-2020-13529Negligible
libsystemd0,232-25+deb9u12, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libsystemd0232-25+deb9u12 debCVE-2020-13529Negligible
libudev1,232-25+deb9u12, ,deb,CVE-2020-13529,Negligible,2021-05-10T16:15:07.373,'An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.',libudev1232-25+deb9u12 debCVE-2020-13529Negligible
libsystemd0,247.3-6, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0247.3-6 debCVE-2013-4392Negligible
libudev1,247.3-6, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1247.3-6 debCVE-2013-4392Negligible
libsystemd0,247.3-7, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0247.3-7 debCVE-2013-4392Negligible
libudev1,247.3-7, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1247.3-7 debCVE-2013-4392Negligible
libsystemd0,252.6-1, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0252.6-1 debCVE-2013-4392Negligible
libudev1,252.6-1, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1252.6-1 debCVE-2013-4392Negligible
libsystemd0,241-7~deb10u7, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0241-7~deb10u7 debCVE-2013-4392Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1241-7~deb10u7 debCVE-2013-4392Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0241-7~deb10u8 debCVE-2013-4392Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1241-7~deb10u8 debCVE-2013-4392Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0241-7~deb10u4 debCVE-2013-4392Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1241-7~deb10u4 debCVE-2013-4392Negligible
libsystemd0,232-25+deb9u13, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0232-25+deb9u13 debCVE-2013-4392Negligible
libudev1,232-25+deb9u13, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1232-25+deb9u13 debCVE-2013-4392Negligible
udev,241-7~deb10u4, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",udev241-7~deb10u4 debCVE-2013-4392Negligible
libsystemd0,232-25+deb9u12, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libsystemd0232-25+deb9u12 debCVE-2013-4392Negligible
libudev1,232-25+deb9u12, ,deb,CVE-2013-4392,Negligible,2013-10-28T22:55:03.773,"'systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.'",libudev1232-25+deb9u12 debCVE-2013-4392Negligible
libtasn1-6,4.16.0-2,4.16.0-2+deb11u1,deb,CVE-2021-46848,Critical,2022-10-24T14:15:49.973,'GNU Libtasn1 before 4.19.0 has an ETYPE_OK off-by-one array size check that affects asn1_encode_simple_der.',libtasn1-64.16.0-24.16.0-2+deb11u1debCVE-2021-46848Critical
libtasn1-6,4.13-3,4.13-3+deb10u1,deb,CVE-2021-46848,Critical,2022-10-24T14:15:49.973,'GNU Libtasn1 before 4.19.0 has an ETYPE_OK off-by-one array size check that affects asn1_encode_simple_der.',libtasn1-64.13-34.13-3+deb10u1debCVE-2021-46848Critical
libtirpc-common,1.3.1-1,1.3.1-1+deb11u1,deb,CVE-2021-46828,High,2022-07-20T06:15:07.907,"'In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.'",libtirpc-common1.3.1-11.3.1-1+deb11u1debCVE-2021-46828High
libtirpc3,1.3.1-1,1.3.1-1+deb11u1,deb,CVE-2021-46828,High,2022-07-20T06:15:07.907,"'In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.'",libtirpc31.3.1-11.3.1-1+deb11u1debCVE-2021-46828High
libtirpc-common,1.1.4-0.4,1.1.4-0.4+deb10u1,deb,CVE-2021-46828,High,2022-07-20T06:15:07.907,"'In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.'",libtirpc-common1.1.4-0.41.1.4-0.4+deb10u1debCVE-2021-46828High
libtirpc3,1.1.4-0.4,1.1.4-0.4+deb10u1,deb,CVE-2021-46828,High,2022-07-20T06:15:07.907,"'In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.'",libtirpc31.1.4-0.41.1.4-0.4+deb10u1debCVE-2021-46828High
libzstd1,1.4.8+dfsg-2.1,(won't fix),deb,CVE-2022-4899,High,2023-03-31T20:15:07.213,"'A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.'",libzstd11.4.8+dfsg-2.1(won't fix)debCVE-2022-4899High
login,1:4.8.1-1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",login1:4.8.1-1(won't fix)debCVE-2023-29383Low
passwd,1:4.8.1-1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",passwd1:4.8.1-1(won't fix)debCVE-2023-29383Low
login,1:4.13+dfsg1-1+b1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",login1:4.13+dfsg1-1+b1(won't fix)debCVE-2023-29383Low
passwd,1:4.13+dfsg1-1+b1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",passwd1:4.13+dfsg1-1+b1(won't fix)debCVE-2023-29383Low
login,1:4.5-1.1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",login1:4.5-1.1(won't fix)debCVE-2023-29383Low
passwd,1:4.5-1.1,(won't fix),deb,CVE-2023-29383,Low,2023-04-14T22:15:07.680,"'In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that ""cat /etc/passwd"" shows a rogue user account.'",passwd1:4.5-1.1(won't fix)debCVE-2023-29383Low
login,1:4.8.1-1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",login1:4.8.1-1 debCVE-2019-19882Negligible
passwd,1:4.8.1-1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",passwd1:4.8.1-1 debCVE-2019-19882Negligible
login,1:4.13+dfsg1-1+b1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",login1:4.13+dfsg1-1+b1 debCVE-2019-19882Negligible
passwd,1:4.13+dfsg1-1+b1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",passwd1:4.13+dfsg1-1+b1 debCVE-2019-19882Negligible
login,1:4.5-1.1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",login1:4.5-1.1 debCVE-2019-19882Negligible
passwd,1:4.5-1.1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",passwd1:4.5-1.1 debCVE-2019-19882Negligible
login,1:4.4-4.1+deb9u1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",login1:4.4-4.1+deb9u1 debCVE-2019-19882Negligible
passwd,1:4.4-4.1+deb9u1, ,deb,CVE-2019-19882,Negligible,2019-12-18T16:15:26.963,"'shadow 4.8, in certain circumstances affecting at least Gentoo, Arch Linux, and Void Linux, allows local users to obtain root access because setuid programs are misconfigured. Specifically, this affects shadow 4.8 when compiled using --with-libpam but without explicitly passing --disable-account-tools-setuid, and without a PAM configuration suitable for use with setuid account management tools. This combination leads to account management tools (groupadd, groupdel, groupmod, useradd, userdel, usermod) that can easily be used by unprivileged local users to escalate privileges to root in multiple ways. This issue became much more relevant in approximately December 2019 when an unrelated bug was fixed (i.e., the chmod calls to suidusbins were fixed in the upstream Makefile which is now included in the release version 4.8).'",passwd1:4.4-4.1+deb9u1 debCVE-2019-19882Negligible
login,1:4.8.1-1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',login1:4.8.1-1 debCVE-2013-4235Negligible
passwd,1:4.8.1-1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',passwd1:4.8.1-1 debCVE-2013-4235Negligible
login,1:4.5-1.1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',login1:4.5-1.1 debCVE-2013-4235Negligible
passwd,1:4.5-1.1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',passwd1:4.5-1.1 debCVE-2013-4235Negligible
login,1:4.4-4.1+deb9u1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',login1:4.4-4.1+deb9u1 debCVE-2013-4235Negligible
passwd,1:4.4-4.1+deb9u1, ,deb,CVE-2013-4235,Negligible,2019-12-03T15:15:10.963,'shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees',passwd1:4.4-4.1+deb9u1 debCVE-2013-4235Negligible
login,1:4.8.1-1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",login1:4.8.1-1 debCVE-2007-5686Negligible
passwd,1:4.8.1-1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",passwd1:4.8.1-1 debCVE-2007-5686Negligible
login,1:4.13+dfsg1-1+b1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",login1:4.13+dfsg1-1+b1 debCVE-2007-5686Negligible
passwd,1:4.13+dfsg1-1+b1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",passwd1:4.13+dfsg1-1+b1 debCVE-2007-5686Negligible
login,1:4.5-1.1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",login1:4.5-1.1 debCVE-2007-5686Negligible
passwd,1:4.5-1.1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",passwd1:4.5-1.1 debCVE-2007-5686Negligible
login,1:4.4-4.1+deb9u1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",login1:4.4-4.1+deb9u1 debCVE-2007-5686Negligible
passwd,1:4.4-4.1+deb9u1, ,deb,CVE-2007-5686,Negligible,2007-10-28T17:08:00.000,"'initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.'",passwd1:4.4-4.1+deb9u1 debCVE-2007-5686Negligible
perl-base,5.32.1-4+deb11u1,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl-base5.32.1-4+deb11u1(won't fix)debCVE-2023-31484High
perl-base,5.32.1-4+deb11u2,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl-base5.32.1-4+deb11u2(won't fix)debCVE-2023-31484High
perl-base,5.36.0-7,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl-base5.36.0-7(won't fix)debCVE-2023-31484High
perl-base,5.28.1-6+deb10u1,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl-base5.28.1-6+deb10u1(won't fix)debCVE-2023-31484High
libperl5.28,5.28.1-6+deb10u1,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',libperl5.285.28.1-6+deb10u1(won't fix)debCVE-2023-31484High
perl,5.28.1-6+deb10u1,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl5.28.1-6+deb10u1(won't fix)debCVE-2023-31484High
perl-modules-5.28,5.28.1-6+deb10u1,(won't fix),deb,CVE-2023-31484,High,2023-04-29T00:15:09.000,'CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.',perl-modules-5.285.28.1-6+deb10u1(won't fix)debCVE-2023-31484High
perl-base,5.32.1-4+deb11u1,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl-base5.32.1-4+deb11u1(won't fix)debCVE-2020-16156High
perl-base,5.32.1-4+deb11u2,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl-base5.32.1-4+deb11u2(won't fix)debCVE-2020-16156High
perl-base,5.28.1-6+deb10u1,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl-base5.28.1-6+deb10u1(won't fix)debCVE-2020-16156High
perl-base,5.24.1-3+deb9u7,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl-base5.24.1-3+deb9u7(won't fix)debCVE-2020-16156High
libperl5.28,5.28.1-6+deb10u1,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',libperl5.285.28.1-6+deb10u1(won't fix)debCVE-2020-16156High
perl,5.28.1-6+deb10u1,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl5.28.1-6+deb10u1(won't fix)debCVE-2020-16156High
perl-modules-5.28,5.28.1-6+deb10u1,(won't fix),deb,CVE-2020-16156,High,2021-12-13T18:15:07.943,'CPAN 2.28 allows Signature Verification Bypass.',perl-modules-5.285.28.1-6+deb10u1(won't fix)debCVE-2020-16156High
perl-base,5.32.1-4+deb11u1, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl-base5.32.1-4+deb11u1 debCVE-2023-31486Negligible
perl-base,5.32.1-4+deb11u2, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl-base5.32.1-4+deb11u2 debCVE-2023-31486Negligible
perl-base,5.36.0-7, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl-base5.36.0-7 debCVE-2023-31486Negligible
perl-base,5.28.1-6+deb10u1, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl-base5.28.1-6+deb10u1 debCVE-2023-31486Negligible
libperl5.28,5.28.1-6+deb10u1, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",libperl5.285.28.1-6+deb10u1 debCVE-2023-31486Negligible
perl,5.28.1-6+deb10u1, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl5.28.1-6+deb10u1 debCVE-2023-31486Negligible
perl-modules-5.28,5.28.1-6+deb10u1, ,deb,CVE-2023-31486,Negligible,2023-04-29T00:15:09.083,"'HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.'",perl-modules-5.285.28.1-6+deb10u1 debCVE-2023-31486Negligible
perl-base,5.32.1-4+deb11u1, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-base5.32.1-4+deb11u1 debCVE-2011-4116Negligible
perl-base,5.32.1-4+deb11u2, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-base5.32.1-4+deb11u2 debCVE-2011-4116Negligible
perl-base,5.36.0-7, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-base5.36.0-7 debCVE-2011-4116Negligible
perl-base,5.28.1-6+deb10u1, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-base5.28.1-6+deb10u1 debCVE-2011-4116Negligible
perl-base,5.24.1-3+deb9u7, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-base5.24.1-3+deb9u7 debCVE-2011-4116Negligible
libperl5.28,5.28.1-6+deb10u1, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',libperl5.285.28.1-6+deb10u1 debCVE-2011-4116Negligible
perl,5.28.1-6+deb10u1, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl5.28.1-6+deb10u1 debCVE-2011-4116Negligible
perl-modules-5.28,5.28.1-6+deb10u1, ,deb,CVE-2011-4116,Negligible,2020-01-31T18:15:11.343,'_is_safe in the File::Temp module for Perl does not properly handle symlinks.',perl-modules-5.285.28.1-6+deb10u1 debCVE-2011-4116Negligible
tar,1.34+dfsg-1, ,deb,CVE-2022-48303,Negligible,2023-01-30T04:15:08.030,'GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.',tar1.34+dfsg-1 debCVE-2022-48303Negligible
tar,1.34+dfsg-1.2, ,deb,CVE-2022-48303,Negligible,2023-01-30T04:15:08.030,'GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.',tar1.34+dfsg-1.2 debCVE-2022-48303Negligible
tar,1.30+dfsg-6, ,deb,CVE-2022-48303,Negligible,2023-01-30T04:15:08.030,'GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.',tar1.30+dfsg-6 debCVE-2022-48303Negligible
tar,1.34+dfsg-1, ,deb,CVE-2005-2541,Negligible,2005-08-10T04:00:00.000,"'Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.'",tar1.34+dfsg-1 debCVE-2005-2541Negligible
tar,1.34+dfsg-1.2, ,deb,CVE-2005-2541,Negligible,2005-08-10T04:00:00.000,"'Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.'",tar1.34+dfsg-1.2 debCVE-2005-2541Negligible
tar,1.30+dfsg-6, ,deb,CVE-2005-2541,Negligible,2005-08-10T04:00:00.000,"'Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.'",tar1.30+dfsg-6 debCVE-2005-2541Negligible
tar,1.29b-1.1+deb9u1, ,deb,CVE-2005-2541,Negligible,2005-08-10T04:00:00.000,"'Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.'",tar1.29b-1.1+deb9u1 debCVE-2005-2541Negligible
tar,1.29b-1.1, ,deb,CVE-2005-2541,Negligible,2005-08-10T04:00:00.000,"'Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.'",tar1.29b-1.1 debCVE-2005-2541Negligible
zlib1g,1:1.2.11.dfsg-2, ,deb,CVE-2023-45853,Critical,2023-10-14T02:15:09.323,"'MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product.'",zlib1g1:1.2.11.dfsg-2 debCVE-2023-45853Critical
zlib1g,1:1.2.13.dfsg-1, ,deb,CVE-2023-45853,Critical,2023-10-14T02:15:09.323,"'MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product.'",zlib1g1:1.2.13.dfsg-1 debCVE-2023-45853Critical
zlib1g,1:1.2.11.dfsg-1, ,deb,CVE-2023-45853,Critical,2023-10-14T02:15:09.323,"'MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product.'",zlib1g1:1.2.11.dfsg-1 debCVE-2023-45853Critical
zlib1g,1:1.2.11.dfsg-2+deb11u1, ,deb,CVE-2023-45853,Critical,2023-10-14T02:15:09.323,"'MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product.'",zlib1g1:1.2.11.dfsg-2+deb11u1 debCVE-2023-45853Critical
zlib1g,1:1.2.11.dfsg-2,1:1.2.11.dfsg-2+deb11u2,deb,CVE-2022-37434,Critical,2022-08-05T07:15:07.240,"'zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).'",zlib1g1:1.2.11.dfsg-21:1.2.11.dfsg-2+deb11u2debCVE-2022-37434Critical
zlib1g,1:1.2.11.dfsg-1,1:1.2.11.dfsg-1+deb10u2,deb,CVE-2022-37434,Critical,2022-08-05T07:15:07.240,"'zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).'",zlib1g1:1.2.11.dfsg-11:1.2.11.dfsg-1+deb10u2debCVE-2022-37434Critical
zlib1g,1:1.2.11.dfsg-2+deb11u1,1:1.2.11.dfsg-2+deb11u2,deb,CVE-2022-37434,Critical,2022-08-05T07:15:07.240,"'zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).'",zlib1g1:1.2.11.dfsg-2+deb11u11:1.2.11.dfsg-2+deb11u2debCVE-2022-37434Critical
zlib1g,1:1.2.11.dfsg-2,1:1.2.11.dfsg-2+deb11u1,deb,CVE-2018-25032,High,2022-03-25T09:15:08.187,"'zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.'",zlib1g1:1.2.11.dfsg-21:1.2.11.dfsg-2+deb11u1debCVE-2018-25032High
zlib1g,1:1.2.11.dfsg-1,1:1.2.11.dfsg-1+deb10u1,deb,CVE-2018-25032,High,2022-03-25T09:15:08.187,"'zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.'",zlib1g1:1.2.11.dfsg-11:1.2.11.dfsg-1+deb10u1debCVE-2018-25032High
zlib1g,1:1.2.8.dfsg-5,1:1.2.8.dfsg-5+deb9u1,deb,CVE-2018-25032,High,2022-03-25T09:15:08.187,"'zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.'",zlib1g1:1.2.8.dfsg-51:1.2.8.dfsg-5+deb9u1debCVE-2018-25032High
libc6,2.36-9+deb12u1,2.36-9+deb12u3,deb,CVE-2023-4527,Medium,2023-09-18T17:15:55.067,"'A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.'",libc62.36-9+deb12u12.36-9+deb12u3debCVE-2023-4527Medium
libc-bin,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4527,Medium,2023-09-18T17:15:55.067,"'A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.'",libc-bin2.36-92.36-9+deb12u3debCVE-2023-4527Medium
libc6,2.36-9,2.36-9+deb12u3,deb,CVE-2023-4527,Medium,2023-09-18T17:15:55.067,"'A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.'",libc62.36-92.36-9+deb12u3debCVE-2023-4527Medium
libssl3,3.0.9-1,3.0.10-1~deb12u1,deb,CVE-2023-2975,Medium,2023-07-14T12:15:09.023,'Issue summary: The AES-SIV cipher implementation contains a bug that causes\nit to ignore empty associated data entries which are unauthenticated as\na consequence.\n\nImpact summary: Applications that use the AES-SIV algorithm and want to\nauthenticate empty data entries as associated data can be mislead by removing\nadding or reordering such empty entries as these are ignored by the OpenSSL\nimplementation. We are currently unaware of any such applications.\n\nThe AES-SIV algorithm allows for authentication of multiple associated\ndata entries along with the encryption. To authenticate empty data the\napplication has to call EVP_EncryptUpdate() (or EVP_CipherUpdate()) with\nNULL pointer as the output buffer and 0 as the input buffer length.\nThe AES-SIV implementation in OpenSSL just returns success for such a call\ninstead of performing the associated data authentication operation.\nThe empty data thus will not be authenticated.\n\nAs this issue does not affect non-empty associated data authentication and\nwe expect it to be rare for an application to use empty associated data\nentries this is qualified as Low severity issue.',libssl33.0.9-13.0.10-1~deb12u1debCVE-2023-2975Medium
libssl3,3.0.9-1,3.0.11-1~deb12u2,deb,CVE-2023-5363,Unknown,2023-10-25T18:17:43.613,"'Issue summary: A bug has been identified in the processing of key and\ninitialisation vector (IV) lengths.  This can lead to potential truncation\nor overruns during the initialisation of some symmetric ciphers.\n\nImpact summary: A truncation in the IV can result in non-uniqueness,\nwhich could result in loss of confidentiality for some cipher modes.\n\nWhen calling EVP_EncryptInit_ex2(), EVP_DecryptInit_ex2() or\nEVP_CipherInit_ex2() the provided OSSL_PARAM array is processed after\nthe key and IV have been established.  Any alterations to the key length,\nvia the ""keylen"" parameter or the IV length, via the ""ivlen"" parameter,\nwithin the OSSL_PARAM array will not take effect as intended, potentially\ncausing truncation or overreading of these values.  The following ciphers\nand cipher modes are impacted: RC2, RC4, RC5, CCM, GCM and OCB.\n\nFor the CCM, GCM and OCB cipher modes, truncation of the IV can result in\nloss of confidentiality.  For example, when following NIST\'s SP 800-38D\nsection 8.2.1 guidance for constructing a deterministic IV for AES in\nGCM mode, truncation of the counter portion could lead to IV reuse.\n\nBoth truncations and overruns of the key and overruns of the IV will\nproduce incorrect results and could, in some cases, trigger a memory\nexception.  However, these issues are not currently assessed as security\ncritical.\n\nChanging the key and/or IV lengths is not considered to be a common operation\nand the vulnerable API was recently introduced. Furthermore it is likely that\napplication developers will have spotted this problem during testing since\ndecryption would fail unless both peers in the communication were similarly\nvulnerable. For these reasons we expect the probability of an application being\nvulnerable to this to be quite low. However if an application is vulnerable then\nthis issue is considered very serious. For these reasons we have assessed this\nissue as Moderate severity overall.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this because\nthe issue lies outside of the FIPS provider boundary.\n\nOpenSSL 3.1 and 3.0 are vulnerable to this issue.'",libssl33.0.9-13.0.11-1~deb12u2debCVE-2023-5363Unknown
gcc-12-base,12.2.0-14, ,deb,CVE-2022-27943,Negligible,2022-03-26T13:15:07.900,"'libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.'",gcc-12-base12.2.0-14 debCVE-2022-27943Negligible
libgcc-s1,12.2.0-14, ,deb,CVE-2022-27943,Negligible,2022-03-26T13:15:07.900,"'libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.'",libgcc-s112.2.0-14 debCVE-2022-27943Negligible
libstdc++6,12.2.0-14, ,deb,CVE-2022-27943,Negligible,2022-03-26T13:15:07.900,"'libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.'",libstdc++612.2.0-14 debCVE-2022-27943Negligible
bsdutils,1:2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",bsdutils1:2.33.1-0.1(won't fix)debCVE-2021-37600Low
bsdutils,1:2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",bsdutils1:2.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
libblkid1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libblkid12.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
libfdisk1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libfdisk12.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
libmount1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libmount12.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
libsmartcols1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libsmartcols12.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
libuuid1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libuuid12.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
mount,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",mount2.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
util-linux,2.29.2-1+deb9u1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",util-linux2.29.2-1+deb9u1(won't fix)debCVE-2021-37600Low
fdisk,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",fdisk2.33.1-0.1(won't fix)debCVE-2021-37600Low
libblkid1,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libblkid12.33.1-0.1(won't fix)debCVE-2021-37600Low
libfdisk1,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libfdisk12.33.1-0.1(won't fix)debCVE-2021-37600Low
libmount1,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libmount12.33.1-0.1(won't fix)debCVE-2021-37600Low
libsmartcols1,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libsmartcols12.33.1-0.1(won't fix)debCVE-2021-37600Low
libuuid1,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",libuuid12.33.1-0.1(won't fix)debCVE-2021-37600Low
mount,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",mount2.33.1-0.1(won't fix)debCVE-2021-37600Low
util-linux,2.33.1-0.1,(won't fix),deb,CVE-2021-37600,Low,2021-07-30T14:15:18.737,"'An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments'",util-linux2.33.1-0.1(won't fix)debCVE-2021-37600Low
gcc-8-base,8.3.0-6,(won't fix),deb,CVE-2019-15847,High,2019-09-02T23:15:10.837,"'The POWER9 backend in GNU Compiler Collection (GCC) before version 10 could optimize multiple calls of the __builtin_darn intrinsic into a single call, thus reducing the entropy of the random number generator. This occurred because a volatile operation was not specified. For example, within a single execution of a program, the output of every __builtin_darn() call may be the same.'",gcc-8-base8.3.0-6(won't fix)debCVE-2019-15847High
libgcc1,1:8.3.0-6,(won't fix),deb,CVE-2019-15847,High,2019-09-02T23:15:10.837,"'The POWER9 backend in GNU Compiler Collection (GCC) before version 10 could optimize multiple calls of the __builtin_darn intrinsic into a single call, thus reducing the entropy of the random number generator. This occurred because a volatile operation was not specified. For example, within a single execution of a program, the output of every __builtin_darn() call may be the same.'",libgcc11:8.3.0-6(won't fix)debCVE-2019-15847High
libstdc++6,8.3.0-6,(won't fix),deb,CVE-2019-15847,High,2019-09-02T23:15:10.837,"'The POWER9 backend in GNU Compiler Collection (GCC) before version 10 could optimize multiple calls of the __builtin_darn intrinsic into a single call, thus reducing the entropy of the random number generator. This occurred because a volatile operation was not specified. For example, within a single execution of a program, the output of every __builtin_darn() call may be the same.'",libstdc++68.3.0-6(won't fix)debCVE-2019-15847High
gcc-8-base,8.3.0-6,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",gcc-8-base8.3.0-6(won't fix)debCVE-2018-12886High
libgcc1,1:8.3.0-6,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",libgcc11:8.3.0-6(won't fix)debCVE-2018-12886High
libstdc++6,8.3.0-6,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",libstdc++68.3.0-6(won't fix)debCVE-2018-12886High
gcc-6-base,6.3.0-18+deb9u1,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",gcc-6-base6.3.0-18+deb9u1(won't fix)debCVE-2018-12886High
libgcc1,1:6.3.0-18+deb9u1,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",libgcc11:6.3.0-18+deb9u1(won't fix)debCVE-2018-12886High
libstdc++6,6.3.0-18+deb9u1,(won't fix),deb,CVE-2018-12886,High,2019-05-22T19:29:00.297,"'stack_protect_prologue in cfgexpand.c and stack_protect_epilogue in function.c in GNU Compiler Collection (GCC) 4.1 through 8 (under certain circumstances) generate instruction sequences when targeting ARM targets that spill the address of the stack protector guard, which allows an attacker to bypass the protection of -fstack-protector, -fstack-protector-all, -fstack-protector-strong, and -fstack-protector-explicit against stack overflow by controlling what the stack canary is compared against.'",libstdc++66.3.0-18+deb9u1(won't fix)debCVE-2018-12886High
gpgv,2.2.12-1+deb10u1,(won't fix),deb,CVE-2019-14855,Low,2020-03-20T16:15:14.680,'A flaw was found in the way certificate signatures could be forged using collisions found in the SHA-1 algorithm. An attacker could use this weakness to create forged certificate signatures. This issue affects GnuPG versions before 2.2.18.',gpgv2.2.12-1+deb10u1(won't fix)debCVE-2019-14855Low
gpgv,2.1.18-8~deb9u4,(won't fix),deb,CVE-2019-14855,Low,2020-03-20T16:15:14.680,'A flaw was found in the way certificate signatures could be forged using collisions found in the SHA-1 algorithm. An attacker could use this weakness to create forged certificate signatures. This issue affects GnuPG versions before 2.2.18.',gpgv2.1.18-8~deb9u4(won't fix)debCVE-2019-14855Low
iptables,1.8.5-3~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',iptables1.8.5-3~bpo10+1 debCVE-2019-11360Negligible
libip4tc2,1.8.5-3~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libip4tc21.8.5-3~bpo10+1 debCVE-2019-11360Negligible
libip6tc2,1.8.5-3~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libip6tc21.8.5-3~bpo10+1 debCVE-2019-11360Negligible
libxtables12,1.8.5-3~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libxtables121.8.5-3~bpo10+1 debCVE-2019-11360Negligible
iptables,1.8.3-2~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',iptables1.8.3-2~bpo10+1 debCVE-2019-11360Negligible
libip4tc2,1.8.3-2~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libip4tc21.8.3-2~bpo10+1 debCVE-2019-11360Negligible
libip6tc2,1.8.3-2~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libip6tc21.8.3-2~bpo10+1 debCVE-2019-11360Negligible
libiptc0,1.8.3-2~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libiptc01.8.3-2~bpo10+1 debCVE-2019-11360Negligible
libxtables12,1.8.3-2~bpo10+1, ,deb,CVE-2019-11360,Negligible,2019-07-12T14:15:11.733,'A buffer overflow in iptables-restore in netfilter iptables 1.8.2 allows an attacker to (at least) crash the program or potentially gain code execution via a specially crafted iptables-save file. This is related to add_param_to_argv in xshared.c.',libxtables121.8.3-2~bpo10+1 debCVE-2019-11360Negligible
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc-bin2.28-102.28-10+deb10u2debCVE-2021-35942Critical
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc62.28-102.28-10+deb10u2debCVE-2021-35942Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2021-35942Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc62.24-11+deb9u4(won't fix)debCVE-2021-35942Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2021-35942Critical
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2021-35942Critical
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2021-35942,Critical,2021-07-22T18:15:23.287,"'The wordexp function in the GNU C Library (aka glibc) through 2.33 may crash or read arbitrary memory in parse_param (in posix/wordexp.c) when called with an untrusted, crafted pattern, potentially resulting in a denial of service or disclosure of information. This occurs because atoi was used but strtoul should have been used to ensure correct calculations.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2021-35942Critical
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc-bin2.28-102.28-10+deb10u2debCVE-2021-3326High
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc62.28-102.28-10+deb10u2debCVE-2021-3326High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2021-3326High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc62.24-11+deb9u4(won't fix)debCVE-2021-3326High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2021-3326High
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2021-3326High
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2021-3326,High,2021-01-27T20:15:14.020,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid input sequences in the ISO-2022-JP-3 encoding, fails an assertion in the code path and aborts the program, potentially resulting in a denial of service.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2021-3326High
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-6096,High,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc-bin2.28-102.28-10+deb10u2debCVE-2020-6096High
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2020-6096,High,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc62.28-102.28-10+deb10u2debCVE-2020-6096High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2020-6096,Low,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc-bin2.24-11+deb9u4(won't fix)debCVE-2020-6096Low
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2020-6096,Low,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc62.24-11+deb9u4(won't fix)debCVE-2020-6096Low
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2020-6096,Low,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2020-6096Low
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-6096,High,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2020-6096High
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2020-6096,High,2020-04-01T22:15:18.503,"""An exploitable signed comparison vulnerability exists in the ARMv7 memcpy() implementation of GNU glibc 2.30.9000. Calling memcpy() (on ARMv7 targets that utilize the GNU glibc implementation) with a negative value for the 'num' parameter results in a signed comparison vulnerability. If an attacker underflows the 'num' parameter to memcpy(), this vulnerability could lead to undefined behavior such as writing to out-of-bounds memory and potentially remote code execution. Furthermore, this memcpy() implementation allows for program execution to continue in scenarios where a segmentation fault or crash should have occurred. The dangers occur in that subsequent execution and iterations of this code will be executed with this corrupted data.""",libc6-dev2.28-102.28-10+deb10u2debCVE-2020-6096High
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc-bin2.28-102.28-10+deb10u2debCVE-2020-1752High
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc62.28-102.28-10+deb10u2debCVE-2020-1752High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2020-1752High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc62.24-11+deb9u4(won't fix)debCVE-2020-1752High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2020-1752High
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2020-1752High
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2020-1752,High,2020-04-30T17:15:13.067,"'A use-after-free vulnerability introduced in glibc upstream version 2.14 was found in the way the tilde expansion was carried out. Directory paths containing an initial tilde followed by a valid username were affected by this issue. A local attacker could exploit this flaw by creating a specially crafted path that, when processed by the glob function, would potentially lead to arbitrary code execution. This was fixed in version 2.32.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2020-1752High
libc-bin,2.28-10,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc-bin2.28-10(won't fix)debCVE-2020-1751High
libc6,2.28-10,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc62.28-10(won't fix)debCVE-2020-1751High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2020-1751High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc62.24-11+deb9u4(won't fix)debCVE-2020-1751High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2020-1751High
libc-dev-bin,2.28-10,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc-dev-bin2.28-10(won't fix)debCVE-2020-1751High
libc6-dev,2.28-10,(won't fix),deb,CVE-2020-1751,High,2020-04-17T19:15:14.437,"'An out-of-bounds write vulnerability was found in glibc before 2.31 when handling signal trampolines on PowerPC. Specifically, the backtrace function did not properly check the array bounds when storing the frame address, resulting in a denial of service or potential code execution. The highest threat from this vulnerability is to system availability.'",libc6-dev2.28-10(won't fix)debCVE-2020-1751High
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc-bin2.28-102.28-10+deb10u2debCVE-2020-27618Medium
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc62.28-102.28-10+deb10u2debCVE-2020-27618Medium
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2020-27618Medium
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc62.24-11+deb9u4(won't fix)debCVE-2020-27618Medium
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2020-27618Medium
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2020-27618Medium
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2020-27618,Medium,2021-02-26T23:15:11.123,"'The iconv function in the GNU C Library (aka glibc or libc6) 2.32 and earlier, when processing invalid multi-byte input sequences in IBM1364, IBM1371, IBM1388, IBM1390, and IBM1399 encodings, fails to advance the input state, which could lead to an infinite loop in applications, resulting in a denial of service, a different vulnerability from CVE-2016-10228.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2020-27618Medium
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc-bin2.28-102.28-10+deb10u2debCVE-2020-10029Medium
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc62.28-102.28-10+deb10u2debCVE-2020-10029Medium
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2020-10029Medium
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc62.24-11+deb9u4(won't fix)debCVE-2020-10029Medium
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2020-10029Medium
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2020-10029Medium
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2020-10029,Medium,2020-03-04T15:15:13.083,"'The GNU C Library (aka glibc or libc6) before 2.32 could overflow an on-stack buffer during range reduction if an input to an 80-bit long double function contains a non-canonical bit pattern, a seen when passing a 0x5d414141414141410000 value to sinl on x86 targets. This is related to sysdeps/ieee754/ldbl-96/e_rem_pio2l.c.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2020-10029Medium
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc-bin2.28-102.28-10+deb10u2debCVE-2019-25013Medium
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc62.28-102.28-10+deb10u2debCVE-2019-25013Medium
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2019-25013Medium
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc62.24-11+deb9u4(won't fix)debCVE-2019-25013Medium
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2019-25013Medium
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2019-25013Medium
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2019-25013,Medium,2021-01-04T18:15:13.027,"'The iconv feature in the GNU C Library (aka glibc or libc6) through 2.32, when processing invalid multi-byte input sequences in the EUC-KR encoding, may have a buffer over-read.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2019-25013Medium
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc-bin2.28-102.28-10+deb10u2debCVE-2021-27645Low
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc62.28-102.28-10+deb10u2debCVE-2021-27645Low
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2021-27645Low
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc62.24-11+deb9u4(won't fix)debCVE-2021-27645Low
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2021-27645Low
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2021-27645Low
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2021-27645,Low,2021-02-24T15:15:13.837,"'The nameserver caching daemon (nscd) in the GNU C Library (aka glibc or libc6) 2.29 through 2.33, when processing a request for netgroup lookup, may crash due to a double-free, potentially resulting in degraded service or Denial of Service on the local system. This is related to netgroupcache.c.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2021-27645Low
libc-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc-bin2.28-102.28-10+deb10u2debCVE-2019-19126Low
libc6,2.28-10,2.28-10+deb10u2,deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc62.28-102.28-10+deb10u2debCVE-2019-19126Low
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2019-19126Low
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc62.24-11+deb9u4(won't fix)debCVE-2019-19126Low
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2019-19126Low
libc-dev-bin,2.28-10,2.28-10+deb10u2,deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc-dev-bin2.28-102.28-10+deb10u2debCVE-2019-19126Low
libc6-dev,2.28-10,2.28-10+deb10u2,deb,CVE-2019-19126,Low,2019-11-19T22:15:11.427,"'On the x86-64 architecture, the GNU C Library (aka glibc) before 2.31 fails to ignore the LD_PREFER_MAP_32BIT_EXEC environment variable during program execution after a security transition, allowing local attackers to restrict the possible mapping addresses for loaded libraries and thus bypass ASLR for a setuid program.'",libc6-dev2.28-102.28-10+deb10u2debCVE-2019-19126Low
libgcrypt20,1.8.4-5+deb10u1,(won't fix),deb,CVE-2019-13627,Medium,2019-09-25T15:15:11.877,"'It was discovered that there was a ECDSA timing attack in the libgcrypt20 cryptographic library. Version affected: 1.8.4-5, 1.7.6-2+deb9u3, and 1.6.3-2+deb8u4. Versions fixed: 1.8.5-2 and 1.6.3-2+deb8u7.'",libgcrypt201.8.4-5+deb10u1(won't fix)debCVE-2019-13627Medium
libgcrypt20,1.8.4-5,(won't fix),deb,CVE-2019-13627,Medium,2019-09-25T15:15:11.877,"'It was discovered that there was a ECDSA timing attack in the libgcrypt20 cryptographic library. Version affected: 1.8.4-5, 1.7.6-2+deb9u3, and 1.6.3-2+deb8u4. Versions fixed: 1.8.5-2 and 1.6.3-2+deb8u7.'",libgcrypt201.8.4-5(won't fix)debCVE-2019-13627Medium
libgcrypt20,1.7.6-2+deb9u4,(won't fix),deb,CVE-2019-13627,Medium,2019-09-25T15:15:11.877,"'It was discovered that there was a ECDSA timing attack in the libgcrypt20 cryptographic library. Version affected: 1.8.4-5, 1.7.6-2+deb9u3, and 1.6.3-2+deb8u4. Versions fixed: 1.8.5-2 and 1.6.3-2+deb8u7.'",libgcrypt201.7.6-2+deb9u4(won't fix)debCVE-2019-13627Medium
libgcrypt20,1.7.6-2+deb9u3,(won't fix),deb,CVE-2019-13627,Medium,2019-09-25T15:15:11.877,"'It was discovered that there was a ECDSA timing attack in the libgcrypt20 cryptographic library. Version affected: 1.8.4-5, 1.7.6-2+deb9u3, and 1.6.3-2+deb8u4. Versions fixed: 1.8.5-2 and 1.6.3-2+deb8u7.'",libgcrypt201.7.6-2+deb9u3(won't fix)debCVE-2019-13627Medium
libidn2-0,2.0.5-1+deb10u1,(won't fix),deb,CVE-2019-12290,High,2019-10-22T16:15:10.877,"'GNU libidn2 before 2.2.0 fails to perform the roundtrip checks specified in RFC3490 Section 4.2 when converting A-labels to U-labels. This makes it possible in some circumstances for one domain to impersonate another. By creating a malicious domain that matches a target domain except for the inclusion of certain punycoded Unicode characters (that would be discarded when converted first to a Unicode label and then back to an ASCII label), arbitrary domains can be impersonated.'",libidn2-02.0.5-1+deb10u1(won't fix)debCVE-2019-12290High
liblz4-1,1.8.3-1+deb10u1,(won't fix),deb,CVE-2019-17543,Low,2019-10-14T02:15:10.873,"'LZ4 before 1.9.2 has a heap-based buffer overflow in LZ4_write32 (related to LZ4_compress_destSize), affecting applications that call LZ4_compress_fast with a large input. (This issue can also lead to data corruption.) NOTE: the vendor states ""only a few specific / uncommon usages of the API are at risk.""'",liblz4-11.8.3-1+deb10u1(won't fix)debCVE-2019-17543Low
liblz4-1,1.8.3-1,(won't fix),deb,CVE-2019-17543,Low,2019-10-14T02:15:10.873,"'LZ4 before 1.9.2 has a heap-based buffer overflow in LZ4_write32 (related to LZ4_compress_destSize), affecting applications that call LZ4_compress_fast with a large input. (This issue can also lead to data corruption.) NOTE: the vendor states ""only a few specific / uncommon usages of the API are at risk.""'",liblz4-11.8.3-1(won't fix)debCVE-2019-17543Low
liblz4-1,0.0~r131-2+deb9u1,(won't fix),deb,CVE-2019-17543,Low,2019-10-14T02:15:10.873,"'LZ4 before 1.9.2 has a heap-based buffer overflow in LZ4_write32 (related to LZ4_compress_destSize), affecting applications that call LZ4_compress_fast with a large input. (This issue can also lead to data corruption.) NOTE: the vendor states ""only a few specific / uncommon usages of the API are at risk.""'",liblz4-10.0~r131-2+deb9u1(won't fix)debCVE-2019-17543Low
liblz4-1,0.0~r131-2+b1,(won't fix),deb,CVE-2019-17543,Low,2019-10-14T02:15:10.873,"'LZ4 before 1.9.2 has a heap-based buffer overflow in LZ4_write32 (related to LZ4_compress_destSize), affecting applications that call LZ4_compress_fast with a large input. (This issue can also lead to data corruption.) NOTE: the vendor states ""only a few specific / uncommon usages of the API are at risk.""'",liblz4-10.0~r131-2+b1(won't fix)debCVE-2019-17543Low
libpcre3,2:8.39-12,(won't fix),deb,CVE-2020-14155,Medium,2020-06-15T17:15:10.777,'libpcre in PCRE before 8.44 allows an integer overflow via a large number after a (?C substring.',libpcre32:8.39-12(won't fix)debCVE-2020-14155Medium
libpcre3,2:8.39-3,(won't fix),deb,CVE-2020-14155,Medium,2020-06-15T17:15:10.777,'libpcre in PCRE before 8.44 allows an integer overflow via a large number after a (?C substring.',libpcre32:8.39-3(won't fix)debCVE-2020-14155Medium
libseccomp2,2.3.3-4, ,deb,CVE-2019-9893,Negligible,2019-03-21T16:01:17.687,"'libseccomp before 2.4.0 did not correctly generate 64-bit syscall argument comparisons using the arithmetic operators (LT, GT, LE, GE), which might able to lead to bypassing seccomp filters and potential privilege escalations.'",libseccomp22.3.3-4 debCVE-2019-9893Negligible
libsystemd0,241-7~deb10u7,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libsystemd0241-7~deb10u7241-7~deb10u9debCVE-2023-26604High
libudev1,241-7~deb10u7,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libudev1241-7~deb10u7241-7~deb10u9debCVE-2023-26604High
libsystemd0,241-7~deb10u8,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libsystemd0241-7~deb10u8241-7~deb10u9debCVE-2023-26604High
libudev1,241-7~deb10u8,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libudev1241-7~deb10u8241-7~deb10u9debCVE-2023-26604High
libsystemd0,241-7~deb10u4,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libsystemd0241-7~deb10u4241-7~deb10u9debCVE-2023-26604High
libudev1,241-7~deb10u4,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",libudev1241-7~deb10u4241-7~deb10u9debCVE-2023-26604High
udev,241-7~deb10u4,241-7~deb10u9,deb,CVE-2023-26604,High,2023-03-03T16:15:10.607,"'systemd before 247 does not adequately block local privilege escalation for some Sudo configurations, e.g., plausible sudoers files in which the ""systemctl status"" command may be executed. Specifically, systemd does not set LESSSECURE to 1, and thus other programs may be launched from the less program. This presents a substantial security risk when running systemctl from Sudo, because less executes as root when the terminal size is too small to show the complete systemctl output.'",udev241-7~deb10u4241-7~deb10u9debCVE-2023-26604High
libsystemd0,241-7~deb10u7,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libsystemd0241-7~deb10u7(won't fix)debCVE-2019-3844High
libudev1,241-7~deb10u7,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libudev1241-7~deb10u7(won't fix)debCVE-2019-3844High
libsystemd0,241-7~deb10u8,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libsystemd0241-7~deb10u8(won't fix)debCVE-2019-3844High
libudev1,241-7~deb10u8,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libudev1241-7~deb10u8(won't fix)debCVE-2019-3844High
libsystemd0,241-7~deb10u4,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libsystemd0241-7~deb10u4(won't fix)debCVE-2019-3844High
libudev1,241-7~deb10u4,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libudev1241-7~deb10u4(won't fix)debCVE-2019-3844High
libsystemd0,232-25+deb9u13,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libsystemd0232-25+deb9u13(won't fix)debCVE-2019-3844High
libudev1,232-25+deb9u13,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libudev1232-25+deb9u13(won't fix)debCVE-2019-3844High
udev,241-7~deb10u4,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",udev241-7~deb10u4(won't fix)debCVE-2019-3844High
libsystemd0,232-25+deb9u12,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libsystemd0232-25+deb9u12(won't fix)debCVE-2019-3844High
libudev1,232-25+deb9u12,(won't fix),deb,CVE-2019-3844,High,2019-04-26T21:29:00.423,"'It was discovered that a systemd service that uses DynamicUser property can get new privileges through the execution of SUID binaries, which would allow to create binaries owned by the service transient group with the setgid bit set. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the GID will be recycled.'",libudev1232-25+deb9u12(won't fix)debCVE-2019-3844High
libsystemd0,241-7~deb10u7,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libsystemd0241-7~deb10u7(won't fix)debCVE-2019-3843High
libudev1,241-7~deb10u7,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libudev1241-7~deb10u7(won't fix)debCVE-2019-3843High
libsystemd0,241-7~deb10u8,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libsystemd0241-7~deb10u8(won't fix)debCVE-2019-3843High
libudev1,241-7~deb10u8,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libudev1241-7~deb10u8(won't fix)debCVE-2019-3843High
libsystemd0,241-7~deb10u4,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libsystemd0241-7~deb10u4(won't fix)debCVE-2019-3843High
libudev1,241-7~deb10u4,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libudev1241-7~deb10u4(won't fix)debCVE-2019-3843High
libsystemd0,232-25+deb9u13,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libsystemd0232-25+deb9u13(won't fix)debCVE-2019-3843High
libudev1,232-25+deb9u13,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libudev1232-25+deb9u13(won't fix)debCVE-2019-3843High
udev,241-7~deb10u4,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",udev241-7~deb10u4(won't fix)debCVE-2019-3843High
libsystemd0,232-25+deb9u12,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libsystemd0232-25+deb9u12(won't fix)debCVE-2019-3843High
libudev1,232-25+deb9u12,(won't fix),deb,CVE-2019-3843,High,2019-04-26T21:29:00.360,"'It was discovered that a systemd service that uses DynamicUser property can create a SUID/SGID binary that would be allowed to run as the transient service UID/GID even after the service is terminated. A local attacker may use this flaw to access resources that will be owned by a potentially different service in the future, when the UID/GID will be recycled.'",libudev1232-25+deb9u12(won't fix)debCVE-2019-3843High
libsystemd0,241-7~deb10u7,241-7~deb10u8,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libsystemd0241-7~deb10u7241-7~deb10u8debCVE-2021-33910Medium
libudev1,241-7~deb10u7,241-7~deb10u8,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libudev1241-7~deb10u7241-7~deb10u8debCVE-2021-33910Medium
libsystemd0,241-7~deb10u4,241-7~deb10u8,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libsystemd0241-7~deb10u4241-7~deb10u8debCVE-2021-33910Medium
libudev1,241-7~deb10u4,241-7~deb10u8,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libudev1241-7~deb10u4241-7~deb10u8debCVE-2021-33910Medium
udev,241-7~deb10u4,241-7~deb10u8,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",udev241-7~deb10u4241-7~deb10u8debCVE-2021-33910Medium
libsystemd0,232-25+deb9u12,232-25+deb9u13,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libsystemd0232-25+deb9u12232-25+deb9u13debCVE-2021-33910Medium
libudev1,232-25+deb9u12,232-25+deb9u13,deb,CVE-2021-33910,Medium,2021-07-20T19:15:09.783,"'basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.'",libudev1232-25+deb9u12232-25+deb9u13debCVE-2021-33910Medium
libsystemd0,241-7~deb10u7, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libsystemd0241-7~deb10u7 debCVE-2019-20386Negligible
libudev1,241-7~deb10u7, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libudev1241-7~deb10u7 debCVE-2019-20386Negligible
libsystemd0,241-7~deb10u8, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libsystemd0241-7~deb10u8 debCVE-2019-20386Negligible
libudev1,241-7~deb10u8, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libudev1241-7~deb10u8 debCVE-2019-20386Negligible
libsystemd0,241-7~deb10u4, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libsystemd0241-7~deb10u4 debCVE-2019-20386Negligible
libudev1,241-7~deb10u4, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libudev1241-7~deb10u4 debCVE-2019-20386Negligible
libsystemd0,232-25+deb9u13, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libsystemd0232-25+deb9u13 debCVE-2019-20386Negligible
libudev1,232-25+deb9u13, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libudev1232-25+deb9u13 debCVE-2019-20386Negligible
udev,241-7~deb10u4, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",udev241-7~deb10u4 debCVE-2019-20386Negligible
libsystemd0,232-25+deb9u12, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libsystemd0232-25+deb9u12 debCVE-2019-20386Negligible
libudev1,232-25+deb9u12, ,deb,CVE-2019-20386,Negligible,2020-01-21T06:15:11.827,"'An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.'",libudev1232-25+deb9u12 debCVE-2019-20386Negligible
libtasn1-6,4.13-3, ,deb,CVE-2018-1000654,Negligible,2018-08-20T19:31:44.870,"'GNU Libtasn1-4.13 libtasn1-4.13 version libtasn1-4.13, libtasn1-4.12 contains a DoS, specifically CPU usage will reach 100% when running asn1Paser against the POC due to an issue in _asn1_expand_object_id(p_tree), after a long time, the program will be killed. This attack appears to be exploitable via parsing a crafted file.'",libtasn1-64.13-3 debCVE-2018-1000654Negligible
login,1:4.5-1.1,(won't fix),deb,CVE-2018-7169,Low,2018-02-15T20:29:00.867,"'An issue was discovered in shadow 4.5. newgidmap (in shadow-utils) is setuid and allows an unprivileged user to be placed in a user namespace where setgroups(2) is permitted. This allows an attacker to remove themselves from a supplementary group, which may allow access to certain filesystem paths if the administrator has used ""group blacklisting"" (e.g., chmod g-rwx) to restrict access to paths. This flaw effectively reverts a security feature in the kernel (in particular, the /proc/self/setgroups knob) to prevent this sort of privilege escalation.'",login1:4.5-1.1(won't fix)debCVE-2018-7169Low
passwd,1:4.5-1.1,(won't fix),deb,CVE-2018-7169,Low,2018-02-15T20:29:00.867,"'An issue was discovered in shadow 4.5. newgidmap (in shadow-utils) is setuid and allows an unprivileged user to be placed in a user namespace where setgroups(2) is permitted. This allows an attacker to remove themselves from a supplementary group, which may allow access to certain filesystem paths if the administrator has used ""group blacklisting"" (e.g., chmod g-rwx) to restrict access to paths. This flaw effectively reverts a security feature in the kernel (in particular, the /proc/self/setgroups knob) to prevent this sort of privilege escalation.'",passwd1:4.5-1.1(won't fix)debCVE-2018-7169Low
login,1:4.4-4.1+deb9u1,(won't fix),deb,CVE-2018-7169,Low,2018-02-15T20:29:00.867,"'An issue was discovered in shadow 4.5. newgidmap (in shadow-utils) is setuid and allows an unprivileged user to be placed in a user namespace where setgroups(2) is permitted. This allows an attacker to remove themselves from a supplementary group, which may allow access to certain filesystem paths if the administrator has used ""group blacklisting"" (e.g., chmod g-rwx) to restrict access to paths. This flaw effectively reverts a security feature in the kernel (in particular, the /proc/self/setgroups knob) to prevent this sort of privilege escalation.'",login1:4.4-4.1+deb9u1(won't fix)debCVE-2018-7169Low
passwd,1:4.4-4.1+deb9u1,(won't fix),deb,CVE-2018-7169,Low,2018-02-15T20:29:00.867,"'An issue was discovered in shadow 4.5. newgidmap (in shadow-utils) is setuid and allows an unprivileged user to be placed in a user namespace where setgroups(2) is permitted. This allows an attacker to remove themselves from a supplementary group, which may allow access to certain filesystem paths if the administrator has used ""group blacklisting"" (e.g., chmod g-rwx) to restrict access to paths. This flaw effectively reverts a security feature in the kernel (in particular, the /proc/self/setgroups knob) to prevent this sort of privilege escalation.'",passwd1:4.4-4.1+deb9u1(won't fix)debCVE-2018-7169Low
tar,1.30+dfsg-6, ,deb,CVE-2021-20193,Negligible,2021-03-26T17:15:12.843,'A flaw was found in the src/list.c of tar 1.33 and earlier. This flaw allows an attacker who can submit a crafted input file to tar to cause uncontrolled consumption of memory. The highest threat from this vulnerability is to system availability.',tar1.30+dfsg-6 debCVE-2021-20193Negligible
tar,1.29b-1.1+deb9u1, ,deb,CVE-2021-20193,Negligible,2021-03-26T17:15:12.843,'A flaw was found in the src/list.c of tar 1.33 and earlier. This flaw allows an attacker who can submit a crafted input file to tar to cause uncontrolled consumption of memory. The highest threat from this vulnerability is to system availability.',tar1.29b-1.1+deb9u1 debCVE-2021-20193Negligible
tar,1.29b-1.1, ,deb,CVE-2021-20193,Negligible,2021-03-26T17:15:12.843,'A flaw was found in the src/list.c of tar 1.33 and earlier. This flaw allows an attacker who can submit a crafted input file to tar to cause uncontrolled consumption of memory. The highest threat from this vulnerability is to system availability.',tar1.29b-1.1 debCVE-2021-20193Negligible
tar,1.30+dfsg-6, ,deb,CVE-2019-9923,Negligible,2019-03-22T08:29:00.247,'pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.',tar1.30+dfsg-6 debCVE-2019-9923Negligible
tar,1.29b-1.1+deb9u1, ,deb,CVE-2019-9923,Negligible,2019-03-22T08:29:00.247,'pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.',tar1.29b-1.1+deb9u1 debCVE-2019-9923Negligible
tar,1.29b-1.1, ,deb,CVE-2019-9923,Negligible,2019-03-22T08:29:00.247,'pax_decode_header in sparse.c in GNU Tar before 1.32 had a NULL pointer dereference when parsing certain archives that have malformed extended headers.',tar1.29b-1.1 debCVE-2019-9923Negligible
bash,5.1-2+b3,(won't fix),deb,CVE-2022-3715,High,2023-01-05T15:15:10.410,"'A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.'",bash5.1-2+b3(won't fix)debCVE-2022-3715High
libtinfo6,6.2+20201114-2,6.2+20201114-2+deb11u2,deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",libtinfo66.2+20201114-26.2+20201114-2+deb11u2debCVE-2023-29491High
ncurses-base,6.2+20201114-2,6.2+20201114-2+deb11u2,deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",ncurses-base6.2+20201114-26.2+20201114-2+deb11u2debCVE-2023-29491High
ncurses-bin,6.2+20201114-2,6.2+20201114-2+deb11u2,deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",ncurses-bin6.2+20201114-26.2+20201114-2+deb11u2debCVE-2023-29491High
libncursesw6,6.1+20181013-2+deb10u2,(won't fix),deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",libncursesw66.1+20181013-2+deb10u2(won't fix)debCVE-2023-29491High
libtinfo6,6.1+20181013-2+deb10u2,(won't fix),deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",libtinfo66.1+20181013-2+deb10u2(won't fix)debCVE-2023-29491High
ncurses-base,6.1+20181013-2+deb10u2,(won't fix),deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",ncurses-base6.1+20181013-2+deb10u2(won't fix)debCVE-2023-29491High
ncurses-bin,6.1+20181013-2+deb10u2,(won't fix),deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",ncurses-bin6.1+20181013-2+deb10u2(won't fix)debCVE-2023-29491High
libncurses6,6.1+20181013-2+deb10u2,(won't fix),deb,CVE-2023-29491,High,2023-04-14T01:15:08.570,"'ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.'",libncurses66.1+20181013-2+deb10u2(won't fix)debCVE-2023-29491High
libtinfo6,6.2+20201114-2,6.2+20201114-2+deb11u1,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libtinfo66.2+20201114-26.2+20201114-2+deb11u1debCVE-2022-29458High
ncurses-base,6.2+20201114-2,6.2+20201114-2+deb11u1,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-base6.2+20201114-26.2+20201114-2+deb11u1debCVE-2022-29458High
ncurses-bin,6.2+20201114-2,6.2+20201114-2+deb11u1,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-bin6.2+20201114-26.2+20201114-2+deb11u1debCVE-2022-29458High
libncursesw5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libncursesw56.0+20161126-1+deb9u2(won't fix)debCVE-2022-29458High
libtinfo5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libtinfo56.0+20161126-1+deb9u2(won't fix)debCVE-2022-29458High
ncurses-base,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-base6.0+20161126-1+deb9u2(won't fix)debCVE-2022-29458High
ncurses-bin,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-bin6.0+20161126-1+deb9u2(won't fix)debCVE-2022-29458High
libncursesw6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u3,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libncursesw66.1+20181013-2+deb10u26.1+20181013-2+deb10u3debCVE-2022-29458High
libtinfo6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u3,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libtinfo66.1+20181013-2+deb10u26.1+20181013-2+deb10u3debCVE-2022-29458High
ncurses-base,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u3,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-base6.1+20181013-2+deb10u26.1+20181013-2+deb10u3debCVE-2022-29458High
ncurses-bin,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u3,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',ncurses-bin6.1+20181013-2+deb10u26.1+20181013-2+deb10u3debCVE-2022-29458High
libncurses6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u3,deb,CVE-2022-29458,High,2022-04-18T21:15:07.600,'ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.',libncurses66.1+20181013-2+deb10u26.1+20181013-2+deb10u3debCVE-2022-29458High
libgcrypt20,1.8.4-5,1.8.4-5+deb10u1,deb,CVE-2021-40528,Medium,2021-09-06T19:15:07.587,"""The ElGamal implementation in Libgcrypt before 1.9.4 allows plaintext recovery because, during interaction between two cryptographic libraries, a certain dangerous combination of the prime defined by the receiver's public key, the generator defined by the receiver's public key, and the sender's ephemeral exponents can lead to a cross-configuration attack against OpenPGP.""",libgcrypt201.8.4-51.8.4-5+deb10u1debCVE-2021-40528Medium
libgcrypt20,1.7.6-2+deb9u3,1.7.6-2+deb9u4,deb,CVE-2021-40528,Medium,2021-09-06T19:15:07.587,"""The ElGamal implementation in Libgcrypt before 1.9.4 allows plaintext recovery because, during interaction between two cryptographic libraries, a certain dangerous combination of the prime defined by the receiver's public key, the generator defined by the receiver's public key, and the sender's ephemeral exponents can lead to a cross-configuration attack against OpenPGP.""",libgcrypt201.7.6-2+deb9u31.7.6-2+deb9u4debCVE-2021-40528Medium
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u7,deb,CVE-2021-20232,Critical,2021-03-12T19:15:13.130,'A flaw was found in gnutls. A use after free issue in client_send_params in lib/ext/pre_shared_key.c may lead to memory corruption and other potential consequences.',libgnutls303.6.7-4+deb10u63.6.7-4+deb10u7debCVE-2021-20232Critical
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u7,deb,CVE-2021-20232,Critical,2021-03-12T19:15:13.130,'A flaw was found in gnutls. A use after free issue in client_send_params in lib/ext/pre_shared_key.c may lead to memory corruption and other potential consequences.',libgnutls303.6.7-4+deb10u53.6.7-4+deb10u7debCVE-2021-20232Critical
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u7,deb,CVE-2021-20231,Critical,2021-03-12T19:15:13.037,'A flaw was found in gnutls. A use after free issue in client sending key_share extension may lead to memory corruption and other consequences.',libgnutls303.6.7-4+deb10u63.6.7-4+deb10u7debCVE-2021-20231Critical
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u7,deb,CVE-2021-20231,Critical,2021-03-12T19:15:13.037,'A flaw was found in gnutls. A use after free issue in client sending key_share extension may lead to memory corruption and other consequences.',libgnutls303.6.7-4+deb10u53.6.7-4+deb10u7debCVE-2021-20231Critical
libgnutls30,3.6.7-4+deb10u6,3.6.7-4+deb10u7,deb,CVE-2020-24659,High,2020-09-04T15:15:10.803,"""An issue was discovered in GnuTLS before 3.6.15. A server can trigger a NULL pointer dereference in a TLS 1.3 client if a no_renegotiation alert is sent with unexpected timing, and then an invalid second handshake occurs. The crash happens in the application's error handling path, where the gnutls_deinit function is called after detecting a handshake failure.""",libgnutls303.6.7-4+deb10u63.6.7-4+deb10u7debCVE-2020-24659High
libgnutls30,3.6.7-4+deb10u5,3.6.7-4+deb10u7,deb,CVE-2020-24659,High,2020-09-04T15:15:10.803,"""An issue was discovered in GnuTLS before 3.6.15. A server can trigger a NULL pointer dereference in a TLS 1.3 client if a no_renegotiation alert is sent with unexpected timing, and then an invalid second handshake occurs. The crash happens in the application's error handling path, where the gnutls_deinit function is called after detecting a handshake failure.""",libgnutls303.6.7-4+deb10u53.6.7-4+deb10u7debCVE-2020-24659High
libhogweed4,3.4.1-1,3.4.1-1+deb10u1,deb,CVE-2021-3580,High,2021-08-05T21:15:12.853,"""A flaw was found in the way nettle's RSA decryption functions handled specially crafted ciphertext. An attacker could use this flaw to provide a manipulated ciphertext leading to application crash and denial of service.""",libhogweed43.4.1-13.4.1-1+deb10u1debCVE-2021-3580High
libnettle6,3.4.1-1,3.4.1-1+deb10u1,deb,CVE-2021-3580,High,2021-08-05T21:15:12.853,"""A flaw was found in the way nettle's RSA decryption functions handled specially crafted ciphertext. An attacker could use this flaw to provide a manipulated ciphertext leading to application crash and denial of service.""",libnettle63.4.1-13.4.1-1+deb10u1debCVE-2021-3580High
libhogweed4,3.4.1-1,3.4.1-1+deb10u1,deb,CVE-2021-20305,High,2021-04-05T22:15:12.727,"'A flaw was found in Nettle in versions before 3.7.2, where several Nettle signature verification functions (GOST DSA, EDDSA & ECDSA) result in the Elliptic Curve Cryptography point (ECC) multiply function being called with out-of-range scalers, possibly resulting in incorrect results. This flaw allows an attacker to force an invalid signature, causing an assertion failure or possible validation. The highest threat to this vulnerability is to confidentiality, integrity, as well as system availability.'",libhogweed43.4.1-13.4.1-1+deb10u1debCVE-2021-20305High
libnettle6,3.4.1-1,3.4.1-1+deb10u1,deb,CVE-2021-20305,High,2021-04-05T22:15:12.727,"'A flaw was found in Nettle in versions before 3.7.2, where several Nettle signature verification functions (GOST DSA, EDDSA & ECDSA) result in the Elliptic Curve Cryptography point (ECC) multiply function being called with out-of-range scalers, possibly resulting in incorrect results. This flaw allows an attacker to force an invalid signature, causing an assertion failure or possible validation. The highest threat to this vulnerability is to confidentiality, integrity, as well as system availability.'",libnettle63.4.1-13.4.1-1+deb10u1debCVE-2021-20305High
apt,1.8.2.1,1.8.2.2,deb,CVE-2020-27350,Medium,2020-12-10T04:15:11.423,"'APT had several integer overflows and underflows while parsing .deb packages, aka GHSL-2020-168 GHSL-2020-169, in files apt-pkg/contrib/extracttar.cc, apt-pkg/deb/debfile.cc, and apt-pkg/contrib/arfile.cc. This issue affects: apt 1.2.32ubuntu0 versions prior to 1.2.32ubuntu0.2; 1.6.12ubuntu0 versions prior to 1.6.12ubuntu0.2; 2.0.2ubuntu0 versions prior to 2.0.2ubuntu0.2; 2.1.10ubuntu0 versions prior to 2.1.10ubuntu0.1;'",apt1.8.2.11.8.2.2debCVE-2020-27350Medium
libapt-pkg5.0,1.8.2.1,1.8.2.2,deb,CVE-2020-27350,Medium,2020-12-10T04:15:11.423,"'APT had several integer overflows and underflows while parsing .deb packages, aka GHSL-2020-168 GHSL-2020-169, in files apt-pkg/contrib/extracttar.cc, apt-pkg/deb/debfile.cc, and apt-pkg/contrib/arfile.cc. This issue affects: apt 1.2.32ubuntu0 versions prior to 1.2.32ubuntu0.2; 1.6.12ubuntu0 versions prior to 1.6.12ubuntu0.2; 2.0.2ubuntu0 versions prior to 2.0.2ubuntu0.2; 2.1.10ubuntu0 versions prior to 2.1.10ubuntu0.1;'",libapt-pkg5.01.8.2.11.8.2.2debCVE-2020-27350Medium
liblz4-1,1.8.3-1,1.8.3-1+deb10u1,deb,CVE-2021-3520,Critical,2021-06-02T13:15:13.170,"""There's a flaw in lz4. An attacker who submits a crafted file to an application linked with lz4 may be able to trigger an integer overflow, leading to calling of memmove() on a negative size argument, causing an out-of-bounds write and/or a crash. The greatest impact of this flaw is to availability, with some potential impact to confidentiality and integrity as well.""",liblz4-11.8.3-11.8.3-1+deb10u1debCVE-2021-3520Critical
liblz4-1,0.0~r131-2+b1,0.0~r131-2+deb9u1,deb,CVE-2021-3520,Critical,2021-06-02T13:15:13.170,"""There's a flaw in lz4. An attacker who submits a crafted file to an application linked with lz4 may be able to trigger an integer overflow, leading to calling of memmove() on a negative size argument, causing an out-of-bounds write and/or a crash. The greatest impact of this flaw is to availability, with some potential impact to confidentiality and integrity as well.""",liblz4-10.0~r131-2+b10.0~r131-2+deb9u1debCVE-2021-3520Critical
libp11-kit0,0.23.15-2,0.23.15-2+deb10u1,deb,CVE-2020-29363,High,2020-12-16T14:15:12.840,"'An issue was discovered in p11-kit 0.23.6 through 0.23.21. A heap-based buffer overflow has been discovered in the RPC protocol used by p11-kit server/remote commands and the client library. When the remote entity supplies a serialized byte array in a CK_ATTRIBUTE, the receiving entity may not allocate sufficient length for the buffer to store the deserialized value.'",libp11-kit00.23.15-20.23.15-2+deb10u1debCVE-2020-29363High
libp11-kit0,0.23.15-2,0.23.15-2+deb10u1,deb,CVE-2020-29361,High,2020-12-16T14:15:12.717,"'An issue was discovered in p11-kit 0.21.1 through 0.23.21. Multiple integer overflows have been discovered in the array allocations in the p11-kit library and the p11-kit list command, where overflow checks are missing before calling realloc or calloc.'",libp11-kit00.23.15-20.23.15-2+deb10u1debCVE-2020-29361High
libp11-kit0,0.23.15-2,0.23.15-2+deb10u1,deb,CVE-2020-29362,Medium,2020-12-16T14:15:12.777,"'An issue was discovered in p11-kit 0.21.1 through 0.23.21. A heap-based buffer over-read has been discovered in the RPC protocol used by thep11-kit server/remote commands and the client library. When the remote entity supplies a byte array through a serialized PKCS#11 function call, the receiving entity may allow the reading of up to 4 bytes of memory past the heap allocation.'",libp11-kit00.23.15-20.23.15-2+deb10u1debCVE-2020-29362Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2021-23840,High,2021-02-16T17:15:13.300,"'Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2021-23840High
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2021-23840,High,2021-02-16T17:15:13.300,"'Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2021-23840High
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u6,deb,CVE-2021-3449,Medium,2021-03-25T15:15:13.450,"'An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). OpenSSL TLS clients are not impacted by this issue. All OpenSSL 1.1.1 versions are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1-1.1.1j).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u6debCVE-2021-3449Medium
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u6,deb,CVE-2021-3449,Medium,2021-03-25T15:15:13.450,"'An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). OpenSSL TLS clients are not impacted by this issue. All OpenSSL 1.1.1 versions are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1-1.1.1j).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u6debCVE-2021-3449Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2021-23841,Medium,2021-02-16T17:15:13.377,'The OpenSSL public API function X509_issuer_and_serial_hash() attempts to create a unique hash value based on the issuer and serial number data contained within an X509 certificate. However it fails to correctly handle any errors that may occur while parsing the issuer field (which might occur if the issuer field is maliciously constructed). This may subsequently result in a NULL pointer deref and a crash leading to a potential denial of service attack. The function X509_issuer_and_serial_hash() is never directly called by OpenSSL itself so applications are only vulnerable if they use this function directly and they use it on certificates that may have been obtained from untrusted sources. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).',libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2021-23841Medium
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2021-23841,Medium,2021-02-16T17:15:13.377,'The OpenSSL public API function X509_issuer_and_serial_hash() attempts to create a unique hash value based on the issuer and serial number data contained within an X509 certificate. However it fails to correctly handle any errors that may occur while parsing the issuer field (which might occur if the issuer field is maliciously constructed). This may subsequently result in a NULL pointer deref and a crash leading to a potential denial of service attack. The function X509_issuer_and_serial_hash() is never directly called by OpenSSL itself so applications are only vulnerable if they use this function directly and they use it on certificates that may have been obtained from untrusted sources. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).',openssl1.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2021-23841Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u4,deb,CVE-2020-1971,Medium,2020-12-08T16:15:11.730,"'The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL\'s s_server, s_client and verify tools have support for the ""-crl_download"" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL\'s parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u4debCVE-2020-1971Medium
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u4,deb,CVE-2020-1971,Medium,2020-12-08T16:15:11.730,"'The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL\'s s_server, s_client and verify tools have support for the ""-crl_download"" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL\'s parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u4debCVE-2020-1971Medium
libssl1.1,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2019-1551,Medium,2019-12-06T18:15:12.840,"'There is an overflow bug in the x64_64 Montgomery squaring procedure used in exponentiation with 512-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against 2-prime RSA1024, 3-prime RSA1536, and DSA1024 as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH512 are considered just feasible. However, for an attack the target would have to re-use the DH512 private key, which is not recommended anyway. Also applications directly using the low level API BN_mod_exp may be affected if they use BN_FLG_CONSTTIME. Fixed in OpenSSL 1.1.1e (Affected 1.1.1-1.1.1d). Fixed in OpenSSL 1.0.2u (Affected 1.0.2-1.0.2t).'",libssl1.11.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2019-1551Medium
openssl,1.1.1d-0+deb10u3,1.1.1d-0+deb10u5,deb,CVE-2019-1551,Medium,2019-12-06T18:15:12.840,"'There is an overflow bug in the x64_64 Montgomery squaring procedure used in exponentiation with 512-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against 2-prime RSA1024, 3-prime RSA1536, and DSA1024 as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH512 are considered just feasible. However, for an attack the target would have to re-use the DH512 private key, which is not recommended anyway. Also applications directly using the low level API BN_mod_exp may be affected if they use BN_FLG_CONSTTIME. Fixed in OpenSSL 1.1.1e (Affected 1.1.1-1.1.1d). Fixed in OpenSSL 1.0.2u (Affected 1.0.2-1.0.2t).'",openssl1.1.1d-0+deb10u31.1.1d-0+deb10u5debCVE-2019-1551Medium
libzstd1,1.3.8+dfsg-3,1.3.8+dfsg-3+deb10u2,deb,CVE-2021-24032,Medium,2021-03-04T21:15:12.963,"'Beginning in v1.4.1 and prior to v1.4.9, due to an incomplete fix for CVE-2021-24031, the Zstandard command-line utility created output files with default permissions and restricted those permissions immediately afterwards. Output files could therefore momentarily be readable or writable to unintended parties.'",libzstd11.3.8+dfsg-31.3.8+dfsg-3+deb10u2debCVE-2021-24032Medium
libzstd1,1.3.8+dfsg-3,1.3.8+dfsg-3+deb10u1,deb,CVE-2021-24031,Medium,2021-03-04T21:15:12.743,"'In the Zstandard command-line utility prior to v1.4.1, output files were created with default permissions. Correct file permissions (matching the input) would only be set at completion time. Output files could therefore be readable or writable to unintended parties.'",libzstd11.3.8+dfsg-31.3.8+dfsg-3+deb10u1debCVE-2021-24031Medium
bash,4.4-5, ,deb,CVE-2019-18276,Negligible,2019-11-28T01:15:10.603,"'An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support ""saved UID"" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use ""enable -f"" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.'",bash4.4-5 debCVE-2019-18276Negligible
bash,5.0-4, ,deb,CVE-2019-18276,Negligible,2019-11-28T01:15:10.603,"'An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support ""saved UID"" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use ""enable -f"" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.'",bash5.0-4 debCVE-2019-18276Negligible
bsdutils,1:2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",bsdutils1:2.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
libblkid1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",libblkid12.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
libfdisk1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",libfdisk12.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
libmount1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",libmount12.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
libsmartcols1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",libsmartcols12.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
libuuid1,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",libuuid12.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
mount,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",mount2.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
util-linux,2.29.2-1+deb9u1,(won't fix),deb,CVE-2016-2779,High,2017-02-07T15:59:00.287,"""runuser in util-linux allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.""",util-linux2.29.2-1+deb9u1(won't fix)debCVE-2016-2779High
gpgv,2.1.18-8~deb9u4,(won't fix),deb,CVE-2018-1000858,High,2018-12-20T17:29:00.457,"'GnuPG version 2.1.12 - 2.2.11 contains a Cross ite Request Forgery (CSRF) vulnerability in dirmngr that can result in Attacker controlled CSRF, Information Disclosure, DoS. This attack appear to be exploitable via Victim must perform a WKD request, e.g. enter an email address in the composer window of Thunderbird/Enigmail. This vulnerability appears to have been fixed in after commit 4a4bb874f63741026bd26264c43bb32b1099f060.'",gpgv2.1.18-8~deb9u4(won't fix)debCVE-2018-1000858High
gpgv,2.1.18-8~deb9u4,(won't fix),deb,CVE-2018-9234,Low,2018-04-04T00:29:00.227,"'GnuPG 2.2.4 and 2.2.5 does not enforce a configuration in which key certification requires an offline master Certify key, which results in apparently valid certifications that occurred only with access to a signing subkey.'",gpgv2.1.18-8~deb9u4(won't fix)debCVE-2018-9234Low
libbz2-1.0,1.0.6-8.1,(won't fix),deb,CVE-2019-12900,Critical,2019-06-19T23:15:09.910,'BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.',libbz2-1.01.0.6-8.1(won't fix)debCVE-2019-12900Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2019-9169,Critical,2019-02-26T02:29:00.497,"'In the GNU C Library (aka glibc or libc6) through 2.29, proceed_next_node in posix/regexec.c has a heap-based buffer over-read via an attempted case-insensitive regular-expression match.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2019-9169Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2019-9169,Critical,2019-02-26T02:29:00.497,"'In the GNU C Library (aka glibc or libc6) through 2.29, proceed_next_node in posix/regexec.c has a heap-based buffer over-read via an attempted case-insensitive regular-expression match.'",libc62.24-11+deb9u4(won't fix)debCVE-2019-9169Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2019-9169,Critical,2019-02-26T02:29:00.497,"'In the GNU C Library (aka glibc or libc6) through 2.29, proceed_next_node in posix/regexec.c has a heap-based buffer over-read via an attempted case-insensitive regular-expression match.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2019-9169Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6551,Critical,2018-02-02T14:29:01.590,"'The malloc implementation in the GNU C Library (aka glibc or libc6), from version 2.24 to 2.26 on powerpc, and only in version 2.26 on i386, did not properly handle malloc calls with arguments close to SIZE_MAX and could return a pointer to a heap region that is smaller than requested, eventually leading to heap corruption.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2018-6551Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6551,Critical,2018-02-02T14:29:01.590,"'The malloc implementation in the GNU C Library (aka glibc or libc6), from version 2.24 to 2.26 on powerpc, and only in version 2.26 on i386, did not properly handle malloc calls with arguments close to SIZE_MAX and could return a pointer to a heap region that is smaller than requested, eventually leading to heap corruption.'",libc62.24-11+deb9u4(won't fix)debCVE-2018-6551Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6551,Critical,2018-02-02T14:29:01.590,"'The malloc implementation in the GNU C Library (aka glibc or libc6), from version 2.24 to 2.26 on powerpc, and only in version 2.26 on i386, did not properly handle malloc calls with arguments close to SIZE_MAX and could return a pointer to a heap region that is smaller than requested, eventually leading to heap corruption.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2018-6551Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6485,Critical,2018-02-01T14:29:00.623,"'An integer overflow in the implementation of the posix_memalign in memalign functions in the GNU C Library (aka glibc or libc6) 2.26 and earlier could cause these functions to return a pointer to a heap area that is too small, potentially leading to heap corruption.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2018-6485Critical
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6485,Critical,2018-02-01T14:29:00.623,"'An integer overflow in the implementation of the posix_memalign in memalign functions in the GNU C Library (aka glibc or libc6) 2.26 and earlier could cause these functions to return a pointer to a heap area that is too small, potentially leading to heap corruption.'",libc62.24-11+deb9u4(won't fix)debCVE-2018-6485Critical
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2018-6485,Critical,2018-02-01T14:29:00.623,"'An integer overflow in the implementation of the posix_memalign in memalign functions in the GNU C Library (aka glibc or libc6) 2.26 and earlier could cause these functions to return a pointer to a heap area that is too small, potentially leading to heap corruption.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2018-6485Critical
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2018-1000001,High,2018-01-31T14:29:00.607,'In glibc 2.26 and earlier there is confusion in the usage of getcwd() by realpath() which can be used to write before the destination buffer leading to a buffer underflow and potential code execution.',libc-bin2.24-11+deb9u4(won't fix)debCVE-2018-1000001High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2018-1000001,High,2018-01-31T14:29:00.607,'In glibc 2.26 and earlier there is confusion in the usage of getcwd() by realpath() which can be used to write before the destination buffer leading to a buffer underflow and potential code execution.',libc62.24-11+deb9u4(won't fix)debCVE-2018-1000001High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2018-1000001,High,2018-01-31T14:29:00.607,'In glibc 2.26 and earlier there is confusion in the usage of getcwd() by realpath() which can be used to write before the destination buffer leading to a buffer underflow and potential code execution.',multiarch-support2.24-11+deb9u4(won't fix)debCVE-2018-1000001High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2009-5155,High,2019-02-26T02:29:00.277,"'In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2009-5155High
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2009-5155,High,2019-02-26T02:29:00.277,"'In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.'",libc62.24-11+deb9u4(won't fix)debCVE-2009-5155High
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2009-5155,High,2019-02-26T02:29:00.277,"'In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2009-5155High
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2017-12132,Medium,2017-08-01T16:29:00.180,"'The DNS stub resolver in the GNU C Library (aka glibc or libc6) before version 2.26, when EDNS support is enabled, will solicit large UDP responses from name servers, potentially simplifying off-path DNS spoofing attacks due to IP fragmentation.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2017-12132Medium
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2017-12132,Medium,2017-08-01T16:29:00.180,"'The DNS stub resolver in the GNU C Library (aka glibc or libc6) before version 2.26, when EDNS support is enabled, will solicit large UDP responses from name servers, potentially simplifying off-path DNS spoofing attacks due to IP fragmentation.'",libc62.24-11+deb9u4(won't fix)debCVE-2017-12132Medium
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2017-12132,Medium,2017-08-01T16:29:00.180,"'The DNS stub resolver in the GNU C Library (aka glibc or libc6) before version 2.26, when EDNS support is enabled, will solicit large UDP responses from name servers, potentially simplifying off-path DNS spoofing attacks due to IP fragmentation.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2017-12132Medium
libc-bin,2.24-11+deb9u4,(won't fix),deb,CVE-2016-10739,Medium,2019-01-21T19:29:00.247,"'In the GNU C Library (aka glibc or libc6) through 2.28, the getaddrinfo function would successfully parse a string that contained an IPv4 address followed by whitespace and arbitrary characters, which could lead applications to incorrectly assume that it had parsed a valid string, without the possibility of embedded HTTP headers or other potentially dangerous substrings.'",libc-bin2.24-11+deb9u4(won't fix)debCVE-2016-10739Medium
libc6,2.24-11+deb9u4,(won't fix),deb,CVE-2016-10739,Medium,2019-01-21T19:29:00.247,"'In the GNU C Library (aka glibc or libc6) through 2.28, the getaddrinfo function would successfully parse a string that contained an IPv4 address followed by whitespace and arbitrary characters, which could lead applications to incorrectly assume that it had parsed a valid string, without the possibility of embedded HTTP headers or other potentially dangerous substrings.'",libc62.24-11+deb9u4(won't fix)debCVE-2016-10739Medium
multiarch-support,2.24-11+deb9u4,(won't fix),deb,CVE-2016-10739,Medium,2019-01-21T19:29:00.247,"'In the GNU C Library (aka glibc or libc6) through 2.28, the getaddrinfo function would successfully parse a string that contained an IPv4 address followed by whitespace and arbitrary characters, which could lead applications to incorrectly assume that it had parsed a valid string, without the possibility of embedded HTTP headers or other potentially dangerous substrings.'",multiarch-support2.24-11+deb9u4(won't fix)debCVE-2016-10739Medium
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-7309,Negligible,2019-02-03T02:29:00.237,"'In the GNU C Library (aka glibc or libc6) through 2.29, the memcmp function for the x32 architecture can incorrectly return zero (indicating that the inputs are equal) because the RDX most significant bit is mishandled.'",libc-bin2.24-11+deb9u4 debCVE-2019-7309Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-7309,Negligible,2019-02-03T02:29:00.237,"'In the GNU C Library (aka glibc or libc6) through 2.29, the memcmp function for the x32 architecture can incorrectly return zero (indicating that the inputs are equal) because the RDX most significant bit is mishandled.'",libc62.24-11+deb9u4 debCVE-2019-7309Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-7309,Negligible,2019-02-03T02:29:00.237,"'In the GNU C Library (aka glibc or libc6) through 2.29, the memcmp function for the x32 architecture can incorrectly return zero (indicating that the inputs are equal) because the RDX most significant bit is mishandled.'",multiarch-support2.24-11+deb9u4 debCVE-2019-7309Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2019-6488,Negligible,2019-01-18T19:29:00.200,"'The string component in the GNU C Library (aka glibc or libc6) through 2.28, when running on the x32 architecture, incorrectly attempts to use a 64-bit register for size_t in assembly codes, which can lead to a segmentation fault or possibly unspecified other impact, as demonstrated by a crash in __memmove_avx_unaligned_erms in sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S during a memcpy.'",libc-bin2.24-11+deb9u4 debCVE-2019-6488Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2019-6488,Negligible,2019-01-18T19:29:00.200,"'The string component in the GNU C Library (aka glibc or libc6) through 2.28, when running on the x32 architecture, incorrectly attempts to use a 64-bit register for size_t in assembly codes, which can lead to a segmentation fault or possibly unspecified other impact, as demonstrated by a crash in __memmove_avx_unaligned_erms in sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S during a memcpy.'",libc62.24-11+deb9u4 debCVE-2019-6488Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2019-6488,Negligible,2019-01-18T19:29:00.200,"'The string component in the GNU C Library (aka glibc or libc6) through 2.28, when running on the x32 architecture, incorrectly attempts to use a 64-bit register for size_t in assembly codes, which can lead to a segmentation fault or possibly unspecified other impact, as demonstrated by a crash in __memmove_avx_unaligned_erms in sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S during a memcpy.'",multiarch-support2.24-11+deb9u4 debCVE-2019-6488Negligible
libc-bin,2.24-11+deb9u4, ,deb,CVE-2015-8985,Negligible,2017-03-20T16:59:01.563,'The pop_fail_stack function in the GNU C Library (aka glibc or libc6) allows context-dependent attackers to cause a denial of service (assertion failure and application crash) via vectors related to extended regular expression processing.',libc-bin2.24-11+deb9u4 debCVE-2015-8985Negligible
libc6,2.24-11+deb9u4, ,deb,CVE-2015-8985,Negligible,2017-03-20T16:59:01.563,'The pop_fail_stack function in the GNU C Library (aka glibc or libc6) allows context-dependent attackers to cause a denial of service (assertion failure and application crash) via vectors related to extended regular expression processing.',libc62.24-11+deb9u4 debCVE-2015-8985Negligible
multiarch-support,2.24-11+deb9u4, ,deb,CVE-2015-8985,Negligible,2017-03-20T16:59:01.563,'The pop_fail_stack function in the GNU C Library (aka glibc or libc6) allows context-dependent attackers to cause a denial of service (assertion failure and application crash) via vectors related to extended regular expression processing.',multiarch-support2.24-11+deb9u4 debCVE-2015-8985Negligible
libncursesw5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17595,Low,2019-10-14T21:15:11.427,'There is a heap-based buffer over-read in the fmt_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',libncursesw56.0+20161126-1+deb9u2(won't fix)debCVE-2019-17595Low
libtinfo5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17595,Low,2019-10-14T21:15:11.427,'There is a heap-based buffer over-read in the fmt_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',libtinfo56.0+20161126-1+deb9u2(won't fix)debCVE-2019-17595Low
ncurses-base,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17595,Low,2019-10-14T21:15:11.427,'There is a heap-based buffer over-read in the fmt_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',ncurses-base6.0+20161126-1+deb9u2(won't fix)debCVE-2019-17595Low
ncurses-bin,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17595,Low,2019-10-14T21:15:11.427,'There is a heap-based buffer over-read in the fmt_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',ncurses-bin6.0+20161126-1+deb9u2(won't fix)debCVE-2019-17595Low
libncursesw5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17594,Low,2019-10-14T21:15:11.347,'There is a heap-based buffer over-read in the _nc_find_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',libncursesw56.0+20161126-1+deb9u2(won't fix)debCVE-2019-17594Low
libtinfo5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17594,Low,2019-10-14T21:15:11.347,'There is a heap-based buffer over-read in the _nc_find_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',libtinfo56.0+20161126-1+deb9u2(won't fix)debCVE-2019-17594Low
ncurses-base,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17594,Low,2019-10-14T21:15:11.347,'There is a heap-based buffer over-read in the _nc_find_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',ncurses-base6.0+20161126-1+deb9u2(won't fix)debCVE-2019-17594Low
ncurses-bin,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2019-17594,Low,2019-10-14T21:15:11.347,'There is a heap-based buffer over-read in the _nc_find_entry function in tinfo/comp_hash.c in the terminfo library in ncurses before 6.1-20191012.',ncurses-bin6.0+20161126-1+deb9u2(won't fix)debCVE-2019-17594Low
libncursesw5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2018-19211,Low,2018-11-12T19:29:00.347,"'In ncurses 6.1, there is a NULL pointer dereference at function _nc_parse_entry in parse_entry.c that will lead to a denial of service attack. The product proceeds to the dereference code path even after a ""dubious character `*\' in name or alias field"" detection.'",libncursesw56.0+20161126-1+deb9u2(won't fix)debCVE-2018-19211Low
libtinfo5,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2018-19211,Low,2018-11-12T19:29:00.347,"'In ncurses 6.1, there is a NULL pointer dereference at function _nc_parse_entry in parse_entry.c that will lead to a denial of service attack. The product proceeds to the dereference code path even after a ""dubious character `*\' in name or alias field"" detection.'",libtinfo56.0+20161126-1+deb9u2(won't fix)debCVE-2018-19211Low
ncurses-base,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2018-19211,Low,2018-11-12T19:29:00.347,"'In ncurses 6.1, there is a NULL pointer dereference at function _nc_parse_entry in parse_entry.c that will lead to a denial of service attack. The product proceeds to the dereference code path even after a ""dubious character `*\' in name or alias field"" detection.'",ncurses-base6.0+20161126-1+deb9u2(won't fix)debCVE-2018-19211Low
ncurses-bin,6.0+20161126-1+deb9u2,(won't fix),deb,CVE-2018-19211,Low,2018-11-12T19:29:00.347,"'In ncurses 6.1, there is a NULL pointer dereference at function _nc_parse_entry in parse_entry.c that will lead to a denial of service attack. The product proceeds to the dereference code path even after a ""dubious character `*\' in name or alias field"" detection.'",ncurses-bin6.0+20161126-1+deb9u2(won't fix)debCVE-2018-19211Low
libncursesw5,6.0+20161126-1+deb9u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',libncursesw56.0+20161126-1+deb9u2 debCVE-2021-39537Negligible
libtinfo5,6.0+20161126-1+deb9u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',libtinfo56.0+20161126-1+deb9u2 debCVE-2021-39537Negligible
ncurses-base,6.0+20161126-1+deb9u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',ncurses-base6.0+20161126-1+deb9u2 debCVE-2021-39537Negligible
ncurses-bin,6.0+20161126-1+deb9u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',ncurses-bin6.0+20161126-1+deb9u2 debCVE-2021-39537Negligible
libncursesw6,6.1+20181013-2+deb10u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',libncursesw66.1+20181013-2+deb10u2 debCVE-2021-39537Negligible
libtinfo6,6.1+20181013-2+deb10u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',libtinfo66.1+20181013-2+deb10u2 debCVE-2021-39537Negligible
ncurses-base,6.1+20181013-2+deb10u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',ncurses-base6.1+20181013-2+deb10u2 debCVE-2021-39537Negligible
ncurses-bin,6.1+20181013-2+deb10u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',ncurses-bin6.1+20181013-2+deb10u2 debCVE-2021-39537Negligible
libncurses6,6.1+20181013-2+deb10u2, ,deb,CVE-2021-39537,Negligible,2021-09-20T16:15:12.477,'An issue was discovered in ncurses through v6.2-1. _nc_captoinfo in captoinfo.c has a heap-based buffer overflow.',libncurses66.1+20181013-2+deb10u2 debCVE-2021-39537Negligible
libsystemd0,232-25+deb9u13,232-25+deb9u14,deb,CVE-2020-1712,High,2020-03-31T17:15:26.577,"'A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.'",libsystemd0232-25+deb9u13232-25+deb9u14debCVE-2020-1712High
libudev1,232-25+deb9u13,232-25+deb9u14,deb,CVE-2020-1712,High,2020-03-31T17:15:26.577,"'A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.'",libudev1232-25+deb9u13232-25+deb9u14debCVE-2020-1712High
libsystemd0,232-25+deb9u12,232-25+deb9u14,deb,CVE-2020-1712,High,2020-03-31T17:15:26.577,"'A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.'",libsystemd0232-25+deb9u12232-25+deb9u14debCVE-2020-1712High
libudev1,232-25+deb9u12,232-25+deb9u14,deb,CVE-2020-1712,High,2020-03-31T17:15:26.577,"'A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.'",libudev1232-25+deb9u12232-25+deb9u14debCVE-2020-1712High
libsystemd0,232-25+deb9u13,(won't fix),deb,CVE-2018-6954,Low,2018-02-13T20:29:00.547,"'systemd-tmpfiles in systemd through 237 mishandles symlinks present in non-terminal path components, which allows local users to obtain ownership of arbitrary files via vectors involving creation of a directory and a file under that directory, and later replacing that directory with a symlink. This occurs even if the fs.protected_symlinks sysctl is turned on.'",libsystemd0232-25+deb9u13(won't fix)debCVE-2018-6954Low
libudev1,232-25+deb9u13,(won't fix),deb,CVE-2018-6954,Low,2018-02-13T20:29:00.547,"'systemd-tmpfiles in systemd through 237 mishandles symlinks present in non-terminal path components, which allows local users to obtain ownership of arbitrary files via vectors involving creation of a directory and a file under that directory, and later replacing that directory with a symlink. This occurs even if the fs.protected_symlinks sysctl is turned on.'",libudev1232-25+deb9u13(won't fix)debCVE-2018-6954Low
libsystemd0,232-25+deb9u12,(won't fix),deb,CVE-2018-6954,Low,2018-02-13T20:29:00.547,"'systemd-tmpfiles in systemd through 237 mishandles symlinks present in non-terminal path components, which allows local users to obtain ownership of arbitrary files via vectors involving creation of a directory and a file under that directory, and later replacing that directory with a symlink. This occurs even if the fs.protected_symlinks sysctl is turned on.'",libsystemd0232-25+deb9u12(won't fix)debCVE-2018-6954Low
libudev1,232-25+deb9u12,(won't fix),deb,CVE-2018-6954,Low,2018-02-13T20:29:00.547,"'systemd-tmpfiles in systemd through 237 mishandles symlinks present in non-terminal path components, which allows local users to obtain ownership of arbitrary files via vectors involving creation of a directory and a file under that directory, and later replacing that directory with a symlink. This occurs even if the fs.protected_symlinks sysctl is turned on.'",libudev1232-25+deb9u12(won't fix)debCVE-2018-6954Low
libsystemd0,232-25+deb9u13,(won't fix),deb,CVE-2018-16888,Low,2019-01-14T22:29:00.233,"'It was discovered systemd does not correctly check the content of PIDFile files before using it to kill processes. When a service is run from an unprivileged user (e.g. User field set in the service file), a local attacker who is able to write to the PIDFile of the mentioned service may use this flaw to trick systemd into killing other services and/or privileged processes. Versions before v237 are vulnerable.'",libsystemd0232-25+deb9u13(won't fix)debCVE-2018-16888Low
libudev1,232-25+deb9u13,(won't fix),deb,CVE-2018-16888,Low,2019-01-14T22:29:00.233,"'It was discovered systemd does not correctly check the content of PIDFile files before using it to kill processes. When a service is run from an unprivileged user (e.g. User field set in the service file), a local attacker who is able to write to the PIDFile of the mentioned service may use this flaw to trick systemd into killing other services and/or privileged processes. Versions before v237 are vulnerable.'",libudev1232-25+deb9u13(won't fix)debCVE-2018-16888Low
libsystemd0,232-25+deb9u12,(won't fix),deb,CVE-2018-16888,Low,2019-01-14T22:29:00.233,"'It was discovered systemd does not correctly check the content of PIDFile files before using it to kill processes. When a service is run from an unprivileged user (e.g. User field set in the service file), a local attacker who is able to write to the PIDFile of the mentioned service may use this flaw to trick systemd into killing other services and/or privileged processes. Versions before v237 are vulnerable.'",libsystemd0232-25+deb9u12(won't fix)debCVE-2018-16888Low
libudev1,232-25+deb9u12,(won't fix),deb,CVE-2018-16888,Low,2019-01-14T22:29:00.233,"'It was discovered systemd does not correctly check the content of PIDFile files before using it to kill processes. When a service is run from an unprivileged user (e.g. User field set in the service file), a local attacker who is able to write to the PIDFile of the mentioned service may use this flaw to trick systemd into killing other services and/or privileged processes. Versions before v237 are vulnerable.'",libudev1232-25+deb9u12(won't fix)debCVE-2018-16888Low
libsystemd0,232-25+deb9u13, ,deb,CVE-2020-13776,Negligible,2020-06-03T03:15:10.677,"'systemd through v245 mishandles numerical usernames such as ones composed of decimal digits or 0x followed by hex digits, as demonstrated by use of root privileges when privileges of the 0x0 user account were intended. NOTE: this issue exists because of an incomplete fix for CVE-2017-1000082.'",libsystemd0232-25+deb9u13 debCVE-2020-13776Negligible
libudev1,232-25+deb9u13, ,deb,CVE-2020-13776,Negligible,2020-06-03T03:15:10.677,"'systemd through v245 mishandles numerical usernames such as ones composed of decimal digits or 0x followed by hex digits, as demonstrated by use of root privileges when privileges of the 0x0 user account were intended. NOTE: this issue exists because of an incomplete fix for CVE-2017-1000082.'",libudev1232-25+deb9u13 debCVE-2020-13776Negligible
libsystemd0,232-25+deb9u12, ,deb,CVE-2020-13776,Negligible,2020-06-03T03:15:10.677,"'systemd through v245 mishandles numerical usernames such as ones composed of decimal digits or 0x followed by hex digits, as demonstrated by use of root privileges when privileges of the 0x0 user account were intended. NOTE: this issue exists because of an incomplete fix for CVE-2017-1000082.'",libsystemd0232-25+deb9u12 debCVE-2020-13776Negligible
libudev1,232-25+deb9u12, ,deb,CVE-2020-13776,Negligible,2020-06-03T03:15:10.677,"'systemd through v245 mishandles numerical usernames such as ones composed of decimal digits or 0x followed by hex digits, as demonstrated by use of root privileges when privileges of the 0x0 user account were intended. NOTE: this issue exists because of an incomplete fix for CVE-2017-1000082.'",libudev1232-25+deb9u12 debCVE-2020-13776Negligible
libsystemd0,232-25+deb9u13, ,deb,CVE-2017-1000082,Negligible,2017-07-07T17:29:00.277,"'systemd v233 and earlier fails to safely parse usernames starting with a numeric digit (e.g. ""0day""), running the service in question with root privileges rather than the user intended.'",libsystemd0232-25+deb9u13 debCVE-2017-1000082Negligible
libudev1,232-25+deb9u13, ,deb,CVE-2017-1000082,Negligible,2017-07-07T17:29:00.277,"'systemd v233 and earlier fails to safely parse usernames starting with a numeric digit (e.g. ""0day""), running the service in question with root privileges rather than the user intended.'",libudev1232-25+deb9u13 debCVE-2017-1000082Negligible
libsystemd0,232-25+deb9u12, ,deb,CVE-2017-1000082,Negligible,2017-07-07T17:29:00.277,"'systemd v233 and earlier fails to safely parse usernames starting with a numeric digit (e.g. ""0day""), running the service in question with root privileges rather than the user intended.'",libsystemd0232-25+deb9u12 debCVE-2017-1000082Negligible
libudev1,232-25+deb9u12, ,deb,CVE-2017-1000082,Negligible,2017-07-07T17:29:00.277,"'systemd v233 and earlier fails to safely parse usernames starting with a numeric digit (e.g. ""0day""), running the service in question with root privileges rather than the user intended.'",libudev1232-25+deb9u12 debCVE-2017-1000082Negligible
tar,1.29b-1.1,1.29b-1.1+deb9u1,deb,CVE-2018-20482,Medium,2018-12-26T18:29:00.373,"""GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).""",tar1.29b-1.11.29b-1.1+deb9u1debCVE-2018-20482Medium
libncursesw6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u4,deb,CVE-2020-19189,Medium,2023-08-22T19:16:01.020,'Buffer Overflow vulnerability in postprocess_terminfo function in tinfo/parse_entry.c:997 in ncurses 6.1 allows remote attackers to cause a denial of service via crafted command.',libncursesw66.1+20181013-2+deb10u26.1+20181013-2+deb10u4debCVE-2020-19189Medium
libtinfo6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u4,deb,CVE-2020-19189,Medium,2023-08-22T19:16:01.020,'Buffer Overflow vulnerability in postprocess_terminfo function in tinfo/parse_entry.c:997 in ncurses 6.1 allows remote attackers to cause a denial of service via crafted command.',libtinfo66.1+20181013-2+deb10u26.1+20181013-2+deb10u4debCVE-2020-19189Medium
ncurses-base,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u4,deb,CVE-2020-19189,Medium,2023-08-22T19:16:01.020,'Buffer Overflow vulnerability in postprocess_terminfo function in tinfo/parse_entry.c:997 in ncurses 6.1 allows remote attackers to cause a denial of service via crafted command.',ncurses-base6.1+20181013-2+deb10u26.1+20181013-2+deb10u4debCVE-2020-19189Medium
ncurses-bin,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u4,deb,CVE-2020-19189,Medium,2023-08-22T19:16:01.020,'Buffer Overflow vulnerability in postprocess_terminfo function in tinfo/parse_entry.c:997 in ncurses 6.1 allows remote attackers to cause a denial of service via crafted command.',ncurses-bin6.1+20181013-2+deb10u26.1+20181013-2+deb10u4debCVE-2020-19189Medium
libncurses6,6.1+20181013-2+deb10u2,6.1+20181013-2+deb10u4,deb,CVE-2020-19189,Medium,2023-08-22T19:16:01.020,'Buffer Overflow vulnerability in postprocess_terminfo function in tinfo/parse_entry.c:997 in ncurses 6.1 allows remote attackers to cause a denial of service via crafted command.',libncurses66.1+20181013-2+deb10u26.1+20181013-2+deb10u4debCVE-2020-19189Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-20288,High,2021-04-15T15:15:12.257,"""An authentication flaw was found in ceph in versions before 14.2.20. When the monitor handles CEPHX_GET_AUTH_SESSION_KEY requests, it doesn't sanitize other_keys, allowing key reuse. An attacker who can request a global_id can exploit the ability of any user to request a global_id previously associated with another user, as ceph does not force the reuse of old keys to generate new ones. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.""",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-20288High
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-27781,High,2020-12-18T21:15:12.660,"'User credentials can be manipulated and stolen by Native CephFS consumers of OpenStack Manila, resulting in potential privilege escalation. An Open Stack Manila user can request access to a share to an arbitrary cephx user, including existing users. The access key is retrieved via the interface drivers. Then, all users of the requesting OpenStack project can view the access key. This enables the attacker to target any resource that the user has access to. This can be done to even ""admin"" users, compromising the ceph administrator. This flaw affects Ceph versions prior to 14.2.16, 15.x prior to 15.2.8, and 16.x prior to 16.2.0.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-27781High
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-12059,High,2020-04-22T13:15:11.337,'An issue was discovered in Ceph through 13.2.9. A POST request with an invalid tagging XML can crash the RGW process by triggering a NULL pointer exception.',python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-12059High
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2019-10222,High,2019-11-08T15:15:11.437,"'A flaw was found in the Ceph RGW configuration with Beast as the front end handling client requests. An unauthenticated attacker could crash the Ceph RGW server by sending valid HTTP headers and terminating the connection, resulting in a remote denial of service for Ceph RGW clients.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2019-10222High
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3979,Medium,2022-08-25T20:15:09.473,"'A key length flaw was found in Red Hat Ceph Storage. An attacker can exploit the fact that the key length is incorrectly passed in an encryption algorithm to create a non random key, which is weaker and can be exploited for loss of confidentiality and integrity on encrypted disks.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3979Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3531,Medium,2021-05-18T12:15:08.080,"'A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3531Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2021-3524,Medium,2021-05-17T17:15:08.773,"'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway) in versions before 14.2.21. The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. In addition, the prior bug fix for CVE-2020-10753 did not account for the use of \\r as a header separator, thus a new flaw has been created.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2021-3524Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-25678,Medium,2021-01-08T18:15:13.293,"'A flaw was found in ceph in versions prior to 16.y.z where ceph stores mgr module passwords in clear text. This can be found by searching the mgr logs for grafana and dashboard, with passwords visible.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-25678Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1760,Medium,2020-04-23T15:15:14.607,"'A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1760Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-1700,Medium,2020-02-07T21:15:10.433,"'A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.'",python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-1700Medium
ceph-common,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',ceph-common12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
libcephfs2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',libcephfs212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
librados2,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',librados212.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
libradosstriper1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',libradosstriper112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
librbd1,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',librbd112.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
python-cephfs,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',python-cephfs12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
python-rados,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',python-rados12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
python-rbd,12.2.11+dfsg1-2.1+b1,12.2.11+dfsg1-2.1+deb10u1,deb,CVE-2020-10753,Medium,2020-06-26T15:15:11.573,'A flaw was found in the Red Hat Ceph Storage RadosGW (Ceph Object Gateway). The vulnerability is related to the injection of HTTP headers via a CORS ExposeHeader tag. The newline character in the ExposeHeader tag in the CORS configuration file generates a header injection in the response when the CORS request is made. Ceph versions 3.x and 4.x are vulnerable to this issue.',python-rbd12.2.11+dfsg1-2.1+b112.2.11+dfsg1-2.1+deb10u1debCVE-2020-10753Medium
cifs-utils,2:6.8-2,2:6.8-2+deb10u1,deb,CVE-2022-27239,High,2022-04-27T14:15:09.203,"'In cifs-utils through 6.14, a stack-based buffer overflow when parsing the mount.cifs ip= command-line argument could lead to local attackers gaining root privileges.'",cifs-utils2:6.8-22:6.8-2+deb10u1debCVE-2022-27239High
cifs-utils,2:6.8-2,(won't fix),deb,CVE-2020-14342,High,2020-09-09T12:15:11.210,"""It was found that cifs-utils' mount.cifs was invoking a shell when requesting the Samba password, which could be used to inject arbitrary commands. An attacker able to invoke mount.cifs with special permission, such as via sudo rules, could use this flaw to escalate their privileges.""",cifs-utils2:6.8-2(won't fix)debCVE-2020-14342High
cifs-utils,2:6.8-2,2:6.8-2+deb10u1,deb,CVE-2022-29869,Medium,2022-04-28T01:15:06.727,"'cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file.'",cifs-utils2:6.8-22:6.8-2+deb10u1debCVE-2022-29869Medium
cifs-utils,2:6.8-2,(won't fix),deb,CVE-2021-20208,Medium,2021-04-19T22:15:12.873,'A flaw was found in cifs-utils in versions before 6.13. A user when mounting a krb5 CIFS file system from within a container can use Kerberos credentials of the host. The highest threat from this vulnerability is to data confidentiality and integrity.',cifs-utils2:6.8-2(won't fix)debCVE-2021-20208Medium
cifs-utils,2:6.8-2, ,deb,CVE-2014-2830,Negligible,2015-03-31T14:59:02.047,"'Stack-based buffer overflow in cifskey.c or cifscreds.c in cifs-utils before 6.4, as used in pam_cifscreds, allows remote attackers to have unspecified impact via unknown vectors.'",cifs-utils2:6.8-2 debCVE-2014-2830Negligible
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u7,deb,CVE-2022-41903,Critical,2023-01-17T23:15:15.690,"'Git is distributed revision control system. `git log` can display commits in an arbitrary format using its `--format` specifiers. This functionality is also exposed to `git archive` via the `export-subst` gitattribute. When processing the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()` where a `size_t` is stored improperly as an `int`, and then added as an offset to a `memcpy()`. This overflow can be triggered directly by a user running a command which invokes the commit formatting machinery (e.g., `git log --format=...`). It may also be triggered indirectly through git archive via the export-subst mechanism, which expands format specifiers inside of files within the repository during a git archive. This integer overflow can result in arbitrary heap writes, which may result in arbitrary code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. Users who are unable to upgrade should disable `git archive` in untrusted repositories. If you expose git archive via `git daemon`, disable it by running `git config --global daemon.uploadArch false`.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u7debCVE-2022-41903Critical
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u7,deb,CVE-2022-41903,Critical,2023-01-17T23:15:15.690,"'Git is distributed revision control system. `git log` can display commits in an arbitrary format using its `--format` specifiers. This functionality is also exposed to `git archive` via the `export-subst` gitattribute. When processing the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()` where a `size_t` is stored improperly as an `int`, and then added as an offset to a `memcpy()`. This overflow can be triggered directly by a user running a command which invokes the commit formatting machinery (e.g., `git log --format=...`). It may also be triggered indirectly through git archive via the export-subst mechanism, which expands format specifiers inside of files within the repository during a git archive. This integer overflow can result in arbitrary heap writes, which may result in arbitrary code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. Users who are unable to upgrade should disable `git archive` in untrusted repositories. If you expose git archive via `git daemon`, disable it by running `git config --global daemon.uploadArch false`.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u7debCVE-2022-41903Critical
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u7,deb,CVE-2022-23521,Critical,2023-01-17T23:15:15.580,"'Git is distributed revision control system. gitattributes are a mechanism to allow defining attributes for paths. These attributes can be defined by adding a `.gitattributes` file to the repository, which contains a set of file patterns and the attributes that should be set for paths matching this pattern. When parsing gitattributes, multiple integer overflows can occur when there is a huge number of path patterns, a huge number of attributes for a single pattern, or when the declared attribute names are huge. These overflows can be triggered via a crafted `.gitattributes` file that may be part of the commit history. Git silently splits lines longer than 2KB when parsing gitattributes from a file, but not when parsing them from the index. Consequentially, the failure mode depends on whether the file exists in the working tree, the index or both. This integer overflow can result in arbitrary heap reads and writes, which may result in remote code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. There are no known workarounds for this issue.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u7debCVE-2022-23521Critical
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u7,deb,CVE-2022-23521,Critical,2023-01-17T23:15:15.580,"'Git is distributed revision control system. gitattributes are a mechanism to allow defining attributes for paths. These attributes can be defined by adding a `.gitattributes` file to the repository, which contains a set of file patterns and the attributes that should be set for paths matching this pattern. When parsing gitattributes, multiple integer overflows can occur when there is a huge number of path patterns, a huge number of attributes for a single pattern, or when the declared attribute names are huge. These overflows can be triggered via a crafted `.gitattributes` file that may be part of the commit history. Git silently splits lines longer than 2KB when parsing gitattributes from a file, but not when parsing them from the index. Consequentially, the failure mode depends on whether the file exists in the working tree, the index or both. This integer overflow can result in arbitrary heap reads and writes, which may result in remote code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. There are no known workarounds for this issue.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u7debCVE-2022-23521Critical
git,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-29007,High,2023-04-25T21:15:10.403,"""Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`. This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config` when attempting to remove the configuration section associated with that submodule. When the attacker injects configuration values which specify executables to run (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid running `git submodule deinit` on untrusted repositories or without prior inspection of any submodule sections in `$GIT_DIR/config`.""",git1:2.20.1-2+deb10u3(won't fix)debCVE-2023-29007High
git-man,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-29007,High,2023-04-25T21:15:10.403,"""Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`. This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config` when attempting to remove the configuration section associated with that submodule. When the attacker injects configuration values which specify executables to run (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid running `git submodule deinit` on untrusted repositories or without prior inspection of any submodule sections in `$GIT_DIR/config`.""",git-man1:2.20.1-2+deb10u3(won't fix)debCVE-2023-29007High
git,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-25652,High,2023-04-25T20:15:09.933,"'Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding specially crafted input to `git apply --reject`, a path outside the working tree can be overwritten with partially controlled contents (corresponding to the rejected hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid using `git apply` with `--reject` when applying patches from an untrusted source. Use `git apply --stat` to inspect a patch before applying; avoid applying one that create a conflict where a link corresponding to the `*.rej` file exists.'",git1:2.20.1-2+deb10u3(won't fix)debCVE-2023-25652High
git-man,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-25652,High,2023-04-25T20:15:09.933,"'Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding specially crafted input to `git apply --reject`, a path outside the working tree can be overwritten with partially controlled contents (corresponding to the rejected hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid using `git apply` with `--reject` when applying patches from an untrusted source. Use `git apply --stat` to inspect a patch before applying; avoid applying one that create a conflict where a link corresponding to the `*.rej` file exists.'",git-man1:2.20.1-2+deb10u3(won't fix)debCVE-2023-25652High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u8,deb,CVE-2023-23946,High,2023-02-14T20:15:17.457,"'Git, a revision control system, is vulnerable to path traversal prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8. By feeding a crafted input to `git apply`, a path outside the working tree can be overwritten as the user who is running `git apply`. A fix has been prepared and will appear in v2.39.2, v2.38.4, v2.37.6, v2.36.5, v2.35.7, v2.34.7, v2.33.7, v2.32.6, v2.31.7, and v2.30.8. As a workaround, use `git apply --stat` to inspect a patch before applying; avoid applying one that creates a symbolic link and then creates a file beyond the symbolic link.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u8debCVE-2023-23946High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u8,deb,CVE-2023-23946,High,2023-02-14T20:15:17.457,"'Git, a revision control system, is vulnerable to path traversal prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8. By feeding a crafted input to `git apply`, a path outside the working tree can be overwritten as the user who is running `git apply`. A fix has been prepared and will appear in v2.39.2, v2.38.4, v2.37.6, v2.36.5, v2.35.7, v2.34.7, v2.33.7, v2.32.6, v2.31.7, and v2.30.8. As a workaround, use `git apply --stat` to inspect a patch before applying; avoid applying one that creates a symbolic link and then creates a file beyond the symbolic link.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u8debCVE-2023-23946High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-39260,High,2022-10-19T12:15:10.160,"""Git is an open source, scalable, distributed revision control system. `git shell` is a restricted login shell that can be used to implement Git's push/pull functionality via SSH. In versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4, the function that splits the command arguments into an array improperly uses an `int` to represent the number of entries in the array, allowing a malicious actor to intentionally overflow the return value, leading to arbitrary heap writes. Because the resulting array is then passed to `execv()`, it is possible to leverage this attack to gain remote code execution on a victim machine. Note that a victim must first allow access to `git shell` as a login shell in order to be vulnerable to this attack. This problem is patched in versions 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 and users are advised to upgrade to the latest version. Disabling `git shell` access via remote logins is a viable short-term workaround.""",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-39260High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-39260,High,2022-10-19T12:15:10.160,"""Git is an open source, scalable, distributed revision control system. `git shell` is a restricted login shell that can be used to implement Git's push/pull functionality via SSH. In versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4, the function that splits the command arguments into an array improperly uses an `int` to represent the number of entries in the array, allowing a malicious actor to intentionally overflow the return value, leading to arbitrary heap writes. Because the resulting array is then passed to `execv()`, it is possible to leverage this attack to gain remote code execution on a victim machine. Note that a victim must first allow access to `git shell` as a login shell in order to be vulnerable to this attack. This problem is patched in versions 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 and users are advised to upgrade to the latest version. Disabling `git shell` access via remote logins is a viable short-term workaround.""",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-39260High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-29187,High,2022-07-12T21:15:09.560,"'Git is a distributed revision control system. Git prior to versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5, is vulnerable to privilege escalation in all platforms. An unsuspecting user could still be affected by the issue reported in CVE-2022-24765, for example when navigating as root into a shared tmp directory that is owned by them, but where an attacker could create a git repository. Versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5 contain a patch for this issue. The simplest way to avoid being affected by the exploit described in the example is to avoid running git as root (or an Administrator in Windows), and if needed to reduce its use to a minimum. While a generic workaround is not possible, a system could be hardened from the exploit described in the example by removing any such repository if it exists already and creating one as root to block any future attacks.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-29187High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-29187,High,2022-07-12T21:15:09.560,"'Git is a distributed revision control system. Git prior to versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5, is vulnerable to privilege escalation in all platforms. An unsuspecting user could still be affected by the issue reported in CVE-2022-24765, for example when navigating as root into a shared tmp directory that is owned by them, but where an attacker could create a git repository. Versions 2.37.1, 2.36.2, 2.35.4, 2.34.4, 2.33.4, 2.32.3, 2.31.4, and 2.30.5 contain a patch for this issue. The simplest way to avoid being affected by the exploit described in the example is to avoid running git as root (or an Administrator in Windows), and if needed to reduce its use to a minimum. While a generic workaround is not possible, a system could be hardened from the exploit described in the example by removing any such repository if it exists already and creating one as root to block any future attacks.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-29187High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-24765,High,2022-04-12T18:15:09.390,"'Git for Windows is a fork of Git containing Windows-specific patches. This vulnerability affects users working on multi-user machines, where untrusted parties have write access to the same hard disk. Those untrusted parties could create the folder `C:\\.git`, which would be picked up by Git operations run supposedly outside a repository while searching for a Git directory. Git would then respect any config in said Git directory. Git Bash users who set `GIT_PS1_SHOWDIRTYSTATE` are vulnerable as well. Users who installed posh-gitare vulnerable simply by starting a PowerShell. Users of IDEs such as Visual Studio are vulnerable: simply creating a new project would already read and respect the config specified in `C:\\.git\\config`. Users of the Microsoft fork of Git are vulnerable simply by starting a Git Bash. The problem has been patched in Git for Windows v2.35.2. Users unable to upgrade may create the folder `.git` on all drives where Git commands are run, and remove read/write access from those folders as a workaround. Alternatively, define or extend `GIT_CEILING_DIRECTORIES` to cover the _parent_ directory of the user profile, e.g. `C:\\Users` if the user profile is located in `C:\\Users\\my-user-name`.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-24765High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-24765,High,2022-04-12T18:15:09.390,"'Git for Windows is a fork of Git containing Windows-specific patches. This vulnerability affects users working on multi-user machines, where untrusted parties have write access to the same hard disk. Those untrusted parties could create the folder `C:\\.git`, which would be picked up by Git operations run supposedly outside a repository while searching for a Git directory. Git would then respect any config in said Git directory. Git Bash users who set `GIT_PS1_SHOWDIRTYSTATE` are vulnerable as well. Users who installed posh-gitare vulnerable simply by starting a PowerShell. Users of IDEs such as Visual Studio are vulnerable: simply creating a new project would already read and respect the config specified in `C:\\.git\\config`. Users of the Microsoft fork of Git are vulnerable simply by starting a Git Bash. The problem has been patched in Git for Windows v2.35.2. Users unable to upgrade may create the folder `.git` on all drives where Git commands are run, and remove read/write access from those folders as a workaround. Alternatively, define or extend `GIT_CEILING_DIRECTORIES` to cover the _parent_ directory of the user profile, e.g. `C:\\Users` if the user profile is located in `C:\\Users\\my-user-name`.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-24765High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u4,deb,CVE-2021-40330,High,2021-08-31T04:15:10.667,"'git_connect_git in connect.c in Git before 2.30.1 allows a repository path to contain a newline character, which may result in unexpected cross-protocol requests, as demonstrated by the git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 substring.'",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u4debCVE-2021-40330High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u4,deb,CVE-2021-40330,High,2021-08-31T04:15:10.667,"'git_connect_git in connect.c in Git before 2.30.1 allows a repository path to contain a newline character, which may result in unexpected cross-protocol requests, as demonstrated by the git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 substring.'",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u4debCVE-2021-40330High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u4,deb,CVE-2021-21300,High,2021-03-09T20:15:13.260,"""Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6.""",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u4debCVE-2021-21300High
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u4,deb,CVE-2021-21300,High,2021-03-09T20:15:13.260,"""Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6.""",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u4debCVE-2021-21300High
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u8,deb,CVE-2023-22490,Medium,2023-02-14T20:15:16.683,"""Git is a revision control system. Using a specially-crafted repository, Git prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8 can be tricked into using its local clone optimization even when using a non-local transport. Though Git will abort local clones whose source `$GIT_DIR/objects` directory contains symbolic links, the `objects` directory itself may still be a symbolic link. These two may be combined to include arbitrary files based on known paths on the victim's filesystem within the malicious repository's working copy, allowing for data exfiltration in a similar manner as CVE-2022-39253.\n\nA fix has been prepared and will appear in v2.39.2 v2.38.4 v2.37.6 v2.36.5 v2.35.7 v2.34.7 v2.33.7 v2.32.6, v2.31.7 and v2.30.8. If upgrading is impractical, two short-term workarounds are available. Avoid cloning repositories from untrusted sources with `--recurse-submodules`. Instead, consider cloning repositories without recursively cloning their submodules, and instead run `git submodule update` at each layer. Before doing so, inspect each new `.gitmodules` file to ensure that it does not contain suspicious module URLs.""",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u8debCVE-2023-22490Medium
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u8,deb,CVE-2023-22490,Medium,2023-02-14T20:15:16.683,"""Git is a revision control system. Using a specially-crafted repository, Git prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7, and 2.30.8 can be tricked into using its local clone optimization even when using a non-local transport. Though Git will abort local clones whose source `$GIT_DIR/objects` directory contains symbolic links, the `objects` directory itself may still be a symbolic link. These two may be combined to include arbitrary files based on known paths on the victim's filesystem within the malicious repository's working copy, allowing for data exfiltration in a similar manner as CVE-2022-39253.\n\nA fix has been prepared and will appear in v2.39.2 v2.38.4 v2.37.6 v2.36.5 v2.35.7 v2.34.7 v2.33.7 v2.32.6, v2.31.7 and v2.30.8. If upgrading is impractical, two short-term workarounds are available. Avoid cloning repositories from untrusted sources with `--recurse-submodules`. Instead, consider cloning repositories without recursively cloning their submodules, and instead run `git submodule update` at each layer. Before doing so, inspect each new `.gitmodules` file to ensure that it does not contain suspicious module URLs.""",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u8debCVE-2023-22490Medium
git,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-39253,Medium,2022-10-19T11:15:11.227,"""Git is an open source, scalable, distributed revision control system. Versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 are subject to exposure of sensitive information to a malicious actor. When performing a local clone (where the source and target of the clone are on the same volume), Git copies the contents of the source's `$GIT_DIR/objects` directory into the destination by either creating hardlinks to the source contents, or copying them (if hardlinks are disabled via `--no-hardlinks`). A malicious actor could convince a victim to clone a repository with a symbolic link pointing at sensitive information on the victim's machine. This can be done either by having the victim clone a malicious repository on the same machine, or having them clone a malicious repository embedded as a bare repository via a submodule from any source, provided they clone with the `--recurse-submodules` option. Git does not create symbolic links in the `$GIT_DIR/objects` directory. The problem has been patched in the versions published on 2022-10-18, and backported to v2.30.x. Potential workarounds: Avoid cloning untrusted repositories using the `--local` optimization when on a shared machine, either by passing the `--no-local` option to `git clone` or cloning from a URL that uses the `file://` scheme. Alternatively, avoid cloning repositories from untrusted sources with `--recurse-submodules` or run `git config --global protocol.file.allow user`.""",git1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-39253Medium
git-man,1:2.20.1-2+deb10u3,1:2.20.1-2+deb10u5,deb,CVE-2022-39253,Medium,2022-10-19T11:15:11.227,"""Git is an open source, scalable, distributed revision control system. Versions prior to 2.30.6, 2.31.5, 2.32.4, 2.33.5, 2.34.5, 2.35.5, 2.36.3, and 2.37.4 are subject to exposure of sensitive information to a malicious actor. When performing a local clone (where the source and target of the clone are on the same volume), Git copies the contents of the source's `$GIT_DIR/objects` directory into the destination by either creating hardlinks to the source contents, or copying them (if hardlinks are disabled via `--no-hardlinks`). A malicious actor could convince a victim to clone a repository with a symbolic link pointing at sensitive information on the victim's machine. This can be done either by having the victim clone a malicious repository on the same machine, or having them clone a malicious repository embedded as a bare repository via a submodule from any source, provided they clone with the `--recurse-submodules` option. Git does not create symbolic links in the `$GIT_DIR/objects` directory. The problem has been patched in the versions published on 2022-10-18, and backported to v2.30.x. Potential workarounds: Avoid cloning untrusted repositories using the `--local` optimization when on a shared machine, either by passing the `--no-local` option to `git clone` or cloning from a URL that uses the `file://` scheme. Alternatively, avoid cloning repositories from untrusted sources with `--recurse-submodules` or run `git config --global protocol.file.allow user`.""",git-man1:2.20.1-2+deb10u31:2.20.1-2+deb10u5debCVE-2022-39253Medium
git,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-25815,Low,2023-04-25T20:15:09.997,"""In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.""",git1:2.20.1-2+deb10u3(won't fix)debCVE-2023-25815Low
git-man,1:2.20.1-2+deb10u3,(won't fix),deb,CVE-2023-25815,Low,2023-04-25T20:15:09.997,"""In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.""",git-man1:2.20.1-2+deb10u3(won't fix)debCVE-2023-25815Low
git,1:2.20.1-2+deb10u3, ,deb,CVE-2022-24975,Negligible,2022-02-11T20:15:07.507,"'The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content, aka the ""GitBleed"" issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option.'",git1:2.20.1-2+deb10u3 debCVE-2022-24975Negligible
git-man,1:2.20.1-2+deb10u3, ,deb,CVE-2022-24975,Negligible,2022-02-11T20:15:07.507,"'The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content, aka the ""GitBleed"" issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option.'",git-man1:2.20.1-2+deb10u3 debCVE-2022-24975Negligible
git,1:2.20.1-2+deb10u3, ,deb,CVE-2018-1000021,Negligible,2018-02-09T23:29:00.557,"'GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server, (or have their traffic modified in a MITM attack).'",git1:2.20.1-2+deb10u3 debCVE-2018-1000021Negligible
git-man,1:2.20.1-2+deb10u3, ,deb,CVE-2018-1000021,Negligible,2018-02-09T23:29:00.557,"'GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server, (or have their traffic modified in a MITM attack).'",git-man1:2.20.1-2+deb10u3 debCVE-2018-1000021Negligible
glusterfs-client,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",glusterfs-client5.5-3(won't fix)debCVE-2023-26253High
glusterfs-common,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",glusterfs-common5.5-3(won't fix)debCVE-2023-26253High
libgfapi0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libgfapi05.5-3(won't fix)debCVE-2023-26253High
libgfchangelog0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libgfchangelog05.5-3(won't fix)debCVE-2023-26253High
libgfdb0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libgfdb05.5-3(won't fix)debCVE-2023-26253High
libgfrpc0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libgfrpc05.5-3(won't fix)debCVE-2023-26253High
libgfxdr0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libgfxdr05.5-3(won't fix)debCVE-2023-26253High
libglusterfs-dev,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libglusterfs-dev5.5-3(won't fix)debCVE-2023-26253High
libglusterfs0,5.5-3,(won't fix),deb,CVE-2023-26253,High,2023-02-21T02:15:10.367,"'In Gluster GlusterFS 11.0, there is an xlators/mount/fuse/src/fuse-bridge.c notify stack-based buffer over-read.'",libglusterfs05.5-3(won't fix)debCVE-2023-26253High
glusterfs-client,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",glusterfs-client5.5-3(won't fix)debCVE-2022-48340High
glusterfs-common,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",glusterfs-common5.5-3(won't fix)debCVE-2022-48340High
libgfapi0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libgfapi05.5-3(won't fix)debCVE-2022-48340High
libgfchangelog0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libgfchangelog05.5-3(won't fix)debCVE-2022-48340High
libgfdb0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libgfdb05.5-3(won't fix)debCVE-2022-48340High
libgfrpc0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libgfrpc05.5-3(won't fix)debCVE-2022-48340High
libgfxdr0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libgfxdr05.5-3(won't fix)debCVE-2022-48340High
libglusterfs-dev,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libglusterfs-dev5.5-3(won't fix)debCVE-2022-48340High
libglusterfs0,5.5-3,(won't fix),deb,CVE-2022-48340,High,2023-02-21T02:15:10.217,"'In Gluster GlusterFS 11.0, there is an xlators/cluster/dht/src/dht-common.c dht_setxattr_mds_cbk use-after-free.'",libglusterfs05.5-3(won't fix)debCVE-2022-48340High
iproute2,4.20.0-2,(won't fix),deb,CVE-2019-20795,Medium,2020-05-09T21:15:10.913,"'iproute2 before 5.1.0 has a use-after-free in get_netnsid_from_name in ip/ipnetns.c. NOTE: security relevance may be limited to certain uses of setuid that, although not a default, are sometimes a configuration option offered to end users. Even when setuid is used, other factors (such as C library configuration) may block exploitability.'",iproute24.20.0-2(won't fix)debCVE-2019-20795Medium
libbsd0,0.9.1-2,0.9.1-2+deb10u1,deb,CVE-2019-20367,Critical,2020-01-08T17:15:11.757,'nlist.c in libbsd before 0.10.0 has an out-of-bounds read during a comparison for a symbol name from the string table (strtab).',libbsd00.9.1-20.9.1-2+deb10u1debCVE-2019-20367Critical
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u4,deb,CVE-2022-32221,Critical,2022-12-05T22:15:10.343,"'When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u4debCVE-2022-32221Critical
libcurl3-gnutls,7.64.0-4+deb10u1,(won't fix),deb,CVE-2023-27534,High,2023-03-30T20:15:07.427,"""A path traversal vulnerability exists in curl <8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.""",libcurl3-gnutls7.64.0-4+deb10u1(won't fix)debCVE-2023-27534High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u6,deb,CVE-2023-27533,High,2023-03-30T20:15:07.373,"'A vulnerability in input validation exists in curl <8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and ""telnet options"" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application\'s intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u6debCVE-2023-27533High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-27782,High,2022-06-02T14:15:44.663,"'libcurl would reuse a previously created connection even when a TLS or SSHrelated option had been changed that should have prohibited reuse.libcurl keeps previously used connections in a connection pool for subsequenttransfers to reuse if one of them matches the setup. However, several TLS andSSH settings were left out from the configuration match checks, making themmatch too easily.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-27782High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-27781,High,2022-06-02T14:15:44.467,"""libcurl provides the `CURLOPT_CERTINFO` option to allow applications torequest details to be returned about a server's certificate chain.Due to an erroneous function, a malicious server could make libcurl built withNSS get stuck in a never-ending busy-loop when trying to retrieve thatinformation.""",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-27781High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-22576,High,2022-05-26T17:15:09.077,"'An improper authentication vulnerability exists in curl 7.33.0 to and including 7.82.0 which might allow reuse OAUTH2-authenticated connections without properly making sure that the connection was authenticated with the same credentials as set for this transfer. This affects SASL-enabled protocols: SMPTP(S), IMAP(S), POP3(S) and LDAP(S) (openldap only).'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-22576High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2021-22946,High,2021-09-29T20:15:08.187,"'A user can tell curl >= 7.20.0 and <= 7.78.0 to require a successful upgrade to TLS when speaking to an IMAP, POP3 or FTP server (`--ssl-reqd` on the command line or`CURLOPT_USE_SSL` set to `CURLUSESSL_CONTROL` or `CURLUSESSL_ALL` withlibcurl). This requirement could be bypassed if the server would return a properly crafted but perfectly legitimate response.This flaw would then make curl silently continue its operations **withoutTLS** contrary to the instructions and expectations, exposing possibly sensitive data in clear text over the network.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2021-22946High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2020-8286,High,2020-12-14T20:15:14.043,'curl 7.41.0 through 7.73.0 is vulnerable to an improper check for certificate revocation due to insufficient verification of the OCSP response.',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2020-8286High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2020-8231,High,2020-12-14T20:15:13.590,"'Due to use of a dangling pointer, libcurl 7.29.0 through 7.71.1 can use the wrong connection when sending data.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2020-8231High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2020-8177,High,2020-12-14T20:15:13.497,'curl 7.20.0 through 7.70.0 is vulnerable to improper restriction of names for files and other resources that can lead too overwriting a local file when the -J flag is used.',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2020-8177High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2020-8169,High,2020-12-14T20:15:13.357,'curl 7.62.0 through 7.70.0 is vulnerable to an information disclosure vulnerability that can lead to a partial password being leaked over the network and to the DNS server(s).',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2020-8169High
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u7,deb,CVE-2023-28321,Medium,2023-05-26T21:15:16.020,"'An improper certificate validation vulnerability exists in curl <v8.1.0 in the way it supports matching of wildcard patterns when listed as ""Subject Alternative Name"" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u7debCVE-2023-28321Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u6,deb,CVE-2023-27538,Medium,2023-03-30T20:15:07.677,"'An authentication bypass vulnerability exists in libcurl prior to v8.0.0 where it reuses a previously established SSH connection despite the fact that an SSH option was modified, which should have prevented reuse. libcurl maintains a pool of previously used connections to reuse them for subsequent transfers if the configurations match. However, two SSH settings were omitted from the configuration check, allowing them to match easily, potentially leading to the reuse of an inappropriate connection.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u6debCVE-2023-27538Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u6,deb,CVE-2023-27536,Medium,2023-03-30T20:15:07.547,'An authentication bypass vulnerability exists libcurl <8.0.0 in the connection reuse feature which can reuse previously established connections with incorrect user permissions due to a failure to check for changes in the CURLOPT_GSSAPI_DELEGATION option. This vulnerability affects krb5/kerberos/negotiate/GSSAPI transfers and could potentially result in unauthorized access to sensitive information. The safest option is to not reuse connections if the CURLOPT_GSSAPI_DELEGATION option has been changed.',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u6debCVE-2023-27536Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u6,deb,CVE-2023-27535,Medium,2023-03-30T20:15:07.483,"'An authentication bypass vulnerability exists in libcurl <8.0.0 in the FTP connection reuse feature that can result in wrong credentials being used during subsequent transfers. Previously created connections are kept in a connection pool for reuse if they match the current setup. However, certain FTP settings such as CURLOPT_FTP_ACCOUNT, CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPT_FTP_SSL_CCC, and CURLOPT_USE_SSL were not included in the configuration match checks, causing them to match too easily. This could lead to libcurl using the wrong credentials when performing a transfer, potentially allowing unauthorized access to sensitive information.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u6debCVE-2023-27535Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u5,deb,CVE-2023-23916,Medium,2023-02-23T20:15:13.777,"'An allocation of resources without limits or throttling vulnerability exists in curl <v7.88.0 based on the ""chained"" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable ""links"" in this ""decompression chain"" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a ""malloc bomb"", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u5debCVE-2023-23916Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u4,deb,CVE-2022-43552,Medium,2023-02-09T20:15:10.950,"'A use after free vulnerability exists in curl <7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u4debCVE-2022-43552Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-32208,Medium,2022-07-07T13:15:08.467,"'When curl < 7.84.0 does FTP transfers secured by krb5, it handles message verification failures wrongly. This flaw makes it possible for a Man-In-The-Middle attack to go unnoticed and even allows it to inject data to the client.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-32208Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-32206,Medium,2022-07-07T13:15:08.340,"'curl < 7.84.0 supports ""chained"" HTTP compression algorithms, meaning that a serverresponse can be compressed multiple times and potentially with different algorithms. The number of acceptable ""links"" in this ""decompression chain"" was unbounded, allowing a malicious server to insert a virtually unlimited number of compression steps.The use of such a decompression chain could result in a ""malloc bomb"", makingcurl end up spending enormous amounts of allocated heap memory, or trying toand returning out of memory errors.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-32206Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2022-27776,Medium,2022-06-02T14:15:43.713,'A insufficiently protected credentials vulnerability in fixed in curl 7.83.0 might leak authentication or cookie header data on HTTP redirects to the same host but another port number.',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2022-27776Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u4,deb,CVE-2022-27774,Medium,2022-06-02T14:15:43.317,'An insufficiently protected credentials vulnerability exists in curl 4.9 to and include curl 7.82.0 are affected that could allow an attacker to extract credentials when follows HTTP(S) redirects is used with authentication could leak credentials to other services that exist on different protocols or port numbers.',libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u4debCVE-2022-27774Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2021-22947,Medium,2021-09-29T20:15:08.253,"""When curl >= 7.20.0 and <= 7.78.0 connects to an IMAP or POP3 server to retrieve data using STARTTLS to upgrade to TLS security, the server can respond and send back multiple responses at once that curl caches. curl would then upgrade to TLS but not flush the in-queue of cached responses but instead continue using and trustingthe responses it got *before* the TLS handshake as if they were authenticated.Using this flaw, it allows a Man-In-The-Middle attacker to first inject the fake responses, then pass-through the TLS traffic from the legitimate server and trick curl into sending data back to the user thinking the attacker's injected data comes from the TLS-protected server.""",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2021-22947Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2021-22876,Medium,2021-04-01T18:15:12.823,"'curl 7.1.1 to and including 7.75.0 is vulnerable to an ""Exposure of Private Personal Information to an Unauthorized Actor"" by leaking credentials in the HTTP Referer: header. libcurl does not strip off user credentials from the URL when automatically populating the Referer: HTTP request header field in outgoing HTTP requests, and therefore risks leaking sensitive data to the server that is the target of the second HTTP request.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2021-22876Medium
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u7,deb,CVE-2023-38546,Low,2023-10-18T04:15:11.137,"'This flaw allows an attacker to insert cookies at will into a running program\nusing libcurl, if the specific series of conditions are met.\n\nlibcurl performs transfers. In its API, an application creates ""easy handles""\nthat are the individual handles for single transfers.\n\nlibcurl provides a function call that duplicates en easy handle called\n[curl_easy_duphandle",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u7debCVE-2023-38546Low
libcurl3-gnutls,7.64.0-4+deb10u1,(won't fix),deb,CVE-2023-28322,Low,2023-05-26T21:15:16.153,"'An information disclosure vulnerability exists in curl <v8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.'",libcurl3-gnutls7.64.0-4+deb10u1(won't fix)debCVE-2023-28322Low
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u4,deb,CVE-2022-35252,Low,2022-09-23T14:15:12.323,"'When curl is used to retrieve and parse cookies from a HTTP(S) server, itaccepts cookies using control codes that when later are sent back to a HTTPserver might make the server return 400 responses. Effectively allowing a""sister site"" to deny service to all siblings.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u4debCVE-2022-35252Low
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2021-22924,Low,2021-08-05T21:15:11.380,"""libcurl keeps previously used connections in a connection pool for subsequenttransfers to reuse, if one of them matches the setup.Due to errors in the logic, the config matching function did not take 'issuercert' into account and it compared the involved paths *case insensitively*,which could lead to libcurl reusing wrong connections.File paths are, or can be, case sensitive on many systems but not all, and caneven vary depending on used file systems.The comparison also didn't include the 'issuer cert' which a transfer can setto qualify how to verify the server certificate.""",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2021-22924Low
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u3,deb,CVE-2021-22898,Low,2021-06-11T16:15:11.043,"'curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u3debCVE-2021-22898Low
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2021-22890,Low,2021-04-01T18:15:12.917,"'curl 7.63.0 to and including 7.75.0 includes vulnerability that allows a malicious HTTPS proxy to MITM a connection due to bad handling of TLS 1.3 session tickets. When using a HTTPS proxy and TLS 1.3, libcurl can confuse session tickets arriving from the HTTPS proxy but work as if they arrived from the remote server and then wrongly ""short-cut"" the host handshake. When confusing the tickets, a HTTPS proxy can trick libcurl to use the wrong session ticket resume for the host and thereby circumvent the server TLS certificate check and make a MITM attack to be possible to perform unnoticed. Note that such a malicious HTTPS proxy needs to provide a certificate that curl will accept for the MITMed server for an attack to work - unless curl has been told to ignore the server certificate check.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2021-22890Low
libcurl3-gnutls,7.64.0-4+deb10u1,7.64.0-4+deb10u2,deb,CVE-2020-8284,Low,2020-12-14T20:15:13.903,"'A malicious server can use the FTP PASV response to trick curl 7.73.0 and earlier into connecting back to a given IP address and port, and this way potentially make curl extract information about services that are otherwise private and not disclosed, for example doing port scanning and service banner extractions.'",libcurl3-gnutls7.64.0-4+deb10u17.64.0-4+deb10u2debCVE-2020-8284Low
libcurl3-gnutls,7.64.0-4+deb10u1, ,deb,CVE-2023-28320,Negligible,2023-05-26T21:15:15.937,"'A denial of service vulnerability exists in curl <v8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.'",libcurl3-gnutls7.64.0-4+deb10u1 debCVE-2023-28320Negligible
libcurl3-gnutls,7.64.0-4+deb10u1, ,deb,CVE-2021-22923,Negligible,2021-08-05T21:15:11.293,"""When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.""",libcurl3-gnutls7.64.0-4+deb10u1 debCVE-2021-22923Negligible
libcurl3-gnutls,7.64.0-4+deb10u1, ,deb,CVE-2021-22922,Negligible,2021-08-05T21:15:11.173,"'When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.'",libcurl3-gnutls7.64.0-4+deb10u1 debCVE-2021-22922Negligible
libcurl3-gnutls,7.64.0-4+deb10u1, ,deb,CVE-2020-19909,Negligible,2023-08-22T19:16:06.480,"'Integer overflow vulnerability in tool_operate.c in curl 7.65.2 via a large value as the retry delay. NOTE: many parties report that this has no direct security impact on the curl user; however, it may (in theory) cause a denial of service to associated systems or networks if, for example, --retry-delay is misinterpreted as a value much smaller than what was intended. This is not especially plausible because the overflow only happens if the user was trying to specify that curl should wait weeks (or longer) before trying to recover from a transient error.'",libcurl3-gnutls7.64.0-4+deb10u1 debCVE-2020-19909Negligible
libdw1,0.176-1.1,0.176-1.1+deb10u1,deb,CVE-2020-21047,Medium,2023-08-22T19:16:09.657,"'The libcpu component which is used by libasm of elfutils version 0.177 (git 47780c9e), suffers from denial-of-service vulnerability caused by application crashes due to out-of-bounds write (CWE-787), off-by-one error (CWE-193) and reachable assertion (CWE-617); to exploit the vulnerability, the attackers need to craft certain ELF files which bypass the missing bound checks.'",libdw10.176-1.10.176-1.1+deb10u1debCVE-2020-21047Medium
libelf1,0.176-1.1,0.176-1.1+deb10u1,deb,CVE-2020-21047,Medium,2023-08-22T19:16:09.657,"'The libcpu component which is used by libasm of elfutils version 0.177 (git 47780c9e), suffers from denial-of-service vulnerability caused by application crashes due to out-of-bounds write (CWE-787), off-by-one error (CWE-193) and reachable assertion (CWE-617); to exploit the vulnerability, the attackers need to craft certain ELF files which bypass the missing bound checks.'",libelf10.176-1.10.176-1.1+deb10u1debCVE-2020-21047Medium
libdw1,0.176-1.1, ,deb,CVE-2021-33294,Negligible,2023-07-18T14:15:11.673,"'In elfutils 0.183, an infinite loop was found in the function handle_symtab in readelf.c .Which allows attackers to cause a denial of service (infinite loop) via crafted file.'",libdw10.176-1.1 debCVE-2021-33294Negligible
libelf1,0.176-1.1, ,deb,CVE-2021-33294,Negligible,2023-07-18T14:15:11.673,"'In elfutils 0.183, an infinite loop was found in the function handle_symtab in readelf.c .Which allows attackers to cause a denial of service (infinite loop) via crafted file.'",libelf10.176-1.1 debCVE-2021-33294Negligible
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u3,deb,CVE-2022-25315,Critical,2022-02-18T05:15:08.237,"'In Expat (aka libexpat) before 2.4.5, there is an integer overflow in storeRawNames.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u3debCVE-2022-25315Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u3,deb,CVE-2022-25236,Critical,2022-02-16T01:15:07.650,'xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u3debCVE-2022-25236Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u3,deb,CVE-2022-25235,Critical,2022-02-16T01:15:07.607,"'xmltok_impl.c in Expat (aka libexpat) before 2.4.5 lacks certain validation of encoding, such as checks for whether a UTF-8 character is valid in a certain context.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u3debCVE-2022-25235Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-23852,Critical,2022-01-24T02:15:06.733,"'Expat (aka libexpat) before 2.4.4 has a signed integer overflow in XML_GetBuffer, for configurations with a nonzero XML_CONTEXT_BYTES.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-23852Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22824,Critical,2022-01-10T14:12:56.567,'defineAttribute in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22824Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22823,Critical,2022-01-10T14:12:56.270,'build_model in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22823Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22822,Critical,2022-01-10T14:12:56.047,'addBinding in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22822Critical
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u6,deb,CVE-2022-43680,High,2022-10-24T14:15:53.323,"'In libexpat through 2.4.9, there is a use-after free caused by overeager destruction of a shared DTD in XML_ExternalEntityParserCreate in out-of-memory situations.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u6debCVE-2022-43680High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u5,deb,CVE-2022-40674,High,2022-09-14T11:15:54.020,'libexpat before 2.4.9 has a use-after-free in the doContent function in xmlparse.c.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u5debCVE-2022-40674High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u3,deb,CVE-2022-25314,High,2022-02-18T05:15:08.187,"'In Expat (aka libexpat) before 2.4.5, there is an integer overflow in copyString.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u3debCVE-2022-25314High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-23990,High,2022-01-26T19:15:08.517,'Expat (aka libexpat) before 2.4.4 has an integer overflow in the doProlog function.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-23990High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22827,High,2022-01-10T14:12:57.363,'storeAtts in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22827High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22826,High,2022-01-10T14:12:57.113,'nextScaffoldPart in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22826High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2022-22825,High,2022-01-10T14:12:56.847,'lookup in xmlparse.c in Expat (aka libexpat) before 2.4.3 has an integer overflow.',libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2022-22825High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2021-46143,High,2022-01-06T04:15:07.017,"'In doProlog in xmlparse.c in Expat (aka libexpat) before 2.4.3, an integer overflow exists for m_groupSize.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2021-46143High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u2,deb,CVE-2021-45960,High,2022-01-01T19:15:08.030,"'In Expat (aka libexpat) before 2.4.3, a left shift by 29 (or more) places in the storeAtts function in xmlparse.c can lead to realloc misbehavior (e.g., allocating too few bytes, or only freeing memory).'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u2debCVE-2021-45960High
libexpat1,2.2.6-2+deb10u1,2.2.6-2+deb10u3,deb,CVE-2022-25313,Medium,2022-02-18T05:15:08.130,"'In Expat (aka libexpat) before 2.4.5, an attacker can trigger stack exhaustion in build_model via a large nesting depth in the DTD element.'",libexpat12.2.6-2+deb10u12.2.6-2+deb10u3debCVE-2022-25313Medium
libexpat1,2.2.6-2+deb10u1, ,deb,CVE-2013-0340,Negligible,2014-01-21T18:55:09.117,"'expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.'",libexpat12.2.6-2+deb10u1 debCVE-2013-0340Negligible
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u5,deb,CVE-2023-29499,High,2023-09-14T20:15:09.420,"'A flaw was found in GLib. GVariant deserialization fails to validate that the input conforms to the expected format, leading to denial of service.'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u5debCVE-2023-29499High
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u3,deb,CVE-2021-27219,High,2021-02-15T17:15:13.137,'An issue was discovered in GNOME GLib before 2.66.6 and 2.67.x before 2.67.3. The function g_bytes_new has an integer overflow on 64-bit platforms due to an implicit cast from 64 bits to 32 bits. The overflow could potentially lead to memory corruption.',libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u3debCVE-2021-27219High
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u3,deb,CVE-2021-27218,High,2021-02-15T17:15:13.073,"'An issue was discovered in GNOME GLib before 2.66.7 and 2.67.x before 2.67.4. If g_byte_array_new_take() was called with a buffer of 4GB or more on a 64-bit platform, the length would be truncated modulo 2**32, causing unintended length truncation.'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u3debCVE-2021-27218High
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u5,deb,CVE-2023-32665,Medium,2023-09-14T20:15:09.883,"'A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u5debCVE-2023-32665Medium
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u5,deb,CVE-2023-32611,Medium,2023-09-14T20:15:09.550,"'A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u5debCVE-2023-32611Medium
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u4,deb,CVE-2021-3800,Medium,2022-08-23T16:15:09.980,"'A flaw was found in glib before version 2.63.6. Due to random charset alias, pkexec can leak content from files owned by privileged users to unprivileged ones under the right condition.'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u4debCVE-2021-3800Medium
libglib2.0-0,2.58.3-2+deb10u2,2.58.3-2+deb10u3,deb,CVE-2021-28153,Medium,2021-03-11T22:15:12.777,"'An issue was discovered in GNOME GLib before 2.66.8. When g_file_replace() is used with G_FILE_CREATE_REPLACE_DESTINATION to replace a path that is a dangling symlink, it incorrectly also creates the target of the symlink as an empty file, which could conceivably have security relevance if the symlink is attacker-controlled. (If the path is a symlink to a file that already exists, then the contents of that file correctly remain unchanged.)'",libglib2.0-02.58.3-2+deb10u22.58.3-2+deb10u3debCVE-2021-28153Medium
libglib2.0-0,2.58.3-2+deb10u2, ,deb,CVE-2020-35457,Negligible,2020-12-14T23:15:12.173,"'GNOME GLib before 2.65.3 has an integer overflow, that might lead to an out-of-bounds write, in g_option_group_add_entries. NOTE: the vendor\'s position is ""Realistically this is not a security issue. The standard pattern is for callers to provide a static list of option entries in a fixed number of calls to g_option_group_add_entries()."" The researcher states that this pattern is undocumented'",libglib2.0-02.58.3-2+deb10u2 debCVE-2020-35457Negligible
libglib2.0-0,2.58.3-2+deb10u2, ,deb,CVE-2012-0039,Negligible,2012-01-14T17:55:01.257,"'GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.'",libglib2.0-02.58.3-2+deb10u2 debCVE-2012-0039Negligible
libgssapi-krb5-2,1.17-3,1.17-3+deb10u2,deb,CVE-2021-36222,High,2021-07-22T18:15:23.337,'ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.',libgssapi-krb5-21.17-31.17-3+deb10u2debCVE-2021-36222High
libk5crypto3,1.17-3,1.17-3+deb10u2,deb,CVE-2021-36222,High,2021-07-22T18:15:23.337,'ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.',libk5crypto31.17-31.17-3+deb10u2debCVE-2021-36222High
libkrb5-3,1.17-3,1.17-3+deb10u2,deb,CVE-2021-36222,High,2021-07-22T18:15:23.337,'ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.',libkrb5-31.17-31.17-3+deb10u2debCVE-2021-36222High
libkrb5support0,1.17-3,1.17-3+deb10u2,deb,CVE-2021-36222,High,2021-07-22T18:15:23.337,'ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.',libkrb5support01.17-31.17-3+deb10u2debCVE-2021-36222High
libgssapi-krb5-2,1.17-3,1.17-3+deb10u1,deb,CVE-2020-28196,High,2020-11-06T08:15:13.860,'MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.',libgssapi-krb5-21.17-31.17-3+deb10u1debCVE-2020-28196High
libk5crypto3,1.17-3,1.17-3+deb10u1,deb,CVE-2020-28196,High,2020-11-06T08:15:13.860,'MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.',libk5crypto31.17-31.17-3+deb10u1debCVE-2020-28196High
libkrb5-3,1.17-3,1.17-3+deb10u1,deb,CVE-2020-28196,High,2020-11-06T08:15:13.860,'MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.',libkrb5-31.17-31.17-3+deb10u1debCVE-2020-28196High
libkrb5support0,1.17-3,1.17-3+deb10u1,deb,CVE-2020-28196,High,2020-11-06T08:15:13.860,'MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.',libkrb5support01.17-31.17-3+deb10u1debCVE-2020-28196High
libicu63,63.1-6+deb10u1,63.1-6+deb10u2,deb,CVE-2020-21913,Medium,2021-09-20T14:15:08.160,'International Components for Unicode (ICU-20850) v66.1 was discovered to contain a use after free bug in the pkg_createWithAssemblyCode function in the file tools/pkgdata/pkgdata.cpp.',libicu6363.1-6+deb10u163.1-6+deb10u2debCVE-2020-21913Medium
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u7,deb,CVE-2022-29155,Critical,2022-05-04T20:15:07.690,"'In OpenLDAP 2.x before 2.5.12 and 2.6.x before 2.6.2, a SQL injection vulnerability exists in the experimental back-sql backend to slapd, via a SQL statement within an LDAP query. This can occur during an LDAP search operation when the search filter is processed, due to a lack of proper escaping.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u7debCVE-2022-29155Critical
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u7,deb,CVE-2022-29155,Critical,2022-05-04T20:15:07.690,"'In OpenLDAP 2.x before 2.5.12 and 2.6.x before 2.6.2, a SQL injection vulnerability exists in the experimental back-sql backend to slapd, via a SQL statement within an LDAP query. This can occur during an LDAP search operation when the search filter is processed, due to a lack of proper escaping.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u7debCVE-2022-29155Critical
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,(won't fix),deb,CVE-2023-2953,High,2023-05-30T22:15:10.613,'A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.',libldap-2.4-22.4.47+dfsg-3+deb10u2(won't fix)debCVE-2023-2953High
libldap-common,2.4.47+dfsg-3+deb10u2,(won't fix),deb,CVE-2023-2953,High,2023-05-30T22:15:10.613,'A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.',libldap-common2.4.47+dfsg-3+deb10u2(won't fix)debCVE-2023-2953High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u6,deb,CVE-2021-27212,High,2021-02-14T03:15:12.957,"'In OpenLDAP through 2.4.57 and 2.5.x through 2.5.1alpha, an assertion failure in slapd can occur in the issuerAndThisUpdateCheck function via a crafted packet, resulting in a denial of service (daemon exit) via a short timestamp. This is related to schema_init.c and checkTime.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u6debCVE-2021-27212High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u6,deb,CVE-2021-27212,High,2021-02-14T03:15:12.957,"'In OpenLDAP through 2.4.57 and 2.5.x through 2.5.1alpha, an assertion failure in slapd can occur in the issuerAndThisUpdateCheck function via a crafted packet, resulting in a denial of service (daemon exit) via a short timestamp. This is related to schema_init.c and checkTime.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u6debCVE-2021-27212High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36230,High,2021-01-26T18:15:57.350,"'A flaw was discovered in OpenLDAP before 2.4.57 leading in an assertion failure in slapd in the X.509 DN parsing in decode.c ber_next_element, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36230High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36230,High,2021-01-26T18:15:57.350,"'A flaw was discovered in OpenLDAP before 2.4.57 leading in an assertion failure in slapd in the X.509 DN parsing in decode.c ber_next_element, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36230High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36229,High,2021-01-26T18:15:57.287,"'A flaw was discovered in ldap_X509dn2bv in OpenLDAP before 2.4.57 leading to a slapd crash in the X.509 DN parsing in ad_keystring, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36229High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36229,High,2021-01-26T18:15:57.287,"'A flaw was discovered in ldap_X509dn2bv in OpenLDAP before 2.4.57 leading to a slapd crash in the X.509 DN parsing in ad_keystring, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36229High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36228,High,2021-01-26T18:15:57.223,"'An integer underflow was discovered in OpenLDAP before 2.4.57 leading to a slapd crash in the Certificate List Exact Assertion processing, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36228High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36228,High,2021-01-26T18:15:57.223,"'An integer underflow was discovered in OpenLDAP before 2.4.57 leading to a slapd crash in the Certificate List Exact Assertion processing, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36228High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36227,High,2021-01-26T18:15:57.160,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an infinite loop in slapd with the cancel_extop Cancel operation, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36227High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36227,High,2021-01-26T18:15:57.160,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an infinite loop in slapd with the cancel_extop Cancel operation, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36227High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36226,High,2021-01-26T18:15:57.100,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a memch->bv_len miscalculation and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36226High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36226,High,2021-01-26T18:15:57.100,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a memch->bv_len miscalculation and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36226High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36225,High,2021-01-26T18:15:57.037,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a double free and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36225High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36225,High,2021-01-26T18:15:57.037,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a double free and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36225High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36224,High,2021-01-26T18:15:56.973,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an invalid pointer free and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36224High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36224,High,2021-01-26T18:15:56.973,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an invalid pointer free and slapd crash in the saslAuthzTo processing, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36224High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36223,High,2021-01-26T18:15:56.867,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a slapd crash in the Values Return Filter control handling, resulting in denial of service (double free and out-of-bounds read).'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36223High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36223,High,2021-01-26T18:15:56.867,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to a slapd crash in the Values Return Filter control handling, resulting in denial of service (double free and out-of-bounds read).'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36223High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36222,High,2021-01-26T18:15:56.770,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an assertion failure in slapd in the saslAuthzTo validation, resulting in denial of service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36222High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36222,High,2021-01-26T18:15:56.770,"'A flaw was discovered in OpenLDAP before 2.4.57 leading to an assertion failure in slapd in the saslAuthzTo validation, resulting in denial of service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36222High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36221,High,2021-01-26T18:15:56.693,"'An integer underflow was discovered in OpenLDAP before 2.4.57 leading to slapd crashes in the Certificate Exact Assertion processing, resulting in denial of service (schema_init.c serialNumberAndIssuerCheck).'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36221High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u5,deb,CVE-2020-36221,High,2021-01-26T18:15:56.693,"'An integer underflow was discovered in OpenLDAP before 2.4.57 leading to slapd crashes in the Certificate Exact Assertion processing, resulting in denial of service (schema_init.c serialNumberAndIssuerCheck).'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u5debCVE-2020-36221High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u4,deb,CVE-2020-25710,High,2021-05-28T11:15:07.593,'A flaw was found in OpenLDAP in versions before 2.4.56. This flaw allows an attacker who sends a malicious packet processed by OpenLDAP to force a failed assertion in csnNormalize23(). The highest threat from this vulnerability is to system availability.',libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u4debCVE-2020-25710High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u4,deb,CVE-2020-25710,High,2021-05-28T11:15:07.593,'A flaw was found in OpenLDAP in versions before 2.4.56. This flaw allows an attacker who sends a malicious packet processed by OpenLDAP to force a failed assertion in csnNormalize23(). The highest threat from this vulnerability is to system availability.',libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u4debCVE-2020-25710High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u4,deb,CVE-2020-25709,High,2021-05-18T12:15:07.673,"'A flaw was found in OpenLDAP. This flaw allows an attacker who can send a malicious packet to be processed by OpenLDAPs slapd server, to trigger an assertion failure. The highest threat from this vulnerability is to system availability.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u4debCVE-2020-25709High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u4,deb,CVE-2020-25709,High,2021-05-18T12:15:07.673,"'A flaw was found in OpenLDAP. This flaw allows an attacker who can send a malicious packet to be processed by OpenLDAPs slapd server, to trigger an assertion failure. The highest threat from this vulnerability is to system availability.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u4debCVE-2020-25709High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u3,deb,CVE-2020-25692,High,2020-12-08T01:15:12.133,"'A NULL pointer dereference was found in OpenLDAP server and was fixed in openldap 2.4.55, during a request for renaming RDNs. An unauthenticated attacker could remotely crash the slapd process by sending a specially crafted request, causing a Denial of Service.'",libldap-2.4-22.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u3debCVE-2020-25692High
libldap-common,2.4.47+dfsg-3+deb10u2,2.4.47+dfsg-3+deb10u3,deb,CVE-2020-25692,High,2020-12-08T01:15:12.133,"'A NULL pointer dereference was found in OpenLDAP server and was fixed in openldap 2.4.55, during a request for renaming RDNs. An unauthenticated attacker could remotely crash the slapd process by sending a specially crafted request, causing a Denial of Service.'",libldap-common2.4.47+dfsg-3+deb10u22.4.47+dfsg-3+deb10u3debCVE-2020-25692High
libldap-2.4-2,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2020-15719,Negligible,2020-07-14T14:15:17.667,"'libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.'",libldap-2.4-22.4.47+dfsg-3+deb10u2 debCVE-2020-15719Negligible
libldap-common,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2020-15719,Negligible,2020-07-14T14:15:17.667,"'libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.'",libldap-common2.4.47+dfsg-3+deb10u2 debCVE-2020-15719Negligible
libldap-2.4-2,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2017-17740,Negligible,2017-12-18T06:29:00.397,"'contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45, when both the nops module and the memberof overlay are enabled, attempts to free a buffer that was allocated on the stack, which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.'",libldap-2.4-22.4.47+dfsg-3+deb10u2 debCVE-2017-17740Negligible
libldap-common,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2017-17740,Negligible,2017-12-18T06:29:00.397,"'contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45, when both the nops module and the memberof overlay are enabled, attempts to free a buffer that was allocated on the stack, which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.'",libldap-common2.4.47+dfsg-3+deb10u2 debCVE-2017-17740Negligible
libldap-2.4-2,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2017-14159,Negligible,2017-09-05T18:29:00.133,"'slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a ""kill `cat /pathname`"" command, as demonstrated by openldap-initscript.'",libldap-2.4-22.4.47+dfsg-3+deb10u2 debCVE-2017-14159Negligible
libldap-common,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2017-14159,Negligible,2017-09-05T18:29:00.133,"'slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a ""kill `cat /pathname`"" command, as demonstrated by openldap-initscript.'",libldap-common2.4.47+dfsg-3+deb10u2 debCVE-2017-14159Negligible
libldap-2.4-2,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2015-3276,Negligible,2015-12-07T20:59:03.023,"'The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings, which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.'",libldap-2.4-22.4.47+dfsg-3+deb10u2 debCVE-2015-3276Negligible
libldap-common,2.4.47+dfsg-3+deb10u2, ,deb,CVE-2015-3276,Negligible,2015-12-07T20:59:03.023,"'The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings, which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.'",libldap-common2.4.47+dfsg-3+deb10u2 debCVE-2015-3276Negligible
libnghttp2-14,1.36.0-2+deb10u1,1.36.0-2+deb10u2,deb,CVE-2020-11080,High,2020-06-03T23:15:11.073,"'In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.'",libnghttp2-141.36.0-2+deb10u11.36.0-2+deb10u2debCVE-2020-11080High
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u4,deb,CVE-2021-43527,Critical,2021-12-08T22:15:09.163,"'NSS (Network Security Services) versions prior to 3.73 or 3.68.1 ESR are vulnerable to a heap overflow when handling DER-encoded DSA or RSA-PSS signatures. Applications using NSS for handling signatures encoded within CMS, S/MIME, PKCS \\#7, or PKCS \\#12 are likely to be impacted. Applications using NSS for certificate validation or other TLS, X.509, OCSP or CRL functionality may be impacted, depending on how they configure NSS. *Note: This vulnerability does NOT impact Mozilla Firefox.* However, email clients and PDF viewers that use NSS for signature verification, such as Thunderbird, LibreOffice, Evolution and Evince are believed to be impacted. This vulnerability affects NSS < 3.73 and NSS < 3.68.1.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u4debCVE-2021-43527Critical
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u6,deb,CVE-2020-12403,Critical,2021-05-27T19:15:07.953,"'A flaw was found in the way CHACHA20-POLY1305 was implemented in NSS in versions before 3.55. When using multi-part Chacha20, it could cause out-of-bounds reads. This issue was fixed by explicitly disabling multi-part ChaCha20 (which was not functioning correctly) and strictly enforcing tag length. The highest threat from this vulnerability is to confidentiality and system availability.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u6debCVE-2020-12403Critical
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u6,deb,CVE-2023-0767,High,2023-06-02T17:15:10.440,"'An attacker could construct a PKCS 12 cert bundle in such a way that could allow for arbitrary memory writes via PKCS 12 Safe Bag attributes being mishandled. This vulnerability affects Firefox < 110, Thunderbird < 102.8, and Firefox ESR < 102.8.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u6debCVE-2023-0767High
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u7,deb,CVE-2020-25648,High,2020-10-20T22:15:43.217,"'A flaw was found in the way NSS handled CCS (ChangeCipherSpec) messages in TLS 1.3. This flaw allows a remote attacker to send multiple CCS messages, causing a denial of service for servers compiled with the NSS library. The highest threat from this vulnerability is to system availability. This flaw affects NSS versions before 3.58.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u7debCVE-2020-25648High
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u5,deb,CVE-2022-22747,Medium,2022-12-22T20:15:16.087,"'After accepting an untrusted certificate, handling an empty pkcs7 sequence as part of the certificate data could have lead to a crash. This crash is believed to be unexploitable. This vulnerability affects Firefox ESR < 91.5, Firefox < 96, and Thunderbird < 91.5.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u5debCVE-2022-22747Medium
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u6,deb,CVE-2020-6829,Medium,2020-10-28T12:15:12.407,"'When performing EC scalar point multiplication, the wNAF point multiplication algorithm was used; which leaked partial information about the nonce used during signature generation. Given an electro-magnetic trace of a few signature generations, the private key could have been computed. This vulnerability affects Firefox < 80 and Firefox for Android < 80.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u6debCVE-2020-6829Medium
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u6,deb,CVE-2020-12401,Medium,2020-10-08T14:15:11.250,"'During ECDSA signature generation, padding applied in the nonce designed to ensure constant-time scalar multiplication was removed, resulting in variable-time execution dependent on secret data. This vulnerability affects Firefox < 80 and Firefox for Android < 80.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u6debCVE-2020-12401Medium
libnss3,2:3.42.1-1+deb10u3,2:3.42.1-1+deb10u6,deb,CVE-2020-12400,Medium,2020-10-08T14:15:11.170,"'When converting coordinates from projective to affine, the modular inversion was not performed in constant time, resulting in a possible timing-based side channel attack. This vulnerability affects Firefox < 80 and Firefox for Android < 80.'",libnss32:3.42.1-1+deb10u32:3.42.1-1+deb10u6debCVE-2020-12400Medium
libnss3,2:3.42.1-1+deb10u3, ,deb,CVE-2017-11698,Negligible,2017-12-27T19:29:00.660,'Heap-based buffer overflow in the __get_page function in lib/dbm/src/h_page.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file.',libnss32:3.42.1-1+deb10u3 debCVE-2017-11698Negligible
libnss3,2:3.42.1-1+deb10u3, ,deb,CVE-2017-11697,Negligible,2017-12-27T19:29:00.613,'The __hash_open function in hash.c:229 in Mozilla Network Security Services (NSS) allows context-dependent attackers to cause a denial of service (floating point exception and crash) via a crafted cert8.db file.',libnss32:3.42.1-1+deb10u3 debCVE-2017-11697Negligible
libnss3,2:3.42.1-1+deb10u3, ,deb,CVE-2017-11696,Negligible,2017-12-27T19:29:00.567,'Heap-based buffer overflow in the __hash_open function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file.',libnss32:3.42.1-1+deb10u3 debCVE-2017-11696Negligible
libnss3,2:3.42.1-1+deb10u3, ,deb,CVE-2017-11695,Negligible,2017-12-27T19:29:00.503,'Heap-based buffer overflow in the alloc_segs function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file.',libnss32:3.42.1-1+deb10u3 debCVE-2017-11695Negligible
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-19246,Low,2019-11-25T17:15:11.887,"'Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.'",libonig56.9.1-1(won't fix)debCVE-2019-19246Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-19204,Low,2019-11-21T21:15:11.577,"'An issue was discovered in Oniguruma 6.x before 6.9.4_rc2. In the function fetch_interval_quantifier (formerly known as fetch_range_quantifier) in regparse.c, PFETCH is called without checking PEND. This leads to a heap-based buffer over-read.'",libonig56.9.1-1(won't fix)debCVE-2019-19204Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-19203,Low,2019-11-21T21:15:11.497,"'An issue was discovered in Oniguruma 6.x before 6.9.4_rc2. In the function gb18030_mbc_enc_len in file gb18030.c, a UChar pointer is dereferenced without checking if it passed the end of the matched string. This leads to a heap-based buffer over-read.'",libonig56.9.1-1(won't fix)debCVE-2019-19203Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-19012,Low,2019-11-17T18:15:11.440,"'An integer overflow in the search_in_range function in regexec.c in Oniguruma 6.x before 6.9.4_rc2 leads to an out-of-bounds read, in which the offset of this read is under the control of an attacker. (This only affects the 32-bit compiled version). Remote attackers can cause a denial-of-service or information disclosure, or possibly have unspecified other impact, via a crafted regular expression.'",libonig56.9.1-1(won't fix)debCVE-2019-19012Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-16163,Low,2019-09-09T17:15:13.347,'Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.',libonig56.9.1-1(won't fix)debCVE-2019-16163Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-13225,Low,2019-07-10T14:15:11.700,"'A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.'",libonig56.9.1-1(won't fix)debCVE-2019-13225Low
libonig5,6.9.1-1,(won't fix),deb,CVE-2019-13224,Low,2019-07-10T14:15:11.607,"'A use-after-free in onig_new_deluxe() in regext.c in Oniguruma 6.9.2 allows attackers to potentially cause information disclosure, denial of service, or possibly code execution by providing a crafted regular expression. The attacker provides a pair of a regex pattern and a string, with a multi-byte encoding that gets handled by onig_new_deluxe(). Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.'",libonig56.9.1-1(won't fix)debCVE-2019-13224Low
libpcre2-8-0,10.32-5,10.32-5+deb10u1,deb,CVE-2019-20454,High,2020-02-14T14:15:10.593,"'An out-of-bounds read was discovered in PCRE before 10.34 when the pattern \\X is JIT compiled and used to match specially crafted subjects in non-UTF mode. Applications that use PCRE to parse untrusted input may be vulnerable to this flaw, which would allow an attacker to crash the application. The flaw occurs in do_extuni_no_utf in pcre2_jit_compile.c.'",libpcre2-8-010.32-510.32-5+deb10u1debCVE-2019-20454High
libpython-stdlib,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',libpython-stdlib2.7.16-1 debCVE-2008-4108Negligible
libpython2-stdlib,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',libpython2-stdlib2.7.16-1 debCVE-2008-4108Negligible
python,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',python2.7.16-1 debCVE-2008-4108Negligible
python-minimal,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',python-minimal2.7.16-1 debCVE-2008-4108Negligible
python2,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',python22.7.16-1 debCVE-2008-4108Negligible
python2-minimal,2.7.16-1, ,deb,CVE-2008-4108,Negligible,2008-09-18T17:59:33.093,'Tools/faqwiz/move-faqwiz.sh (aka the generic FAQ wizard moving tool) in Python 2.4.5 might allow local users to overwrite arbitrary files via a symlink attack on a tmp$RANDOM.tmp temporary file.  NOTE: there may not be common usage scenarios in which tmp$RANDOM.tmp is located in an untrusted directory.',python2-minimal2.7.16-1 debCVE-2008-4108Negligible
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48565Critical
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48565Critical
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48565Critical
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48565Critical
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48565Critical
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48565Critical
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48565Critical
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48565Critical
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',python3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48565Critical
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48565,Critical,2023-08-22T19:16:32.007,'An XML External Entity (XXE) issue was discovered in Python through 3.9.1. The plistlib module no longer accepts entity declarations in XML plist files to avoid XML vulnerabilities.',python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48565Critical
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3177Critical
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3177Critical
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3177Critical
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2021-3177Critical
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2021-3177Critical
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2021-3177Critical
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3177Critical
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3177Critical
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",python3.73.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2021-3177Critical
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2021-3177,Critical,2021-01-19T06:15:12.967,"'Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2021-3177Critical
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-24329High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-24329High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-24329High
libpython3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython3.73.7.3-2+deb10u2(won't fix)debCVE-2023-24329High
libpython3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2023-24329High
libpython3.7-stdlib,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',libpython3.7-stdlib3.7.3-2+deb10u2(won't fix)debCVE-2023-24329High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-24329High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-24329High
python3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',python3.73.7.3-2+deb10u2(won't fix)debCVE-2023-24329High
python3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-24329,High,2023-02-17T15:15:12.243,'An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.',python3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2023-24329High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48560High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48560High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48560High
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48560High
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48560High
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48560High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48560High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48560High
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',python3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48560High
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48560,High,2023-08-22T19:16:31.827,'A use-after-free exists in Python through 3.9 via heappushpop in heapq.',python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48560High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-0391High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-0391High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-0391High
libpython3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython3.73.7.3-2+deb10u2(won't fix)debCVE-2022-0391High
libpython3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2022-0391High
libpython3.7-stdlib,3.7.3-2+deb10u2,(won't fix),deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",libpython3.7-stdlib3.7.3-2+deb10u2(won't fix)debCVE-2022-0391High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-0391High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-0391High
python3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",python3.73.7.3-2+deb10u2(won't fix)debCVE-2022-0391High
python3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2022-0391,High,2022-02-09T23:15:16.580,"""A flaw was found in Python, specifically within the urllib.parse module. This module helps break Uniform Resource Locator (URL) strings into components. The issue involves how the urlparse method does not sanitize input and allows characters like '\\r' and '\\n' in the URL path. This flaw allows an attacker to input a crafted URL, leading to injection attacks. This flaw affects Python versions prior to 3.10.0b1, 3.9.5, 3.8.11, 3.7.11 and 3.6.14.""",python3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2022-0391High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3737High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3737High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3737High
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3737High
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3737High
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3737High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3737High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3737High
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3737High
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3737,High,2022-03-04T19:15:08.730,"'A flaw was found in python. An improperly handled HTTP response in the HTTP client code of python may allow a remote attacker, who controls the HTTP server, to make the client script enter an infinite loop, consuming CPU time. The highest threat from this vulnerability is to system availability.'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3737High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-26116High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-26116High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-26116High
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2020-26116High
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2020-26116High
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2020-26116High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-26116High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-26116High
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",python3.73.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2020-26116High
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u3,deb,CVE-2020-26116,High,2020-09-27T04:15:11.587,"'http.client in Python 3.x before 3.5.10, 3.6.x before 3.6.12, 3.7.x before 3.7.9, and 3.8.x before 3.8.5 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of HTTPConnection.request.'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u3debCVE-2020-26116High
libpython2.7,2.7.16-2+deb10u1,(won't fix),deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython2.72.7.16-2+deb10u1(won't fix)debCVE-2020-10735High
libpython2.7-minimal,2.7.16-2+deb10u1,(won't fix),deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython2.7-minimal2.7.16-2+deb10u1(won't fix)debCVE-2020-10735High
libpython2.7-stdlib,2.7.16-2+deb10u1,(won't fix),deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython2.7-stdlib2.7.16-2+deb10u1(won't fix)debCVE-2020-10735High
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2020-10735High
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2020-10735High
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2020-10735High
python2.7,2.7.16-2+deb10u1,(won't fix),deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",python2.72.7.16-2+deb10u1(won't fix)debCVE-2020-10735High
python2.7-minimal,2.7.16-2+deb10u1,(won't fix),deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",python2.7-minimal2.7.16-2+deb10u1(won't fix)debCVE-2020-10735High
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2020-10735High
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2020-10735,High,2022-09-09T14:15:08.660,"'A flaw was found in python. In algorithms with quadratic time complexity using non-binary bases, when using int(""text""), a system could take 50ms to parse an int string with 100,000 digits and 5s for 1,000,000 digits (float, decimal, int.from_bytes(), and int() for binary bases 2, 4, 8, 16, and 32 are not affected). The highest threat from this vulnerability is to system availability.'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2020-10735High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2019-20907,High,2020-07-13T13:15:10.763,"'In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2019-20907High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2019-20907,High,2020-07-13T13:15:10.763,"'In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2019-20907High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2019-20907,High,2020-07-13T13:15:10.763,"'In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2019-20907High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2019-20907,High,2020-07-13T13:15:10.763,"'In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2019-20907High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2019-20907,High,2020-07-13T13:15:10.763,"'In Lib/tarfile.py in Python through 3.8.3, an attacker is able to craft a TAR archive leading to an infinite loop when opened by tarfile.open, because _proc_pax lacks header validation.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2019-20907High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2015-20107High
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2015-20107High
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2015-20107High
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2015-20107High
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2015-20107High
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2015-20107High
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2015-20107High
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2015-20107High
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2015-20107High
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2015-20107,High,2022-04-13T16:15:08.937,"'In Python (aka CPython) up to 3.10.8, the mailcap module does not add escape characters into commands discovered in the system mailcap file. This may allow attackers to inject shell commands into applications that call mailcap.findmatch with untrusted input (if they lack validation of user-provided filenames or arguments). The fix is also back-ported to 3.7, 3.8, 3.9'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2015-20107High
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-40217Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-40217Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-40217Medium
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2023-40217Medium
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2023-40217Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2023-40217Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-40217Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2023-40217Medium
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",python3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2023-40217Medium
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2023-40217,Medium,2023-08-25T01:15:09.017,"'An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as ""not connected"" and won\'t initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2023-40217Medium
libpython2.7,2.7.16-2+deb10u1,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython2.72.7.16-2+deb10u1(won't fix)debCVE-2023-27043Medium
libpython2.7-minimal,2.7.16-2+deb10u1,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython2.7-minimal2.7.16-2+deb10u1(won't fix)debCVE-2023-27043Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython2.7-stdlib2.7.16-2+deb10u1(won't fix)debCVE-2023-27043Medium
libpython3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython3.73.7.3-2+deb10u2(won't fix)debCVE-2023-27043Medium
libpython3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2023-27043Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",libpython3.7-stdlib3.7.3-2+deb10u2(won't fix)debCVE-2023-27043Medium
python2.7,2.7.16-2+deb10u1,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",python2.72.7.16-2+deb10u1(won't fix)debCVE-2023-27043Medium
python2.7-minimal,2.7.16-2+deb10u1,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",python2.7-minimal2.7.16-2+deb10u1(won't fix)debCVE-2023-27043Medium
python3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",python3.73.7.3-2+deb10u2(won't fix)debCVE-2023-27043Medium
python3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2023-27043,Medium,2023-04-19T00:15:07.973,"'The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.'",python3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2023-27043Medium
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48566Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48566Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48566Medium
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48566Medium
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48566Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48566Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48566Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2022-48566Medium
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',python3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48566Medium
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48566,Medium,2023-08-22T19:16:32.087,'An issue was discovered in compare_digest in Lib/hmac.py in Python through 3.9.1. Constant-time-defeating optimisations were possible in the accumulator variable in hmac.compare_digest.',python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48566Medium
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-4189Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-4189Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-4189Medium
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-4189Medium
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-4189Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-4189Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-4189Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-4189Medium
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-4189Medium
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-4189,Medium,2022-08-24T16:15:09.827,"'A flaw was found in Python, specifically in the FTP (File Transfer Protocol) client library in PASV (passive) mode. The issue is how the FTP client trusts the host from the PASV response by default. This flaw allows an attacker to set up a malicious FTP server that can trick FTP clients into connecting back to a given IP address and port. This vulnerability could lead to FTP client scanning ports, which otherwise would not have been possible.'",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-4189Medium
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3733Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3733Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3733Medium
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3733Medium
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3733Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3733Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3733Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2021-3733Medium
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3733Medium
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3733,Medium,2022-03-10T17:42:59.623,"""There's a flaw in urllib's AbstractBasicAuthHandler class. An attacker who controls a malicious HTTP server that an HTTP client (such as web browser) connects to, could trigger a Regular Expression Denial of Service (ReDOS) during an authentication request with a specially crafted payload that is sent by the server to the client. The greatest threat that this flaw poses is to application availability.""",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3733Medium
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2021-23336Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2021-23336Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2021-23336Medium
libpython3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython3.73.7.3-2+deb10u2(won't fix)debCVE-2021-23336Medium
libpython3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2021-23336Medium
libpython3.7-stdlib,3.7.3-2+deb10u2,(won't fix),deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",libpython3.7-stdlib3.7.3-2+deb10u2(won't fix)debCVE-2021-23336Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2021-23336Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u3,deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u3debCVE-2021-23336Medium
python3.7,3.7.3-2+deb10u2,(won't fix),deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",python3.73.7.3-2+deb10u2(won't fix)debCVE-2021-23336Medium
python3.7-minimal,3.7.3-2+deb10u2,(won't fix),deb,CVE-2021-23336,Medium,2021-02-15T13:15:12.433,"'The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.'",python3.7-minimal3.7.3-2+deb10u2(won't fix)debCVE-2021-23336Medium
libpython2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-8492,Medium,2020-01-30T19:15:12.103,"'Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.'",libpython2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-8492Medium
libpython2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-8492,Medium,2020-01-30T19:15:12.103,"'Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.'",libpython2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-8492Medium
libpython2.7-stdlib,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-8492,Medium,2020-01-30T19:15:12.103,"'Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.'",libpython2.7-stdlib2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-8492Medium
python2.7,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-8492,Medium,2020-01-30T19:15:12.103,"'Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.'",python2.72.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-8492Medium
python2.7-minimal,2.7.16-2+deb10u1,2.7.16-2+deb10u2,deb,CVE-2020-8492,Medium,2020-01-30T19:15:12.103,"'Python 2.7 through 2.7.17, 3.5 through 3.5.9, 3.6 through 3.6.10, 3.7 through 3.7.6, and 3.8 through 3.8.1 allows an HTTP server to conduct Regular Expression Denial of Service (ReDoS) attacks against a client because of urllib.request.AbstractBasicAuthHandler catastrophic backtracking.'",python2.7-minimal2.7.16-2+deb10u12.7.16-2+deb10u2debCVE-2020-8492Medium
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython2.72.7.16-2+deb10u1 debCVE-2023-24535Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2023-24535Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2023-24535Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython3.73.7.3-2+deb10u2 debCVE-2023-24535Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2023-24535Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2023-24535Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",python2.72.7.16-2+deb10u1 debCVE-2023-24535Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2023-24535Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",python3.73.7.3-2+deb10u2 debCVE-2023-24535Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2023-24535,Negligible,2023-06-08T21:15:16.420,"'Parsing invalid messages can panic. Parsing a text-format message which contains a potential number consisting of a minus sign, one or more characters of whitespace, and no further input will cause a panic.'",python3.7-minimal3.7.3-2+deb10u2 debCVE-2023-24535Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython2.72.7.16-2+deb10u1 debCVE-2021-28861Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2021-28861Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2021-28861Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython3.73.7.3-2+deb10u2 debCVE-2021-28861Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2021-28861Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2021-28861Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",python2.72.7.16-2+deb10u1 debCVE-2021-28861Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2021-28861Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",python3.73.7.3-2+deb10u2 debCVE-2021-28861Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2021-28861,Negligible,2022-08-23T01:15:07.617,"'Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states ""Warning: http.server is not recommended for production. It only implements basic security checks.""'",python3.7-minimal3.7.3-2+deb10u2 debCVE-2021-28861Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython2.72.7.16-2+deb10u1 debCVE-2020-27619Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2020-27619Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2020-27619Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython3.73.7.3-2+deb10u2 debCVE-2020-27619Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2020-27619Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2020-27619Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",python2.72.7.16-2+deb10u1 debCVE-2020-27619Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2020-27619Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",python3.73.7.3-2+deb10u2 debCVE-2020-27619Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2020-27619,Negligible,2020-10-22T03:16:31.010,"'In Python 3 through 3.9.0, the Lib/test/multibytecodec_support.py CJK codec tests call eval() on content retrieved via HTTP.'",python3.7-minimal3.7.3-2+deb10u2 debCVE-2020-27619Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython2.72.7.16-2+deb10u1 debCVE-2019-9674Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2019-9674Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2019-9674Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython3.73.7.3-2+deb10u2 debCVE-2019-9674Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2019-9674Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2019-9674Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',python2.72.7.16-2+deb10u1 debCVE-2019-9674Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',python2.7-minimal2.7.16-2+deb10u1 debCVE-2019-9674Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',python3.73.7.3-2+deb10u2 debCVE-2019-9674Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2019-9674,Negligible,2020-02-04T15:15:11.633,'Lib/zipfile.py in Python through 3.7.2 allows remote attackers to cause a denial of service (resource consumption) via a ZIP bomb.',python3.7-minimal3.7.3-2+deb10u2 debCVE-2019-9674Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython2.72.7.16-2+deb10u1 debCVE-2019-18348Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2019-18348Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2019-18348Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython3.73.7.3-2+deb10u2 debCVE-2019-18348Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2019-18348Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2019-18348Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",python2.72.7.16-2+deb10u1 debCVE-2019-18348Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2019-18348Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",python3.73.7.3-2+deb10u2 debCVE-2019-18348Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2019-18348,Negligible,2019-10-23T17:15:12.973,"'An issue was discovered in urllib2 in Python 2.x through 2.7.17 and urllib in Python 3.x through 3.8.0. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the first argument to urllib.request.urlopen with \\r\\n (specifically in the host component of a URL) followed by an HTTP header. This is similar to the CVE-2019-9740 query string issue and the CVE-2019-9947 path string issue. (This is not exploitable when glibc has CVE-2016-10739 fixed.). This is fixed in: v2.7.18, v2.7.18rc1; v3.5.10, v3.5.10rc1; v3.6.11, v3.6.11rc1, v3.6.12; v3.7.8, v3.7.8rc1, v3.7.9; v3.8.3, v3.8.3rc1, v3.8.4, v3.8.4rc1, v3.8.5, v3.8.6, v3.8.6rc1.'",python3.7-minimal3.7.3-2+deb10u2 debCVE-2019-18348Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython2.72.7.16-2+deb10u1 debCVE-2017-17522Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2017-17522Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2017-17522Negligible
libpython3.7,3.7.3-2+deb10u2, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython3.73.7.3-2+deb10u2 debCVE-2017-17522Negligible
libpython3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython3.7-minimal3.7.3-2+deb10u2 debCVE-2017-17522Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",libpython3.7-stdlib3.7.3-2+deb10u2 debCVE-2017-17522Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",python2.72.7.16-2+deb10u1 debCVE-2017-17522Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2017-17522Negligible
python3.7,3.7.3-2+deb10u2, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",python3.73.7.3-2+deb10u2 debCVE-2017-17522Negligible
python3.7-minimal,3.7.3-2+deb10u2, ,deb,CVE-2017-17522,Negligible,2017-12-14T16:29:00.713,"'Lib/webbrowser.py in Python through 3.6.3 does not validate strings before launching the program specified by the BROWSER environment variable, which might allow remote attackers to conduct argument-injection attacks via a crafted URL. NOTE: a software maintainer indicates that exploitation is impossible because the code relies on subprocess.Popen and the default shell=False setting'",python3.7-minimal3.7.3-2+deb10u2 debCVE-2017-17522Negligible
libpython2.7,2.7.16-2+deb10u1, ,deb,CVE-2013-7040,Negligible,2014-05-19T14:55:09.987,"'Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.'",libpython2.72.7.16-2+deb10u1 debCVE-2013-7040Negligible
libpython2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2013-7040,Negligible,2014-05-19T14:55:09.987,"'Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.'",libpython2.7-minimal2.7.16-2+deb10u1 debCVE-2013-7040Negligible
libpython2.7-stdlib,2.7.16-2+deb10u1, ,deb,CVE-2013-7040,Negligible,2014-05-19T14:55:09.987,"'Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.'",libpython2.7-stdlib2.7.16-2+deb10u1 debCVE-2013-7040Negligible
python2.7,2.7.16-2+deb10u1, ,deb,CVE-2013-7040,Negligible,2014-05-19T14:55:09.987,"'Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.'",python2.72.7.16-2+deb10u1 debCVE-2013-7040Negligible
python2.7-minimal,2.7.16-2+deb10u1, ,deb,CVE-2013-7040,Negligible,2014-05-19T14:55:09.987,"'Python 2.7 before 3.4 only uses the last eight bits of the prefix to randomize hash values, which causes it to compute hash values without restricting the ability to trigger hash collisions predictably and makes it easier for context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1150.'",python2.7-minimal2.7.16-2+deb10u1 debCVE-2013-7040Negligible
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48564,Negligible,2023-08-22T19:16:31.927,'read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.',libpython3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48564Negligible
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48564,Negligible,2023-08-22T19:16:31.927,'read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.',libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48564Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48564,Negligible,2023-08-22T19:16:31.927,'read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.',libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48564Negligible
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48564,Negligible,2023-08-22T19:16:31.927,'read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.',python3.73.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48564Negligible
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u6,deb,CVE-2022-48564,Negligible,2023-08-22T19:16:31.927,'read_ints in plistlib.py in Python through 3.9.1 is vulnerable to a potential DoS attack via CPU and RAM exhaustion when processing malformed Apple Property List files in binary format.',python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u6debCVE-2022-48564Negligible
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u4,deb,CVE-2022-37454,Negligible,2022-10-21T06:15:09.333,'The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.',libpython3.73.7.3-2+deb10u23.7.3-2+deb10u4debCVE-2022-37454Negligible
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u4,deb,CVE-2022-37454,Negligible,2022-10-21T06:15:09.333,'The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.',libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u4debCVE-2022-37454Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u4,deb,CVE-2022-37454,Negligible,2022-10-21T06:15:09.333,'The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.',libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u4debCVE-2022-37454Negligible
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u4,deb,CVE-2022-37454,Negligible,2022-10-21T06:15:09.333,'The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.',python3.73.7.3-2+deb10u23.7.3-2+deb10u4debCVE-2022-37454Negligible
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u4,deb,CVE-2022-37454,Negligible,2022-10-21T06:15:09.333,'The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.',python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u4debCVE-2022-37454Negligible
libpython3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3426,Negligible,2021-05-20T13:15:07.753,"""There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.""",libpython3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3426Negligible
libpython3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3426,Negligible,2021-05-20T13:15:07.753,"""There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.""",libpython3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3426Negligible
libpython3.7-stdlib,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3426,Negligible,2021-05-20T13:15:07.753,"""There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.""",libpython3.7-stdlib3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3426Negligible
python3.7,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3426,Negligible,2021-05-20T13:15:07.753,"""There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.""",python3.73.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3426Negligible
python3.7-minimal,3.7.3-2+deb10u2,3.7.3-2+deb10u5,deb,CVE-2021-3426,Negligible,2021-05-20T13:15:07.753,"""There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.""",python3.7-minimal3.7.3-2+deb10u23.7.3-2+deb10u5debCVE-2021-3426Negligible
libsasl2-2,2.1.27+dfsg-1+deb10u1,2.1.27+dfsg-1+deb10u2,deb,CVE-2022-24407,High,2022-02-24T15:15:29.350,"'In Cyrus SASL 2.1.17 through 2.1.27 before 2.1.28, plugins/sql.c does not escape the password for a SQL INSERT or UPDATE statement.'",libsasl2-22.1.27+dfsg-1+deb10u12.1.27+dfsg-1+deb10u2debCVE-2022-24407High
libsasl2-modules-db,2.1.27+dfsg-1+deb10u1,2.1.27+dfsg-1+deb10u2,deb,CVE-2022-24407,High,2022-02-24T15:15:29.350,"'In Cyrus SASL 2.1.17 through 2.1.27 before 2.1.28, plugins/sql.c does not escape the password for a SQL INSERT or UPDATE statement.'",libsasl2-modules-db2.1.27+dfsg-1+deb10u12.1.27+dfsg-1+deb10u2debCVE-2022-24407High
libsqlite3-0,3.27.2-3, ,deb,CVE-2022-35737,Negligible,2022-08-03T06:15:07.690,'SQLite 1.0.12 through 3.39.x before 3.39.2 sometimes allows an array-bounds overflow if billions of bytes are used in a string argument to a C API.',libsqlite3-03.27.2-3 debCVE-2022-35737Negligible
libsqlite3-0,3.27.2-3, ,deb,CVE-2021-45346,Negligible,2022-02-14T19:15:07.793,"'A Memory Leak vulnerability exists in SQLite Project SQLite3 3.35.1 and 3.37.0 via maliciously crafted SQL Queries (made via editing the Database File), it is possible to query a record, and leak subsequent bytes of memory that extend beyond the record, which could let a malicious user obtain sensitive information. NOTE: The developer disputes this as a vulnerability stating that If you give SQLite a corrupted database file and submit a query against the database, it might read parts of the database that you did not intend or expect.'",libsqlite3-03.27.2-3 debCVE-2021-45346Negligible
libsqlite3-0,3.27.2-3, ,deb,CVE-2021-36690,Negligible,2021-08-24T14:15:09.797,"'A segmentation fault can occur in the sqlite3.exe command-line component of SQLite 3.36.0 via the idxGetTableInfo function when there is a crafted SQL query. NOTE: the vendor disputes the relevance of this report because a sqlite3.exe user already has full privileges (e.g., is intentionally allowed to execute commands). This report does NOT imply any problem in the SQLite library.'",libsqlite3-03.27.2-3 debCVE-2021-36690Negligible
libsqlite3-0,3.27.2-3,(won't fix),deb,CVE-2021-31239,Negligible,2023-05-09T02:15:08.907,'An issue found in SQLite SQLite3 v.3.35.4 that allows a remote attacker to cause a denial of service via the appendvfs.c function.',libsqlite3-03.27.2-3(won't fix)debCVE-2021-31239Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u2,deb,CVE-2020-35527,Negligible,2022-09-01T18:15:08.637,"'In SQLite 3.31.1, there is an out of bounds access problem through ALTER TABLE for views that have a nested FROM clause.'",libsqlite3-03.27.2-33.27.2-3+deb10u2debCVE-2020-35527Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u2,deb,CVE-2020-35525,Negligible,2022-09-01T18:15:08.540,"'In SQlite 3.31.1, a potential null pointer derreference was found in the INTERSEC query processing.'",libsqlite3-03.27.2-33.27.2-3+deb10u2debCVE-2020-35525Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2020-15358,Negligible,2020-06-27T12:15:11.187,"'In SQLite before 3.32.3, select.c mishandles query-flattener optimization, leading to a multiSelectOrderBy heap overflow because of misuse of transitive properties for constant propagation.'",libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2020-15358Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2020-13632,Negligible,2020-05-27T15:15:13.007,'ext/fts3/fts3_snippet.c in SQLite before 3.32.0 has a NULL pointer dereference via a crafted matchinfo() query.',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2020-13632Negligible
libsqlite3-0,3.27.2-3,(won't fix),deb,CVE-2020-13631,Negligible,2020-05-27T15:15:12.947,"'SQLite before 3.32.0 allows a virtual table to be renamed to the name of one of its shadow tables, related to alter.c and build.c.'",libsqlite3-03.27.2-3(won't fix)debCVE-2020-13631Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2020-13630,Negligible,2020-05-27T15:15:12.867,"'ext/fts3/fts3.c in SQLite before 3.32.0 has a use-after-free in fts3EvalNextRow, related to the snippet feature.'",libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2020-13630Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2020-13435,Negligible,2020-05-24T22:15:10.460,'SQLite through 3.32.0 has a segmentation fault in sqlite3ExprCodeTarget in expr.c.',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2020-13435Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2020-13434,Negligible,2020-05-24T22:15:10.397,'SQLite through 3.32.0 has an integer overflow in sqlite3_str_vappendf in printf.c.',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2020-13434Negligible
libsqlite3-0,3.27.2-3, ,deb,CVE-2020-11656,Negligible,2020-04-09T03:15:11.410,"'In SQLite through 3.31.1, the ALTER TABLE implementation has a use-after-free, as demonstrated by an ORDER BY clause that belongs to a compound SELECT statement.'",libsqlite3-03.27.2-3 debCVE-2020-11656Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2019-20218,Negligible,2020-01-02T14:16:36.690,'selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2019-20218Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2019-19959,Negligible,2020-01-03T22:15:12.550,"""ext/misc/zipfile.c in SQLite 3.30.1 mishandles certain uses of INSERT INTO in situations involving embedded '\\0' characters in filenames, leading to a memory-management error that can be detected by (for example) valgrind.""",libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2019-19959Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2019-19925,Negligible,2019-12-24T17:15:10.927,'zipfileUpdate in ext/misc/zipfile.c in SQLite 3.30.1 mishandles a NULL pathname during an update of a ZIP archive.',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2019-19925Negligible
libsqlite3-0,3.27.2-3,(won't fix),deb,CVE-2019-19924,Negligible,2019-12-24T16:15:11.370,"'SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.'",libsqlite3-03.27.2-3(won't fix)debCVE-2019-19924Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2019-19923,Negligible,2019-12-24T16:15:11.260,'flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).',libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2019-19923Negligible
libsqlite3-0,3.27.2-3,(won't fix),deb,CVE-2019-19645,Negligible,2019-12-09T16:15:10.407,'alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.',libsqlite3-03.27.2-3(won't fix)debCVE-2019-19645Negligible
libsqlite3-0,3.27.2-3,(won't fix),deb,CVE-2019-19603,Negligible,2019-12-09T19:15:14.710,"'SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash.'",libsqlite3-03.27.2-3(won't fix)debCVE-2019-19603Negligible
libsqlite3-0,3.27.2-3, ,deb,CVE-2019-19244,Negligible,2019-11-25T20:15:11.407,"'sqlite3Select in select.c in SQLite 3.30.1 allows a crash if a sub-select uses both DISTINCT and window functions, and also has certain ORDER BY usage.'",libsqlite3-03.27.2-3 debCVE-2019-19244Negligible
libsqlite3-0,3.27.2-3,3.27.2-3+deb10u1,deb,CVE-2019-16168,Negligible,2019-09-09T17:15:13.910,"'In SQLite through 3.29.0, whereLoopAddBtreeIndex in sqlite3.c can crash a browser or other application because of missing validation of a sqlite_stat1 sz field, aka a ""severe division by zero in the query planner.""'",libsqlite3-03.27.2-33.27.2-3+deb10u1debCVE-2019-16168Negligible
libssh2-1,1.8.0-2.1,1.8.0-2.1+deb10u1,deb,CVE-2020-22218,High,2023-08-22T19:16:19.120,'An issue was discovered in function _libssh2_packet_add in libssh2 1.10.0 allows attackers to access out of bounds memory.',libssh2-11.8.0-2.11.8.0-2.1+deb10u1debCVE-2020-22218High
libssh2-1,1.8.0-2.1,1.8.0-2.1+deb10u1,deb,CVE-2019-17498,High,2019-10-21T22:15:10.523,"'In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.'",libssh2-11.8.0-2.11.8.0-2.1+deb10u1debCVE-2019-17498High
libssh2-1,1.8.0-2.1,1.8.0-2.1+deb10u1,deb,CVE-2019-13115,High,2019-07-16T18:15:13.287,"'In libssh2 before 1.9.0, kex_method_diffie_hellman_group_exchange_sha256_key_exchange in kex.c has an integer overflow that could lead to an out-of-bounds read in the way packets are read from the server. A remote attacker who compromises a SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server. This is related to an _libssh2_check_length mistake, and is different from the various issues fixed in 1.8.1, such as CVE-2019-3855.'",libssh2-11.8.0-2.11.8.0-2.1+deb10u1debCVE-2019-13115High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-45141,Critical,2023-03-06T23:15:11.157,"'Since the Windows Kerberos RC4-HMAC Elevation of Privilege Vulnerability was disclosed by Microsoft on Nov 8 2022 and per RFC8429 it is assumed that rc4-hmac is weak, Vulnerable Samba Active Directory DCs will issue rc4-hmac encrypted tickets despite the target server supporting better encryption (eg aes256-cts-hmac-sha1-96).'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-45141Critical
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-44640,Critical,2022-12-25T05:15:11.103,'Heimdal before 7.7.1 allows remote attackers to execute arbitrary code because of an invalid free in the ASN.1 codec used by the Key Distribution Center (KDC).',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-44640Critical
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-1472,Critical,2020-08-17T19:15:15.117,"""An elevation of privilege vulnerability exists when an attacker establishes a vulnerable Netlogon secure channel connection to a domain controller, using the Netlogon Remote Protocol (MS-NRPC), aka 'Netlogon Elevation of Privilege Vulnerability'.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-1472Critical
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2023-34966,High,2023-07-20T15:15:11.333,"""An infinite loop vulnerability was found in Samba's mdssvc RPC service for Spotlight. When parsing Spotlight mdssvc RPC packets sent by the client, the core unmarshalling function sl_unpack_loop() did not validate a field in the network packet that contains the count of elements in an array-like structure. By passing 0 as the count value, the attacked function will run in an endless loop consuming 100% CPU. This flaw allows an attacker to issue a malformed RPC request, triggering an infinite loop, resulting in a denial of service condition.""",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2023-34966High
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-38023,High,2022-11-09T22:15:16.203,'Netlogon RPC Elevation of Privilege Vulnerability',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-38023High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-37967,High,2022-11-09T22:15:14.590,'Windows Kerberos Elevation of Privilege Vulnerability',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-37967High
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-37966,High,2022-11-09T22:15:13.603,'Windows Kerberos RC4-HMAC Elevation of Privilege Vulnerability',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-37966High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-32744,High,2022-08-25T18:15:10.497,"""A flaw was found in Samba. The KDC accepts kpasswd requests encrypted with any key known to it. By encrypting forged kpasswd requests with its own key, a user can change other users' passwords, enabling full domain takeover.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-32744High
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-32743,High,2022-09-01T21:15:10.130,'Samba does not validate the Validated-DNS-Host-Name right for the dNSHostName attribute which could permit unprivileged users to write it.',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-32743High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-2031,High,2022-08-25T18:15:09.837,"""A flaw was found in Samba. The security vulnerability occurs when KDC and the kpasswd service share a single account and set of keys, allowing them to decrypt each other's tickets. A user who has been requested to change their password, can exploit this flaw to obtain and use tickets to other services.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-2031High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-0336,High,2022-08-29T15:15:09.250,"'The Samba AD DC includes checks when adding service principals names (SPNs) to an account to ensure that SPNs do not alias with those already in the database. Some of these checks are able to be bypassed if an account modification re-adds an SPN that was previously present on that account, such as one added when a computer is joined to a domain. An attacker who has the ability to write to an account can exploit this to perform a denial-of-service attack by adding an SPN that matches an existing service. Additionally, an attacker who can intercept traffic can impersonate existing services, resulting in a loss of confidentiality and integrity.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-0336High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u3,deb,CVE-2021-44142,High,2022-02-21T15:15:07.380,"'The Samba vfs_fruit module uses extended file attributes (EA, xattr) to provide ""...enhanced compatibility with Apple SMB clients and interoperability with a Netatalk 3 AFP fileserver."" Samba versions prior to 4.13.17, 4.14.12 and 4.15.5 with vfs_fruit configured allow out-of-bounds heap read and write via specially crafted extended file attributes. A remote attacker with write access to extended file attributes can execute arbitrary code with the privileges of smbd, typically root.'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u3debCVE-2021-44142High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-3738,High,2022-03-02T23:15:09.070,"""In DCE/RPC it is possible to share the handles (cookies for resource state) between multiple connections via a mechanism called 'association groups'. These handles can reference connections to our sam.ldb database. However while the database was correctly shared, the user credentials state was only pointed at, and when one connection within that association group ended, the database would be left pointing at an invalid 'struct session_info'. The most likely outcome here is a crash, but it is possible that the use-after-free could instead allow different user state to be pointed at and this might allow more privileged access.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-3738High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-25722,High,2022-02-18T18:15:08.643,'Multiple flaws were found in the way samba AD DC implemented access and conformance checking of stored data. An attacker could use this flaw to cause total domain compromise.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-25722High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-25721,High,2022-03-16T15:15:09.813,'Kerberos acceptors need easy access to stable AD identifiers (eg objectSid). Samba as an AD DC now provides a way for Linux applications to obtain a reliable SID (and samAccountName) in issued tickets.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-25721High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-25719,High,2022-02-18T18:15:08.563,"'A flaw was found in the way Samba, as an Active Directory Domain Controller, implemented Kerberos name-based authentication. The Samba AD DC, could become confused about the user a ticket represents if it did not strictly require a Kerberos PAC and always use the SIDs found within. The result could include total domain compromise.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-25719High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-25718,High,2022-02-18T18:15:08.487,"'A flaw was found in the way samba, as an Active Directory Domain Controller, is able to support an RODC (read-only domain controller). This would allow an RODC to print administrator tickets.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-25718High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u2,deb,CVE-2020-25717,High,2022-02-18T18:15:08.393,'A flaw was found in the way Samba maps domain users to local users. An authenticated attacker could use this flaw to cause possible privilege escalation.',libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u2debCVE-2020-25717High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-14303,High,2020-07-06T18:15:20.323,"'A flaw was found in the AD DC NBT server in all Samba versions before 4.10.17, before 4.11.11 and before 4.12.4. A samba user could send an empty UDP packet to cause the samba server to crash.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-14303High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-10745,High,2020-07-07T14:15:11.007,"'A flaw was found in all Samba versions before 4.10.17, before 4.11.11 and before 4.12.4 in the way it processed NetBios over TCP/IP. This flaw allows a remote attacker could to cause the Samba server to consume excessive CPU use, resulting in a denial of service. This highest threat from this vulnerability is to system availability.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-10745High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-10704,High,2020-05-06T14:15:10.817,"'A flaw was found when using samba as an Active Directory Domain Controller. Due to the way samba handles certain requests as an Active Directory Domain Controller LDAP server, an unauthorized user can cause a stack overflow leading to a denial of service. The highest threat from this vulnerability is to system availability. This issue affects all samba versions before 4.10.15, before 4.11.8 and before 4.12.2.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-10704High
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2023-42669,Medium,2023-11-06T07:15:09.137,"'A vulnerability was found in Samba\'s ""rpcecho"" development server, a non-Windows RPC server used to test Samba\'s DCE/RPC stack elements. This vulnerability stems from an RPC function that can be blocked indefinitely. The issue arises because the ""rpcecho"" service operates with only one worker in the main RPC task, allowing calls to the ""rpcecho"" server to be blocked for a specified time, causing service disruptions. This disruption is triggered by a ""sleep()"" call in the ""dcesrv_echo_TestSleep()"" function under specific conditions. Authenticated users or attackers can exploit this vulnerability to make calls to the ""rpcecho"" server, requesting it to block for a specified duration, effectively disrupting most services and leading to a complete denial of service on the AD DC. The DoS affects all other services as ""rpcecho"" runs in the main RPC task.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2023-42669Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2023-4091,Medium,2023-11-03T08:15:08.197,"'A vulnerability was discovered in Samba, where the flaw allows SMB clients to truncate files, even with read-only permissions when the Samba VFS module ""acl_xattr"" is configured with ""acl_xattr:ignore system acls = yes"". The SMB protocol allows opening files when the client requests read-only access but then implicitly truncates the opened file to 0 bytes if the client specifies a separate OVERWRITE create disposition request. The issue arises in configurations that bypass kernel file system permissions checks, relying solely on Samba\'s permissions.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2023-4091Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2023-34968,Medium,2023-07-20T15:15:11.540,"'A path disclosure vulnerability was found in Samba. As part of the Spotlight protocol, Samba discloses the server-side absolute path of shares, files, and directories in the results for search queries. This flaw allows a malicious client or an attacker with a targeted RPC request to view the information that is part of the disclosed path.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2023-34968Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2023-0922,Medium,2023-04-03T23:15:07.000,"'The Samba AD DC administration tool, when operating against a remote LDAP server, will by default send new or reset passwords over a signed-only connection.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2023-0922Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2023-0614,Medium,2023-04-03T23:15:06.957,"'The fix in 4.6.16, 4.7.9, 4.8.4 and 4.9.7 for CVE-2018-10919 Confidential attribute disclosure vi LDAP filters was insufficient and an attacker may be able to obtain confidential BitLocker recovery keys from a Samba AD DC.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2023-0614Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2023-0225,Medium,2023-04-03T23:15:06.907,'A flaw was found in Samba. An incomplete access check on dnsHostName allows authenticated but otherwise unprivileged users to delete this attribute from any object in the directory.',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2023-0225Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-3437,Medium,2023-01-12T15:15:10.083,"'A heap-based buffer overflow vulnerability was found in Samba within the GSSAPI unwrap_des() and unwrap_des3() routines of Heimdal. The DES and Triple-DES decryption routines in the Heimdal GSSAPI library allow a length-limited write buffer overflow on malloc() allocated memory when presented with a maliciously small packet. This flaw allows a remote user to send specially crafted malicious data to the application, possibly resulting in a denial of service (DoS) attack.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-3437Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2022-32746,Medium,2022-08-25T18:15:10.633,"'A flaw was found in the Samba AD LDAP server. The AD DC database audit logging module can access LDAP message values freed by a preceding database module, resulting in a use-after-free issue. This issue is only possible when modifying certain privileged attributes, such as userAccountControl.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2022-32746Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-32742,Medium,2022-08-25T18:15:10.430,"'A flaw was found in Samba. Some SMB1 write requests were not correctly range-checked to ensure the client had sent enough data to fulfill the write, allowing server memory contents to be written into the file (or printer) instead of client-supplied data. The client cannot control the area of the server memory written to the file (or printer).'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-32742Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2022-2127,Medium,2023-07-20T15:15:11.183,"'An out-of-bounds read vulnerability was found in Samba due to insufficient length checks in winbindd_pam_auth_crap.c. When performing NTLM authentication, the client replies to cryptographic challenges back to the server. These replies have variable lengths, and Winbind fails to check the lan manager response length. When Winbind is used for NTLM authentication, a maliciously crafted request can trigger an out-of-bounds read in Winbind, possibly resulting in a crash.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2022-2127Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-44141,Medium,2022-02-21T18:15:08.493,'All versions of Samba prior to 4.15.5 are vulnerable to a malicious client using a server symlink to determine if a file or directory exists in an area of the server file system not exported under the share definition. SMB1 with unix extensions has to be enabled in order for this attack to succeed.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-44141Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-3671,Medium,2021-10-12T18:15:08.357,'A null pointer de-reference was found in the way samba kerberos server handled missing sname in TGS-REQ (Ticket Granting Server - Request). An authenticated user could use this flaw to crash the samba server.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-3671Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-3670,Medium,2022-08-23T16:15:09.393,'MaxQueryDuration not honoured in Samba AD DC LDAP',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-3670Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-20316,Medium,2022-08-23T16:15:09.147,"'A flaw was found in the way Samba handled file/directory metadata. This flaw allows an authenticated attacker with permissions to read or modify share metadata, to perform this operation outside of the share.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-20316Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-20254,Medium,2021-05-05T14:15:07.883,'A flaw was found in samba. The Samba smbd file server must map Windows group identities (SIDs) into unix group ids (gids). The code that performs this had a flaw that could allow it to read data beyond the end of the array in the case where a negative cache entry had been added to the mapping cache. This could cause the calling code to return those values into the process token that stores the group membership for a user. The highest threat from this vulnerability is to data confidentiality and integrity.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-20254Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2021-20251,Medium,2023-03-06T23:15:10.387,'A flaw was found in samba. A race condition in the password lockout code may lead to the risk of brute force attacks being successful if special conditions are met.',libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2021-20251Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-14383,Medium,2020-12-02T01:15:12.170,"""A flaw was found in samba's DNS server. An authenticated user could use this flaw to the RPC server to crash. This RPC server, which also serves protocols other than dnsserver, will be restarted after a short delay, but it is easy for an authenticated non administrative attacker to crash it again as soon as it returns. The Samba DNS server itself will continue to operate, but many RPC services will not.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-14383Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-14323,Medium,2020-10-29T20:15:17.117,"""A null pointer dereference flaw was found in samba's Winbind service in versions before 4.11.15, before 4.12.9 and before 4.13.1. A local user could use this flaw to crash the winbind service causing denial of service.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-14323Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-14318,Medium,2020-12-03T16:15:12.077,'A flaw was found in the way samba handled file and directory permissions. An authenticated user could use this flaw to gain access to certain file and directory information which otherwise would be unavailable to the attacker.',libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-14318Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-10760,Medium,2020-07-06T19:15:12.307,"'A use-after-free flaw was found in all samba LDAP server versions before 4.10.17, before 4.11.11, before 4.12.4 used in a AC DC configuration. A Samba LDAP user could use this flaw to crash samba.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-10760Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2020-10730,Medium,2020-07-07T14:15:10.927,"'A NULL pointer dereference, or possible use-after-free flaw was found in Samba AD LDAP server in versions before 4.10.17, before 4.11.11 and before 4.12.4. Although some versions of Samba shipped with Red Hat Enterprise Linux do not support Samba in AD mode, the affected code is shipped with the libldb package. This flaw allows an authenticated user to possibly trigger a use-after-free or NULL pointer dereference. The highest threat from this vulnerability is to system availability.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2020-10730Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-19344,Medium,2020-01-21T18:15:12.937,"'There is a use-after-free issue in all samba 4.9.x versions before 4.9.18, all samba 4.10.x versions before 4.10.12 and all samba 4.11.x versions before 4.11.5, essentially due to a call to realloc() while other local variables still point at the original buffer.'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-19344Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-14907,Medium,2020-01-21T18:15:12.717,"'All samba versions 4.9.x before 4.9.18, 4.10.x before 4.10.12 and 4.11.x before 4.11.5 have an issue where if it is set with ""log level = 3"" (or above) then the string obtained from the client, after a failed character conversion, is printed. Such strings can be provided during the NTLMSSP authentication exchange. In the Samba AD DC in particular, this may cause a long-lived process(such as the RPC server) to terminate. (In the file server case, the most likely target, smbd, operates as process-per-client and so a crash there is harmless).'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-14907Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-14902,Medium,2020-01-21T18:15:12.653,"'There is an issue in all samba 4.11.x versions before 4.11.5, all samba 4.10.x versions before 4.10.12 and all samba 4.9.x versions before 4.9.18, where the removal of the right to create or modify a subtree would not automatically be taken away on all domain controllers.'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-14902Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2019-14870,Medium,2019-12-10T23:15:10.457,"'All Samba versions 4.x.x before 4.9.17, 4.10.x before 4.10.11 and 4.11.x before 4.11.3 have an issue, where the S4U (MS-SFU) Kerberos delegation model includes a feature allowing for a subset of clients to be opted out of constrained delegation in any way, either S4U2Self or regular Kerberos authentication, by forcing all tickets for these clients to be non-forwardable. In AD this is implemented by a user attribute delegation_not_allowed (aka not-delegated), which translates to disallow-forwardable. However the Samba AD DC does not do that for S4U2Self and does set the forwardable flag even if the impersonated client has the not-delegated flag set.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2019-14870Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2019-14861,Medium,2019-12-10T23:15:10.360,"'All Samba versions 4.x.x before 4.9.17, 4.10.x before 4.10.11 and 4.11.x before 4.11.3 have an issue, where the (poorly named) dnsserver RPC pipe provides administrative facilities to modify DNS records and zones. Samba, when acting as an AD DC, stores DNS records in LDAP. In AD, the default permissions on the DNS partition allow creation of new records by authenticated users. This is used for example to allow machines to self-register in DNS. If a DNS record was created that case-insensitively matched the name of the zone, the ldb_qsort() and dns_name_compare() routines could be confused into reading memory prior to the list of DNS entries when responding to DnssrvEnumRecords() or DnssrvEnumRecords2() and so following invalid memory as a pointer.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2019-14861Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-14847,Medium,2019-11-06T10:15:10.933,'A flaw was found in samba 4.0.0 before samba 4.9.15 and samba 4.10.x before 4.10.10. An attacker can crash AD DC LDAP server via dirsync resulting in denial of service. Privilege escalation is not possible with this issue.',libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-14847Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-14833,Medium,2019-11-06T10:15:10.793,"'A flaw was found in Samba, all versions starting samba 4.5.0 before samba 4.9.15, samba 4.10.10, samba 4.11.2, in the way it handles a user password change or a new password for a samba user. The Samba Active Directory Domain Controller can be configured to use a custom script to check for password complexity. This configuration can fail to verify password complexity when non-ASCII characters are used in the password, which could lead to weak passwords being set for samba users, making it vulnerable to dictionary attacks.'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-14833Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2019-10218,Medium,2019-11-06T10:15:10.607,"'A flaw was found in the samba client, all samba versions before samba 4.11.2, 4.10.10 and 4.9.15, where a malicious server can supply a pathname to the client with separators. This could allow the client to access files and folders outside of the SMB network pathnames. An attacker could use this vulnerability to create files outside of the current working directory using the privileges of the client user.'",libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2019-10218Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2018-14628,Medium,2023-01-17T18:15:10.810,"""An information leak vulnerability was discovered in Samba's LDAP server. Due to missing access control checks, an authenticated but unprivileged attacker could discover the names and preserved attributes of deleted objects in the LDAP store.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2018-14628Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,2:4.9.5+dfsg-5+deb10u4,deb,CVE-2016-2124,Medium,2022-02-18T18:15:08.237,'A flaw was found in the way samba implemented SMB1 authentication. An attacker could use this flaw to retrieve the plaintext password sent over the wire even if Kerberos authentication was required.',libwbclient02:4.9.5+dfsg-5+deb10u12:4.9.5+dfsg-5+deb10u4debCVE-2016-2124Medium
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2021-43566,Low,2022-01-11T16:15:07.813,"'All versions of Samba prior to 4.13.16 are vulnerable to a malicious client using an SMB1 or NFS race to allow a directory to be created in an area of the server file system not exported under the share definition. Note that SMB1 has to be enabled, or the share also available via NFS in order for this attack to succeed.'",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2021-43566Low
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2021-20277,Negligible,2021-05-12T14:15:11.140,"""A flaw was found in Samba's libldb. Multiple, consecutive leading spaces in an LDAP attribute can lead to an out-of-bounds memory write, leading to a crash of the LDAP server process handling the request. The highest threat from this vulnerability is to system availability.""",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2021-20277Negligible
libwbclient0,2:4.9.5+dfsg-5+deb10u1, ,deb,CVE-2020-27840,Negligible,2021-05-12T15:15:07.543,"'A flaw was found in samba. Spaces used in a string around a domain name (DN), while supposed to be ignored, can cause invalid DN strings with spaces to instead write a zero-byte into out-of-bounds memory, resulting in a crash. The highest threat from this vulnerability is to system availability.'",libwbclient02:4.9.5+dfsg-5+deb10u1 debCVE-2020-27840Negligible
libwbclient0,2:4.9.5+dfsg-5+deb10u1,(won't fix),deb,CVE-2023-4154,Unknown,2023-11-07T20:15:08.683,"""A design flaw was found in Samba's DirSync control implementation, which exposes passwords and secrets in Active Directory to privileged users and Read-Only Domain Controllers (RODCs). This flaw allows RODCs and users possessing the GET_CHANGES right to access all attributes, including sensitive secrets and passwords. Even in a default setup, RODC DC accounts, which should only replicate some passwords, can gain access to all domain secrets, including the vital krbtgt, effectively eliminating the RODC / DC distinction. Furthermore, the vulnerability fails to account for error conditions (fail open), like out-of-memory situations, potentially granting access to secret attributes, even under low-privileged attacker influence.""",libwbclient02:4.9.5+dfsg-5+deb10u1(won't fix)debCVE-2023-4154Unknown
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u5,deb,CVE-2022-40304,High,2022-11-23T18:15:12.167,"'An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u5debCVE-2022-40304High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u5,deb,CVE-2022-40303,High,2022-11-23T00:15:11.007,"'An issue was discovered in libxml2 before 2.10.3. When parsing a multi-gigabyte XML document with the XML_PARSE_HUGE parser option enabled, several integer counters can overflow. This results in an attempt to access an array at a negative 2GB offset, typically leading to a segmentation fault.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u5debCVE-2022-40303High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u3,deb,CVE-2022-23308,High,2022-02-26T05:15:08.280,'valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u3debCVE-2022-23308High
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2022-2309,High,2022-07-05T10:15:08.763,"""NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered.""",libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2022-2309High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2021-3518,High,2021-05-18T12:15:08.043,"""There's a flaw in libxml2 in versions before 2.9.11. An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free. The greatest impact from this flaw is to confidentiality, integrity, and availability.""",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2021-3518High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2021-3517,High,2021-05-19T14:15:07.553,"'There is a flaw in the xml entity encoding functionality of libxml2 in versions before 2.9.11. An attacker who is able to supply a crafted file to be processed by an application linked with the affected functionality of libxml2 could trigger an out-of-bounds read. The most likely impact of this flaw is to application availability, with some potential impact to confidentiality and integrity if an attacker is able to use memory information to further exploit the application.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2021-3517High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2021-3516,High,2021-06-01T14:15:10.373,"""There's a flaw in libxml2's xmllint in versions before 2.9.11. An attacker who is able to submit a crafted file to be processed by xmllint could trigger a use-after-free. The greatest impact of this flaw is to confidentiality, integrity, and availability.""",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2021-3516High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2020-7595,High,2020-01-21T23:15:13.867,'xmlStringLenDecodeEntities in parser.c in libxml2 2.9.10 has an infinite loop in a certain end-of-file situation.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2020-7595High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2019-20388,High,2020-01-21T23:15:13.553,'xmlSchemaPreRun in xmlschemas.c in libxml2 2.9.10 allows an xmlSchemaValidateStream memory leak.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2019-20388High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2019-19956,High,2019-12-24T16:15:11.450,'xmlParseBalancedChunkMemoryRecover in parser.c in libxml2 before 2.9.10 has a memory leak related to newDoc->oldNs.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2019-19956High
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2018-14404,High,2018-07-19T13:29:00.480,'A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case. Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2018-14404High
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2017-16932,High,2017-11-23T21:29:00.437,'parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.',libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2017-16932High
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2023-45322,Medium,2023-10-06T22:15:11.660,"'libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor\'s position is ""I don\'t think these issues are critical enough to warrant a CVE ID ... because an attacker typically can\'t control when memory allocations fail.""'",libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2023-45322Medium
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2023-39615,Medium,2023-08-29T17:15:12.527,"""Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.""",libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2023-39615Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u6,deb,CVE-2023-29469,Medium,2023-04-24T21:15:09.230,"""An issue was discovered in libxml2 before 2.10.4. When hashing empty dict strings in a crafted XML document, xmlDictComputeFastKey in dict.c can produce non-deterministic values, leading to various logic and memory errors, such as a double free. This behavior occurs because there is an attempt to use the first byte of an empty string, and any value is possible (not solely the '\\0' value).""",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u6debCVE-2023-29469Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u6,deb,CVE-2023-28484,Medium,2023-04-24T21:15:09.180,"'In libxml2 before 2.10.4, parsing of certain invalid XSD schemas can lead to a NULL pointer dereference and subsequently a segfault. This occurs in xmlSchemaFixupComplexType in xmlschemas.c.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u6debCVE-2023-28484Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u4,deb,CVE-2022-29824,Medium,2022-05-03T03:15:06.687,"""In libxml2 before 2.9.14, several buffer handling functions in buf.c (xmlBuf*) and tree.c (xmlBuffer*) don't check for integer overflows. This can result in out-of-bounds memory writes. Exploitation requires a victim to open a crafted, multi-gigabyte XML file. Other software using libxml2's buffer functions, for example libxslt through 1.1.35, is affected as well.""",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u4debCVE-2022-29824Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2021-3541,Medium,2021-07-09T17:15:07.973,'A flaw was found in libxml2. Exponential entity expansion attack its possible bypassing all existing protection mechanisms and leading to denial of service.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2021-3541Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2021-3537,Medium,2021-05-14T20:15:16.553,"'A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference. If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application. The highest threat from this vulnerability is to system availability.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2021-3537Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u2,deb,CVE-2020-24977,Medium,2020-09-04T00:15:10.693,'GNOME project libxml2 v2.9.10 has a global buffer over-read vulnerability in xmlEncodeEntitiesInternal at libxml2/entities.c. The issue has been fixed in commit 50f06b3e.',libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u2debCVE-2020-24977Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2018-14567,Medium,2018-08-16T20:29:02.470,"'libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035 and CVE-2018-9251.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2018-14567Medium
libxml2,2.9.4+dfsg1-7+b3,2.9.4+dfsg1-7+deb10u1,deb,CVE-2017-18258,Medium,2018-04-08T17:29:00.237,"'The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.'",libxml22.9.4+dfsg1-7+b32.9.4+dfsg1-7+deb10u1debCVE-2017-18258Medium
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2016-9318,Medium,2016-11-16T00:59:00.180,"'libxml2 2.9.4 and earlier, as used in XMLSec 1.2.23 and earlier and other products, does not offer a flag directly indicating that the current document may be read but other files may not be opened, which makes it easier for remote attackers to conduct XML External Entity (XXE) attacks via a crafted document.'",libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2016-9318Medium
libxml2,2.9.4+dfsg1-7+b3,(won't fix),deb,CVE-2016-3709,Medium,2022-07-28T17:15:07.920,'Possible cross-site scripting vulnerability in libxml after commit 960f0e2.',libxml22.9.4+dfsg1-7+b3(won't fix)debCVE-2016-3709Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-5717,High,2023-10-25T18:17:43.913,"""A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-5717High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-5178,High,2023-11-01T17:15:11.920,"'A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe-oF/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation in case that the attacker already has local privileges.'",linux-libc-dev4.19.132-1 debCVE-2023-5178High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4921,High,2023-09-12T20:15:10.573,"""A use-after-free vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.\n\nWhen the plug qdisc is used as a class of the qfq qdisc, sending network packets triggers use-after-free in qfq_dequeue() due to the incorrect .peek handler of sch_plug and lack of error checking in agg_dequeue().\n\nWe recommend upgrading past commit 8fc134fee27f2263988ae38920bc03da416b03d8.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4921High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4623,High,2023-09-06T14:15:12.357,"""A use-after-free vulnerability in the Linux kernel's net/sched: sch_hfsc (HFSC qdisc traffic control) component can be exploited to achieve local privilege escalation.\n\nIf a class with a link-sharing curve (i.e. with the HFSC_FSC flag set) has a parent without a link-sharing curve, then init_vf() will call vttree_insert() on the parent, but vttree_remove() will be skipped in update_vf(). This leaves a dangling pointer that can cause a use-after-free.\n\nWe recommend upgrading past commit b3d26c5702c7d6c45456326e56d2ccf3f103e60f.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4623High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4622,High,2023-09-06T14:15:12.193,"""A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation.\n\nThe unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free.\n\nWe recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4622High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-45862,High,2023-10-14T21:15:45.180,'An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-45862High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2023-4387,High,2023-08-16T19:15:10.087,"""A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.""",linux-libc-dev4.19.132-14.19.249-1debCVE-2023-4387High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-42753,High,2023-09-25T21:15:15.923,"'An array indexing vulnerability was found in the netfilter subsystem of the Linux kernel. A missing macro could lead to a miscalculation of the `h->nets` array offset, providing attackers with the primitive to arbitrarily increment/decrement a memory buffer out-of-bound. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.'",linux-libc-dev4.19.132-1 debCVE-2023-42753High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4244,High,2023-09-06T14:15:11.877,"""A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nDue to a race condition between nf_tables netlink control plane transaction and nft_set element garbage collection, it is possible to underflow the reference counter causing a use-after-free vulnerability.\n\nWe recommend upgrading past commit 3e91b0ebd994635df2346353322ac51ce84ce6d8.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4244High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4208,High,2023-09-06T14:15:11.627,"""A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.\n\nWhen u32_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit 3044b16e7c6fe5d24b1cdbcf1bd0a9d92d1ebd81.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4208High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4207,High,2023-09-06T14:15:11.453,"""A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.\n\nWhen fw_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit 76e42ae831991c828cffa8c37736ebfb831ad5ec.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4207High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4206,High,2023-09-06T14:15:11.280,"""A use-after-free vulnerability in the Linux kernel's net/sched: cls_route component can be exploited to achieve local privilege escalation.\n\nWhen route4_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit b80b829e9e2c1b3f7aae34855e04d8f6ecaf13c8.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-4206High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4128,High,2023-08-10T17:15:12.033,"'Rejected reason: ** REJECT ** DO NOT USE THIS CVE RECORD. ConsultIDs: CVE-2023-4206, CVE-2023-4207, CVE-2023-4208.  Reason: This record is a duplicate of CVE-2023-4206, CVE-2023-4207, CVE-2023-4208. Notes: All CVE users should reference CVE-2023-4206, CVE-2023-4207, CVE-2023-4208 instead of this record. All references and descriptions in this record have been removed to prevent accidental usage.'",linux-libc-dev4.19.132-1 debCVE-2023-4128High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-40283,High,2023-08-14T03:15:09.257,'An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.',linux-libc-dev4.19.132-1 debCVE-2023-40283High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2023-3812,High,2023-07-24T16:15:13.337,'An out-of-bounds memory access flaw was found in the Linux kernels TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.269-1debCVE-2023-3812High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3776,High,2023-07-21T21:15:11.973,"""A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.\n\nIf tcf_change_indev() fails, fw_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.\n\nWe recommend upgrading past commit 0323bce598eea038714f941ce2b22541c46d488f.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-3776High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3640,High,2023-07-24T16:15:13.063,"""A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.""",linux-libc-dev4.19.132-1 debCVE-2023-3640High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3611,High,2023-07-21T21:15:11.897,"""An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.\n\nThe qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks.\n\nWe recommend upgrading past commit 3e337087c3b5805fe0b8a46ba622a962880b5d64.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-3611High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3609,High,2023-07-21T21:15:11.743,"""A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.\n\nIf tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.\n\nWe recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.\n\n""",linux-libc-dev4.19.132-1 debCVE-2023-3609High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-35828,High,2023-06-18T22:15:09.417,'An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-35828High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-35827,High,2023-06-18T22:15:09.373,'An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.',linux-libc-dev4.19.132-1 debCVE-2023-35827High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-35824,High,2023-06-18T22:15:09.240,'An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-35824High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-35823,High,2023-06-18T22:15:09.187,'An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-35823High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-35788,High,2023-06-16T21:15:09.340,'An issue was discovered in fl_set_geneve_opt in net/sched/cls_flower.c in the Linux kernel before 6.3.7. It allows an out-of-bounds write in the flower classifier code via TCA_FLOWER_KEY_ENC_OPTS_GENEVE packets. This may result in denial of service or privilege escalation.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-35788High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-3567,High,2023-07-24T16:15:12.990,'A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-3567High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-35001,High,2023-07-05T19:15:10.147,'Linux Kernel nftables Out-Of-Bounds Read/Write Vulnerability; nft_byteorder poorly handled vm register contents when CAP_NET_ADMIN is in any user or network namespace',linux-libc-dev4.19.132-1 debCVE-2023-35001High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-34319,High,2023-09-22T14:15:45.627,"""The fix for XSA-423 added logic to Linux'es netback driver to deal with\na frontend splitting a packet in a way such that not all of the headers\nwould come in one piece.  Unfortunately the logic introduced there\ndidn't account for the extreme case of the entire packet being split\ninto as many pieces as permitted by the protocol, yet still being\nsmaller than the area that's specially dealt with to keep all (possible)\nheaders together.  Such an unusual packet would therefore trigger a\nbuffer overrun in the driver.\n""",linux-libc-dev4.19.132-1 debCVE-2023-34319High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3397,High,2023-11-01T20:15:08.737,"'A race condition occurred between the functions lmLogClose and txEnd in JFS, in the Linux Kernel, executed in different threads. This flaw allows a local attacker with normal user privileges to crash the system or leak internal kernel information.'",linux-libc-dev4.19.132-1 debCVE-2023-3397High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3390,High,2023-06-28T21:15:10.447,"""A use-after-free vulnerability was found in the Linux kernel's netfilter subsystem in net/netfilter/nf_tables_api.c.\n\nMishandled error handling with NFT_MSG_NEWRULE makes it possible to use a dangling pointer in the same transaction causing a use-after-free vulnerability. This flaw allows a local attacker with user access to cause a privilege escalation issue.\n\nWe recommend upgrading past commit\xa01240eb93f0616b21c675416516ff3d74798fdc97.""",linux-libc-dev4.19.132-1 debCVE-2023-3390High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-3268,High,2023-06-16T19:15:14.707,'An out of bounds (OOB) memory access flaw was found in the Linux kernel in relay_file_read_start_pos in kernel/relay.c in the relayfs. This flaw could allow a local attacker to crash the system or leak kernel internal information.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-3268High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-32233,High,2023-05-08T20:15:20.267,"'In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables when processing batch requests can be abused to perform arbitrary read and write operations on kernel memory. Unprivileged local users can obtain root privileges. This occurs because anonymous sets are mishandled.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-32233High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-31436,High,2023-04-28T02:15:09.007,'qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13 allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-31436High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-3141,High,2023-06-09T20:15:10.327,"'A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-3141High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-3111,High,2023-06-05T21:15:11.377,'A use after free vulnerability was found in prepare_to_relocate in fs/btrfs/relocation.c in btrfs in the Linux Kernel. This possible flaw can be triggered by calling btrfs_ioctl_balance() before calling btrfs_ioctl_defrag().',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-3111High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-3090,High,2023-06-28T20:15:09.693,'A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.\n\nThe out-of-bounds write is caused by missing skb->cb  initialization in the ipvlan network driver. The vulnerability is reachable if\xa0CONFIG_IPVLAN is enabled.\n\n\nWe recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.\n\n',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-3090High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2023-28466,High,2023-03-16T00:15:11.563,"'do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).'",linux-libc-dev4.19.132-1(won't fix)debCVE-2023-28466High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-23559,High,2023-01-13T01:15:10.300,"'In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-23559High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-21255,High,2023-07-13T00:15:24.053,"'In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n'",linux-libc-dev4.19.132-1 debCVE-2023-21255High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-2124,High,2023-05-15T22:15:12.150,'An out-of-bounds memory access flaw was found in the Linux kernels XFS file system in how a user restores an XFS image after failure (with a dirty log journal). This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-1 debCVE-2023-2124High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2023-20938,High,2023-02-28T17:15:10.723,"'In binder_transaction_buffer_release of binder.c, there is a possible use after free due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-257685302References: Upstream kernel'",linux-libc-dev4.19.132-1(won't fix)debCVE-2023-20938High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-2007,High,2023-04-24T23:15:18.877,'The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.',linux-libc-dev4.19.132-14.19.289-1debCVE-2023-2007High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1989,High,2023-04-11T21:15:15.503,"'A use-after-free flaw was found in btsdio_remove in drivers\\bluetooth\\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1989High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2023-1838,High,2023-04-05T19:15:07.793,"'A use-after-free flaw was found in vhost_net_set_backend in drivers/vhost/net.c in virtio network subcomponent in the Linux kernel due to a double fget. This flaw could allow a local attacker to crash the system, and could even lead to a kernel information leak problem.'",linux-libc-dev4.19.132-14.19.249-1debCVE-2023-1838High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1829,High,2023-04-12T12:15:07.080,'A use-after-free vulnerability in the Linux Kernel traffic control index filter (tcindex) can be exploited to achieve local privilege escalation.\xa0The tcindex_delete function which does not properly deactivate filters in case of a perfect hashes while deleting the underlying structure which can later lead to double freeing the structure.\xa0A local attacker user can use this vulnerability to elevate its privileges to root.\nWe recommend upgrading past commit 8c710f75256bb3cf05ac7b1672c82b92c43f3d28.\n\n',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1829High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1670,High,2023-03-30T23:15:06.413,'A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1670High
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2023-1390,High,2023-03-16T21:15:11.447,"'A remote denial of service vulnerability was found in the Linux kernels TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state while attempting to parse SKBs, which are not in the queue. Sending two small UDP packets to a system with a UDP bearer results in the CPU utilization for the system to instantly spike to 100%, causing a denial of service condition.'",linux-libc-dev4.19.132-14.19.171-1debCVE-2023-1390High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-1380,High,2023-03-27T21:15:10.623,"'A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-1380High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1281,High,2023-03-22T14:15:16.090,"""Use After Free vulnerability in Linux kernel traffic control index filter (tcindex) allows Privilege Escalation.\xa0The imperfect hash area can be updated while packets are traversing, which will cause a use-after-free when 'tcf_exts_exec()' is called with the destroyed tcf_ext.\xa0A local attacker user can use this vulnerability to elevate its privileges to root.\nThis issue affects Linux Kernel: from 4.14 before git commit ee059170b1f7e94e55fa6cadee544e176a6e59c2.\n\n""",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1281High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1118,High,2023-03-02T18:15:09.637,'A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1118High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1078,High,2023-03-27T21:15:10.520,"'A flaw was found in the Linux Kernel in RDS (Reliable Datagram Sockets) protocol. The rds_rm_zerocopy_callback() uses list_entry() on the head of a list causing a type confusion. Local user can trigger this with rds_message_put(). Type confusion leads to `struct rds_msg_zcopy_info *info` actually points to something else that is potentially controlled by local user. It is known how to trigger this, which causes an out of bounds access, and a lock corruption.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1078High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1077,High,2023-03-27T21:15:10.467,"'In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.'",linux-libc-dev4.19.132-1 debCVE-2023-1077High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-0461,High,2023-02-28T15:15:11.550,"'There is a use-after-free vulnerability in the Linux Kernel which can be exploited to achieve local privilege escalation. To reach the vulnerability kernel configuration flag CONFIG_TLS\xa0or CONFIG_XFRM_ESPINTCP\xa0has to be configured, but the operation does not require any privilege.\n\nThere is a use-after-free bug of icsk_ulp_data\xa0of a struct inet_connection_sock.\n\nWhen CONFIG_TLS\xa0is enabled, user can install a tls context (struct tls_context) on a connected tcp socket. The context is not cleared if this socket is disconnected and reused as a listener. If a new socket is created from the listener, the context is inherited and vulnerable.\n\nThe setsockopt\xa0TCP_ULP\xa0operation does not require any privilege.\n\nWe recommend upgrading past commit\xa02c02d41d71f90a5168391b6a5f2954112ba2307c'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-0461High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-0386,High,2023-03-22T21:15:18.090,"'A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities was found in the Linux kernels OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount. This uid mapping bug allows a local user to escalate their privileges on the system.'",linux-libc-dev4.19.132-1 debCVE-2023-0386High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-0030,High,2023-03-08T23:15:10.963,'A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-1 debCVE-2023-0030High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-47521,High,2022-12-18T06:15:09.527,'An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.',linux-libc-dev4.19.132-1 debCVE-2022-47521High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-47520,High,2022-12-18T06:15:09.473,'An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.',linux-libc-dev4.19.132-1 debCVE-2022-47520High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-47519,High,2022-12-18T06:15:09.417,'An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing the channel list attribute from Wi-Fi management frames.',linux-libc-dev4.19.132-1 debCVE-2022-47519High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-47518,High,2022-12-18T06:15:09.300,'An issue was discovered in the Linux kernel before 6.0.11. Missing validation of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when copying the list of operating channels from Wi-Fi management frames.',linux-libc-dev4.19.132-1 debCVE-2022-47518High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-4744,High,2023-03-30T21:15:06.497,'A double-free flaw was found in the Linux kernels TUN/TAP device driver functionality in how a user registers the device when the register_netdevice function fails (NETDEV_REGISTER notifier). This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.282-1debCVE-2022-4744High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-45934,High,2022-11-27T04:15:10.290,'An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.',linux-libc-dev4.19.132-14.19.282-1debCVE-2022-45934High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2022-45919,High,2022-11-27T02:15:16.547,"'An issue was discovered in the Linux kernel through 6.0.10. In drivers/media/dvb-core/dvb_ca_en50221.c, a use-after-free can occur is there is a disconnect after an open, because of the lack of a wait_event.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2022-45919High
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2022-45886,High,2022-11-25T04:15:09.273,'An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_net.c has a .disconnect versus dvb_device_open race condition that leads to a use-after-free.',linux-libc-dev4.19.132-14.19.289-1debCVE-2022-45886High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-43945,High,2022-11-04T19:15:11.180,'The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H',linux-libc-dev4.19.132-1 debCVE-2022-43945High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-4378,High,2023-01-05T16:15:11.840,"""A stack overflow flaw was found in the Linux kernel's SYSCTL subsystem in how a user changes certain kernel parameters and variables. This flaw allows a local user to crash or potentially escalate their privileges on the system.""",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-4378High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-42896,High,2022-11-23T15:15:10.723,"""There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_connect and l2cap_le_connect_req functions which may allow code execution and leaking kernel memory (respectively) remotely via Bluetooth.\xa0A remote attacker could execute code leaking kernel memory via Bluetooth if within proximity of the victim.\n\nWe recommend upgrading past commit\xa0  https://www.google.com/url  https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4 https://www.google.com/url \n\n""",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-42896High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-41858,High,2023-01-17T18:15:11.140,'A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-41858High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-4095,High,2023-03-22T15:15:10.113,"'A use-after-free flaw was found in Linux kernel before 5.19.2. This issue occurs in cmd_hdl_filter in drivers/staging/rtl8712/rtl8712_cmd.c, allowing an attacker to launch a local denial of service attack and gain escalation of privileges.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-4095High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-39189,High,2022-09-02T05:15:07.693,'An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.',linux-libc-dev4.19.132-1 debCVE-2022-39189High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-36946,High,2022-07-27T20:15:08.643,"'nfqnl_mangle in net/netfilter/nfnetlink_queue.c in the Linux kernel through 5.18.14 allows remote attackers to cause a denial of service (panic) because, in the case of an nf_queue verdict with a one-byte nfta_payload attribute, an skb_pull can encounter a negative skb->len.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-36946High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3649,High,2022-10-21T20:15:09.837,'A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3649High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3640,High,2022-10-21T15:15:09.427,"'A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3640High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-3635,High,2022-10-21T11:15:09.557,"'A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function tst_timer of the file drivers/atm/idt77252.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. VDB-211934 is the identifier assigned to this vulnerability.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-3635High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3566,High,2022-10-17T19:15:10.330,"'A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.'",linux-libc-dev4.19.132-1 debCVE-2022-3566High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3565,High,2022-10-17T19:15:10.257,"'A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3565High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3564,High,2022-10-17T19:15:10.187,'A vulnerability classified as critical was found in Linux Kernel. Affected by this vulnerability is the function l2cap_reassemble_sdu of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211087.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3564High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-3545,High,2022-10-17T12:15:11.133,'A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.',linux-libc-dev4.19.132-14.19.282-1debCVE-2022-3545High
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-3424,High,2023-03-06T23:15:10.853,"'A use-after-free flaw was found in the Linux kernels SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2022-3424High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-32981,High,2022-06-10T20:15:08.550,'An issue was discovered in the Linux kernel through 5.18.3 on powerpc 32-bit platforms. There is a buffer overflow in ptrace PEEKUSER and POKEUSER (aka PEEKUSR and POKEUSR) when accessing floating point registers.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-32981High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-3239,High,2022-09-19T20:15:12.697,'A flaw use after free in the Linux kernel video4linux driver was found in the way user triggers em28xx_usb_probe() for the Empia 28xx based TV cards. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-3239High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-32250,High,2022-06-02T21:15:07.973,'net/netfilter/nf_tables_api.c in the Linux kernel through 5.18.1 allows a local user (able to create user/net namespaces) to escalate privileges to root because an incorrect NFT_STATEFUL_EXPR check leads to a use-after-free.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-32250High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-3202,High,2022-09-14T15:15:11.453,'A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled File System (JFS)in the Linux kernel. This could allow a local attacker to crash the system or leak kernel internal information.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-3202High
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3176,High,2022-09-16T14:15:09.713,"""There exists a use-after-free in io_uring in the Linux kernel. Signalfd_poll() and binder_poll() use a waitqueue whose lifetime is the current task. It will send a POLLFREE notification to all waiters before the queue is freed. Unfortunately, the io_uring poll doesn't handle POLLFREE. This allows a use-after-free to occur if a signalfd or binder fd is polled with io_uring poll, and the waitqueue gets freed. We recommend upgrading past commit fc78b2fc21f10c4c9c4d5d659a685710ffa63659""",linux-libc-dev4.19.132-1 debCVE-2022-3176High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-30594,High,2022-05-12T05:15:06.657,'The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-30594High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-3028,High,2022-08-31T16:15:11.867,"""A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.""",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-3028High
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-2978,High,2022-08-24T16:15:12.010,'A flaw use after free in the Linux kernel NILFS file system was found in the way user triggers function security_inode_alloc to fail with following call to function nilfs_mdt_destroy. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-2978High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-2977,High,2022-09-14T21:15:10.377,'A flaw was found in the Linux kernel implementation of proxied virtualized TPM devices. On a system where virtualized TPM devices are configured (this is not the default) a local attacker can create a use-after-free and create a situation where it may be possible to escalate privileges on the system.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-2977High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-2964,High,2022-09-09T15:15:10.227,'A flaw was found in the Linux kernels driver for the ASIX AX88179_178A-based USB 2.0/3.0 Gigabit Ethernet Devices. The vulnerability contains multiple out-of-bounds reads and possible out-of-bounds writes.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-2964High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-29581,High,2022-05-17T17:15:08.357,'Improper Update of Reference Count vulnerability in net/sched of Linux Kernel allows local attacker to cause privilege escalation to root. This issue affects: Linux Kernel versions prior to 5.18; version 4.14 and later versions.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-29581High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-28390,High,2022-04-03T21:15:08.163,'ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-28390High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-27666,High,2022-03-23T06:15:06.717,'A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-27666High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-27223,High,2022-03-16T00:15:09.993,"'In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-27223High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-26490,High,2022-03-06T04:15:07.100,'st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-26490High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-2639,High,2022-09-01T21:15:09.600,"'An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.'",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-2639High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-24958,High,2022-02-11T06:15:06.717,'drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.',linux-libc-dev4.19.132-14.19.235-1debCVE-2022-24958High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23042,High,2022-03-10T20:15:08.763,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23042High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23041,High,2022-03-10T20:15:08.720,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23041High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23040,High,2022-03-10T20:15:08.677,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23040High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23039,High,2022-03-10T20:15:08.633,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23039High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23038,High,2022-03-10T20:15:08.593,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23038High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23037,High,2022-03-10T20:15:08.547,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23037High
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2022-23036,High,2022-03-10T20:15:08.503,"""Linux PV device frontends vulnerable to attacks by backends T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.235-1debCVE-2022-23036High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-20566,High,2022-12-16T16:15:19.433,"'In l2cap_chan_put of l2cap_core, there is a possible use after free due to improper locking. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-165329981References: Upstream kernel'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-20566High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-20422,High,2022-10-11T20:15:12.693,"'In emulation_proc_handler of armv8_deprecated.c, there is a possible way to corrupt memory due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-237540956References: Upstream kernel'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-20422High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-20421,High,2022-10-11T20:15:12.533,"'In binder_inc_ref_for_node of binder.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-239630375References: Upstream kernel'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-20421High
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-20368,High,2022-08-11T15:15:10.557,'Product: AndroidVersions: Android kernelAndroid ID: A-224546354References: Upstream kernel',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-20368High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2022-20141,High,2022-06-15T14:15:11.183,"'In ip_check_mc_rcu of igmp.c, there is a possible use after free due to improper locking. This could lead to local escalation of privilege when opening and closing inet sockets with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-112551163References: Upstream kernel'",linux-libc-dev4.19.132-14.19.208-1debCVE-2022-20141High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1729,High,2022-09-01T21:15:09.057,"'A race condition was found the Linux kernel in perf_event_open() which can be exploited by an unprivileged user to gain root privileges. The bug allows to build several exploit primitives such as kernel address information leak, arbitrary execution, etc.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1729High
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-1679,High,2022-05-16T18:15:08.410,'A use-after-free flaw was found in the Linux kernels Atheros wireless adapter driver in the way a user forces the ath9k_htc_wait_for_target function to fail with some input messages. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-1679High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-1678,High,2022-05-25T15:15:07.887,"'An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper update of sock reference in TCP pacing can lead to memory/netns leak, which can be used by remote clients.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-1678High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1652,High,2022-06-02T14:15:32.930,"'Linux Kernel could allow a local attacker to execute arbitrary code on the system, caused by a concurrency use-after-free flaw in the bad_flp_intr function. By executing a specially-crafted program, an attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service condition on the system.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1652High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1419,High,2022-06-02T14:15:32.577,"'The root cause of this vulnerability is that the ioctl$DRM_IOCTL_MODE_DESTROY_DUMB can decrease refcount of *drm_vgem_gem_object *(created in *vgem_gem_dumb_create*) concurrently, and *vgem_gem_dumb_create *will access the freed drm_vgem_gem_object.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1419High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1353,High,2022-04-29T16:15:08.853,"'A vulnerability was found in the pfkey_register function in net/key/af_key.c in the Linux kernel. This flaw allows a local, unprivileged user to gain access to kernel memory, leading to a system crash or a leak of internal kernel information.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1353High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1199,High,2022-08-29T15:15:10.527,"'A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1199High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1048,High,2022-04-29T16:15:08.470,'A use-after-free flaw was found in the Linux kernels sound subsystem in the way a user triggers concurrent calls of PCM hw_params. The hw_free ioctls or similar race condition happens inside ALSA PCM for other ioctls. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1048High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1012,High,2022-08-05T16:15:11.370,'A memory leak problem was found in the TCP source port generation algorithm in net/ipv4/tcp.c due to the small table perturb size. This flaw may allow an attacker to information leak and may cause a denial of service problem.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1012High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1011,High,2022-03-18T18:15:12.177,"'A use-after-free flaw was found in the Linux kernels FUSE filesystem in the way a user triggers write(). This flaw allows a local user to gain unauthorized access to data from the FUSE filesystem, resulting in privilege escalation.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1011High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2022-0850,High,2022-08-29T15:15:09.920,"'A vulnerability was found in linux kernel, where an information leak occurs via ext4_extent_header to userspace.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2022-0850High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0492,High,2022-03-03T19:15:08.633,"'A vulnerability was found in the Linux kernels cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0492High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0435,High,2022-03-25T19:15:10.100,"""A stack overflow flaw was found in the Linux kernel's TIPC protocol functionality in the way a user sends a packet with malicious content where the number of domain member nodes is higher than the 64 allowed. This flaw allows a remote user to crash the system or possibly escalate their privileges if they have access to the TIPC network.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0435High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0330,High,2022-03-25T19:15:10.027,"""A random memory access flaw was found in the Linux kernel's GPU i915 kernel driver functionality in the way a user may run malicious code on the GPU. This flaw allows a local user to crash the system or escalate their privileges on the system.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0330High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-45485,High,2021-12-25T02:15:06.667,"""In the IPv6 implementation in the Linux kernel before 5.13.3, net/ipv6/output_core.c has an information leak because of certain use of a hash table which, although big, doesn't properly consider that IPv6-based attackers can typically choose among many IPv6 source addresses.""",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-45485High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-45469,High,2021-12-23T19:15:12.693,"'In __f2fs_setxattr in fs/f2fs/xattr.c in the Linux kernel through 5.15.11, there is an out-of-bounds memory access when an inode has an invalid last xattr entry.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-45469High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-44733,High,2021-12-22T17:15:09.123,'A use-after-free exists in drivers/tee/tee_shm.c in the TEE subsystem in the Linux kernel through 5.15.11. This occurs because of a race condition in tee_shm_get_from_id during an attempt to free a shared memory object.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-44733High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-42252,High,2021-10-11T19:15:07.713,"'An issue was discovered in aspeed_lpc_ctrl_mmap in drivers/soc/aspeed/aspeed-lpc-ctrl.c in the Linux kernel before 5.14.6. Local attackers able to access the Aspeed LPC control interface could overwrite memory in the kernel and potentially execute privileges, aka CID-b49a0e69a7b1. This occurs because a certain comparison uses values that are not memory sizes.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-42252High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4202,High,2022-03-25T19:15:09.770,"'A use-after-free flaw was found in nci_request in net/nfc/nci/core.c in NFC Controller Interface (NCI) in the Linux kernel. This flaw could allow a local attacker with user privileges to cause a data race problem while the device is getting removed, leading to a privilege escalation problem.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4202High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-42008,High,2021-10-05T00:15:07.413,'The decode_data function in drivers/net/hamradio/6pack.c in the Linux kernel before 5.13.13 has a slab out-of-bounds write. Input from a process that has the CAP_NET_ADMIN capability can lead to root access.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-42008High
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2021-4197,High,2022-03-23T20:15:10.200,"""An unprivileged write to the file handler flaw in the Linux kernel's control groups and namespaces subsystem was found in the way users have access to some less privileged process that are controlled by cgroups and have higher privileged parent process. It is actually both for cgroup2 and cgroup1 versions of control groups. A local user could use this flaw to crash the system or escalate their privileges on the system.""",linux-libc-dev4.19.132-14.19.249-2debCVE-2021-4197High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-41864,High,2021-10-02T00:15:07.503,'prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-41864High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-4157,High,2022-03-25T19:15:09.703,"'An out of memory bounds write flaw (1 or 2 bytes of memory) in the Linux kernel NFS subsystem was found in the way users use mirroring (replication of files with NFS). A user, having access to the NFS mount, could potentially use this flaw to crash the system or escalate privileges on the system.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-4157High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4083,High,2022-01-18T17:15:09.403,"""A read-after-free memory flaw was found in the Linux kernel's garbage collection for Unix domain socket file handlers in the way users call close() and fget() simultaneously and can potentially trigger a race condition. This flaw allows a local user to crash the system or escalate their privileges on the system. This flaw affects Linux kernel versions prior to 5.16-rc4.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4083High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-40490,High,2021-09-03T01:15:07.940,'A race condition was discovered in ext4_write_inline_data_end in fs/ext4/inline.c in the ext4 subsystem in the Linux kernel through 5.13.13.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-40490High
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-4037,High,2022-08-24T16:15:09.257,"'A vulnerability was found in the fs/inode.c:inode_init_owner() function logic of the LInux kernel that allows local users to create files for the XFS file-system with an unintended group ownership and with group execution and SGID permission bits set, in a scenario where a directory is SGID and belongs to a certain group and is writable by a user who is not a member of this group. This can lead to excessive permissions granted in case when they should not. This vulnerability is similar to the previous CVE-2018-13405 and adds the missed fix for the XFS.'",linux-libc-dev4.19.132-1 debCVE-2021-4037High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-39713,High,2022-03-16T15:15:11.330,'Product: AndroidVersions: Android kernelAndroid ID: A-173788806References: Upstream kernel',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-39713High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-39698,High,2022-03-16T15:15:10.757,"'In aio_poll_complete_work of aio.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-185125206References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-39698High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-39686,High,2022-03-16T15:15:10.417,"'In several functions of binder.c, there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-39686High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-39685,High,2022-03-16T15:15:10.377,"'In various setup methods of the USB gadget subsystem, there is a possible out of bounds write due to an incorrect flag check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-210292376References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-39685High
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2021-39634,High,2022-01-14T20:15:11.247,"'In fs/eventpoll.c, there is a possible use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204450605References: Upstream kernel'",linux-libc-dev4.19.132-14.19.152-1debCVE-2021-39634High
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3864,High,2022-08-26T16:15:09.680,"'A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.'",linux-libc-dev4.19.132-1 debCVE-2021-3864High
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3847,High,2022-04-01T23:15:10.597,'An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.',linux-libc-dev4.19.132-1 debCVE-2021-3847High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-38300,High,2021-09-20T06:15:06.623,"'arch/mips/net/bpf_jit.c in the Linux kernel before 5.4.10 can generate undesirable machine code when transforming unprivileged cBPF programs, allowing execution of arbitrary code within the kernel context. This occurs because conditional branches can exceed the 128 KB limit of the MIPS architecture.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-38300High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2021-38207,High,2021-08-08T20:15:07.353,'drivers/net/ethernet/xilinx/ll_temac_main.c in the Linux kernel before 5.12.13 allows remote attackers to cause a denial of service (buffer overflow and lockup) by sending heavy network traffic for about ten minutes.',linux-libc-dev4.19.132-1(won't fix)debCVE-2021-38207High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-38160,High,2021-08-07T04:15:06.967,"'In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-38160High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3760,High,2022-02-16T19:15:08.707,"'A flaw was found in the Linux kernel. A use-after-free vulnerability in the NFC stack can lead to a threat to confidentiality, integrity, and system availability.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3760High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-37576,High,2021-07-26T22:15:08.423,"'arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-37576High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3752,High,2022-02-16T19:15:08.587,"'A use-after-free flaw was found in the Linux kernels Bluetooth subsystem in the way user calls connect to the socket and disconnect simultaneously due to a race condition. This flaw allows a user to crash the system or escalate their privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3752High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3743,High,2022-03-04T16:15:08.547,"'An out-of-bounds (OOB) memory read flaw was found in the Qualcomm IPC router protocol in the Linux kernel. A missing sanity check allows a local attacker to gain access to out-of-bounds memory, leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3743High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3656,High,2022-03-04T19:15:08.677,"'A flaw was found in the KVM\'s AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the ""virt_ext"" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3656High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3653,High,2021-09-29T20:15:08.617,"'A flaw was found in the KVM\'s AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the ""int_ctl"" field, this issue could allow a malicious L1 to enable AVIC support (Advanced Virtual Interrupt Controller) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape. This flaw affects Linux kernel versions prior to 5.14-rc7.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3653High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3640,High,2022-03-03T23:15:08.197,'A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg() with the expected controllable faulting memory page. A privileged local user could use this flaw to crash the system or escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3640High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3612,High,2021-07-09T11:15:09.457,"""An out-of-bounds memory write flaw was found in the Linux kernel's joystick devices subsystem in versions before 5.9-rc1, in the way the user calls ioctl JSIOCSBTNMAP. This flaw allows a local user to crash the system or possibly escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.""",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3612High
linux-libc-dev,4.19.132-1,4.19.194-3,deb,CVE-2021-3609,High,2022-03-03T19:15:08.173,"'.A flaw was found in the CAN BCM networking protocol in the Linux kernel, where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory, crash the system or escalate privileges. This race condition in net/can/bcm.c in the Linux kernel allows for local privilege escalation to root.'",linux-libc-dev4.19.132-14.19.194-3debCVE-2021-3609High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-3506,High,2021-04-19T22:15:13.110,'An out-of-bounds (OOB) memory access flaw was found in fs/f2fs/node.c in the f2fs module in the Linux kernel in versions before 5.12.0-rc4. A bounds check failure allows a local attacker to gain access to out-of-bounds memory leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-3506High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-35039,High,2021-07-07T01:15:07.517,"'kernel/module.c in the Linux kernel before 5.12.14 mishandles Signature Verification, aka CID-0c18f29aae7c. Without CONFIG_MODULE_SIG, verification that a kernel module is signed, for loading via init_module, does not occur for a module.sig_enforce=1 command-line argument.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-35039High
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3493,High,2021-04-17T05:15:14.630,"'The overlayfs implementation in the linux kernel did not properly validate with respect to user namespaces the setting of file capabilities on files in an underlying file system. Due to the combination of unprivileged user namespaces along with a patch carried in the Ubuntu kernel to allow unprivileged overlay mounts, an attacker could use this to gain elevated privileges.'",linux-libc-dev4.19.132-1 debCVE-2021-3493High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-3483,High,2021-05-17T12:15:07.523,"'A flaw was found in the Nosy driver in the Linux kernel. This issue allows a device to be inserted twice into a doubly-linked list, leading to a use-after-free when one of these devices is removed. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability. Versions before kernel 5.12-rc6 are affected'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-3483High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3444,High,2021-03-23T18:15:13.627,"'The bpf verifier in the Linux kernel did not properly handle mod32 destination register truncation when the source register was known to be 0. A local attacker with the ability to load bpf programs could use this gain out-of-bounds reads in kernel memory leading to information disclosure (kernel memory), and possibly out-of-bounds writes that could potentially lead to code execution. This issue was addressed in the upstream kernel in commit 9b00f1b78809 (""bpf: Fix truncation handling for mod32 dst reg wrt zero"") and in Linux stable kernels 5.11.2, 5.10.19, and 5.4.101.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3444High
linux-libc-dev,4.19.132-1,4.19.194-3,deb,CVE-2021-33909,High,2021-07-20T19:15:09.747,"'fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.'",linux-libc-dev4.19.132-14.19.194-3debCVE-2021-33909High
linux-libc-dev,4.19.132-1,4.19.177-1,deb,CVE-2021-3348,High,2021-02-01T04:15:14.430,"'nbd_add_socket in drivers/block/nbd.c in the Linux kernel through 5.10.12 has an ndb_queue_rq use-after-free that could be triggered by local attackers (with access to the nbd device) via an I/O request at a certain point during device setup, aka CID-b98e762e3d71.'",linux-libc-dev4.19.132-14.19.177-1debCVE-2021-3348High
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2021-3347,High,2021-01-29T17:15:12.950,"'An issue was discovered in the Linux kernel through 5.10.11. PI futexes have a kernel stack use-after-free during fault handling, allowing local users to execute code in the kernel, aka CID-34b1a1ce1458.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2021-3347High
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-33033,High,2021-05-14T23:15:09.780,"'The Linux kernel before 5.11.14 has a use-after-free in cipso_v4_genopt in net/ipv4/cipso_ipv4.c because the CIPSO and CALIPSO refcounting for the DOI definitions is mishandled, aka CID-ad5d07f4a9cd. This leads to writing an arbitrary value.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-33033High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-32399,High,2021-05-10T22:15:06.053,'net/bluetooth/hci_request.c in the Linux kernel through 5.12.2 has a race condition for removal of the HCI controller.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-32399High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-29154,High,2021-04-08T21:15:13.580,"'BPF JIT compilers in the Linux kernel through 5.11.12 have incorrect computation of branch displacements, allowing them to execute arbitrary code within the kernel context. This affects arch/x86/net/bpf_jit_comp.c and arch/x86/net/bpf_jit_comp32.c.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-29154High
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-28660,High,2021-03-17T15:15:13.593,'rtw_wx_set_scan in drivers/staging/rtl8188eu/os_dep/ioctl_linux.c in the Linux kernel through 5.11.6 allows writing beyond the end of the ->ssid[,linux-libc-dev4.19.132-14.19.181-1debCVE-2021-28660High
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-27365,High,2021-03-07T05:15:13.623,"'An issue was discovered in the Linux kernel through 5.11.3. Certain iSCSI data structures do not have appropriate length constraints or checks, and can exceed the PAGE_SIZE value. An unprivileged user can send a Netlink message that is associated with iSCSI, and has a length up to the maximum length of a Netlink message.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-27365High
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-27364,High,2021-03-07T05:15:13.437,'An issue was discovered in the Linux kernel through 5.11.3. drivers/scsi/scsi_transport_iscsi.c is adversely affected by the ability of an unprivileged user to craft Netlink messages.',linux-libc-dev4.19.132-14.19.181-1debCVE-2021-27364High
linux-libc-dev,4.19.132-1,4.19.177-1,deb,CVE-2021-26930,High,2021-02-17T01:15:13.157,"""An issue was discovered in the Linux kernel 3.11 through 5.10.16, as used by Xen. To service requests to the PV backend, the driver maps grant references provided by the frontend. In this process, errors may be encountered. In one case, an error encountered earlier might be discarded by later processing, resulting in the caller assuming successful mapping, and hence subsequent operations trying to access space that wasn't mapped. In another case, internal state would be insufficiently updated, preventing safe recovery from the error. This affects drivers/block/xen-blkback/blkback.c.""",linux-libc-dev4.19.132-14.19.177-1debCVE-2021-26930High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-23134,High,2021-05-12T23:15:07.707,"'Use After Free vulnerability in nfc sockets in the Linux Kernel before 5.12.4 allows local attackers to elevate their privileges. In typical configurations, the issue can only be triggered by a privileged local user with the CAP_NET_RAW capability.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-23134High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-23133,High,2021-04-22T18:15:08.123,'A race condition in Linux kernel SCTP sockets (net/sctp/socket.c) before 5.12-rc8 can lead to kernel privilege escalation from the context of a network service or an unprivileged process. If sctp_destroy_sock is called without sock_net(sk)->sctp.addr_wq_lock then an element is removed from the auto_asconf_splist list without any proper locking. This can be exploited by an attacker with network service privileges to escalate to root or from the context of an unprivileged user directly if a BPF_CGROUP_INET_SOCK_CREATE is attached which denies creation of some SCTP socket.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-23133High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-22600,High,2022-01-26T14:15:08.123,'A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-22600High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-22555,High,2021-07-07T12:15:08.453,'A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-22555High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-22543,High,2021-05-26T11:15:08.623,'An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-22543High
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-20322,High,2022-02-18T18:15:09.013,"'A flaw in the processing of received ICMP errors (ICMP fragment needed and ICMP redirect) in the Linux kernel functionality was found to allow the ability to quickly scan open UDP ports. This flaw allows an off-path remote user to effectively bypass the source port UDP randomization. The highest threat from this vulnerability is to confidentiality and possibly integrity, because software that relies on UDP source port randomization are indirectly affected as well.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-20322High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2021-1048,High,2021-12-15T19:15:14.917,"'In ep_loop_check_proc of eventpoll.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-204573007References: Upstream kernel'",linux-libc-dev4.19.132-14.19.146-1debCVE-2021-1048High
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-0512,High,2021-06-21T17:15:08.477,"'In __hidinput_change_resolution_multipliers of hid-input.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-173843328References: Upstream kernel'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-0512High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-36386,High,2021-06-07T20:15:08.287,"'An issue was discovered in the Linux kernel before 5.8.1. net/bluetooth/hci_event.c has a slab out-of-bounds read in hci_extended_inquiry_result_evt, aka CID-51c19bf3d5cf.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-36386High
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-36385,High,2021-06-07T12:15:08.417,"'An issue was discovered in the Linux kernel before 5.10. drivers/infiniband/core/ucma.c has a use-after-free because the ctx is reached via the ctx_list in some ucma_migrate_id situations where ucma_close is called, aka CID-f5449e74802c.'",linux-libc-dev4.19.132-1 debCVE-2020-36385High
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2020-35519,High,2021-05-06T15:15:07.860,"'An out-of-bounds (OOB) memory access flaw was found in x25_bind in net/x25/af_x25.c in the Linux kernel version v5.12-rc5. A bounds check failure allows a local attacker with a user account on the system to gain access to out-of-bounds memory, leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.'",linux-libc-dev4.19.132-14.19.171-1debCVE-2020-35519High
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-29661,High,2020-12-09T17:15:31.807,"'A locking issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_jobctrl.c allows a use-after-free attack against TIOCSPGRP, aka CID-54ffccbf053b.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-29661High
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-29569,High,2020-12-15T17:15:14.707,"'An issue was discovered in the Linux kernel through 5.10.1, as used with Xen through 4.14.x. The Linux kernel PV block backend expects the kernel thread handler to reset ring->xenblkd to NULL when stopped. However, the handler may not have time to run if the frontend quickly toggles between the states connect and disconnect. As a consequence, the block backend may re-use a pointer after it was freed. A misbehaving guest can trigger a dom0 crash by continuously connecting / disconnecting a block frontend. Privilege escalation and information leaks cannot be ruled out. This only affects systems with a Linux blkback.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-29569High
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-28374,High,2021-01-13T04:15:12.837,"'In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-28374High
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-27815,High,2021-05-26T13:15:07.647,"'A flaw was found in the JFS filesystem code in the Linux Kernel which allows a local attacker with the ability to set extended attributes to panic the system, causing memory corruption or escalating privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-27815High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-25705,High,2020-11-17T02:15:13.427,"'A flaw in ICMP packets in the Linux kernel may allow an attacker to quickly scan open UDP ports. This flaw allows an off-path remote attacker to effectively bypass source port UDP randomization. Software that relies on UDP source port randomization are indirectly affected as well on the Linux Based Products (RUGGEDCOM RM1224: All versions between v5.0 and v6.4, SCALANCE M-800: All versions between v5.0 and v6.4, SCALANCE S615: All versions between v5.0 and v6.4, SCALANCE SC-600: All versions prior to v2.1.3, SCALANCE W1750D: v8.3.0.1, v8.6.0, and v8.7.0, SIMATIC Cloud Connect 7: All versions, SIMATIC MV500 Family: All versions, SIMATIC NET CP 1243-1 (incl. SIPLUS variants): Versions 3.1.39 and later, SIMATIC NET CP 1243-7 LTE EU: Version'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-25705High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-25672,High,2021-05-25T20:15:07.557,'A memory leak vulnerability was found in Linux kernel in llcp_sock_connect',linux-libc-dev4.19.132-14.19.194-1debCVE-2020-25672High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-25671,High,2021-05-26T11:15:08.547,"'A vulnerability was found in Linux Kernel, where a refcount leak in llcp_sock_connect() causing use-after-free which might lead to privilege escalations.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-25671High
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-25670,High,2021-05-26T11:15:08.487,'A vulnerability was found in Linux Kernel where refcount leak in llcp_sock_bind() causing use-after-free which might lead to privilege escalations.',linux-libc-dev4.19.132-14.19.194-1debCVE-2020-25670High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-25669,High,2021-05-26T12:15:15.743,"'A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-25669High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-25668,High,2021-05-26T12:15:15.687,'A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-25668High
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-25645,High,2020-10-13T20:15:12.570,'A flaw was found in the Linux kernel in versions before 5.9-rc7. Traffic between two Geneve endpoints may be unencrypted when IPsec is configured to encrypt traffic for the specific UDP port used by the GENEVE tunnel allowing anyone between the two endpoints to read the traffic unencrypted. The main threat from this vulnerability is to data confidentiality.',linux-libc-dev4.19.132-14.19.152-1debCVE-2020-25645High
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-25643,High,2020-10-06T14:15:12.683,'A flaw was found in the HDLC_PPP module of the Linux kernel in versions before 5.9-rc7. Memory corruption and a read overflow is caused by improper input validation in the ppp_cp_parse_cr function which can cause the system to crash or cause a denial of service. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.',linux-libc-dev4.19.132-14.19.152-1debCVE-2020-25643High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-25212,High,2020-09-09T16:15:12.063,"'A TOCTOU mismatch in the NFS client code in the Linux kernel before 5.8.3 could be used by local attackers to corrupt memory or possibly have unspecified other impact because a size check is in fs/nfs/nfs4proc.c instead of fs/nfs/nfs4xdr.c, aka CID-b4487b935452.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-25212High
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2020-16119,High,2021-01-14T01:15:13.010,"'Use-after-free vulnerability in the Linux kernel exploitable by a local attacker due to reuse of a DCCP socket with an attached dccps_hc_tx_ccid object as a listener after being released. Fixed in Ubuntu Linux kernel 5.4.0-51.56, 5.3.0-68.63, 4.15.0-121.123, 4.4.0-193.224, 3.13.0.182.191 and 3.2.0-149.196.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2020-16119High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-14386,High,2020-09-16T13:15:11.083,'A flaw was found in the Linux kernel before 5.9-rc4. Memory corruption can be exploited to gain root privileges from unprivileged processes. The highest threat from this vulnerability is to data confidentiality and integrity.',linux-libc-dev4.19.132-14.19.146-1debCVE-2020-14386High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-14356,High,2020-08-19T15:15:12.060,'A flaw null pointer dereference in the Linux kernel cgroupv2 subsystem in versions before 5.7.10 was found in the way when reboot the system. A local user could use this flaw to crash the system or escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.146-1debCVE-2020-14356High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-14351,High,2020-12-03T17:15:12.270,'A flaw was found in the Linux kernel. A use-after-free memory flaw was found in the perf subsystem allowing a local attacker with permission to monitor perf events to corrupt memory and possibly escalate privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-14351High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2020-12362,High,2021-02-17T14:15:15.123,'Integer overflow in the firmware for some Intel(R) Graphics Drivers for Windows * before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable an escalation of privilege via local access.',linux-libc-dev4.19.132-1(won't fix)debCVE-2020-12362High
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-12351,High,2020-11-23T17:15:12.250,'Improper input validation in BlueZ may allow an unauthenticated user to potentially enable escalation of privilege via adjacent access.',linux-libc-dev4.19.132-14.19.152-1debCVE-2020-12351High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-0466,High,2020-12-14T22:15:14.287,"'In do_epoll_ctl and ep_loop_check_proc of eventpoll.c, there is a possible use after free due to a logic error. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-147802478References: Upstream kernel'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-0466High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-0423,High,2020-10-14T14:15:17.280,"'In binder_release_work of binder.c, there is a possible use-after-free due to improper locking. This could lead to local escalation of privilege in the kernel with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-161151868References: N/A'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-0423High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2019-19816,High,2019-12-17T06:15:12.907,"'In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image and performing some operations can cause slab-out-of-bounds write access in __btrfs_map_block in fs/btrfs/volumes.c, because a value of 1 for the number of data stripes is mishandled.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2019-19816High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2019-19814,High,2019-12-17T06:15:12.843,"'In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.'",linux-libc-dev4.19.132-1(won't fix)debCVE-2019-19814High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2019-19770,High,2019-12-12T20:15:17.787,"'In the Linux kernel 4.19.83, there is a use-after-free (read) in the debugfs_remove function in fs/debugfs/inode.c (which is used to remove a file or directory in debugfs that was previously created with a call to another debugfs function such as debugfs_create_file). NOTE: Linux kernel developers dispute this issue as not being an issue with debugfs, instead this is an issue with misuse of debugfs within blktrace'",linux-libc-dev4.19.132-14.19.160-1debCVE-2019-19770High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2019-19449,High,2019-12-08T02:15:09.970,"'In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).'",linux-libc-dev4.19.132-1(won't fix)debCVE-2019-19449High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19448,High,2019-12-08T02:15:09.907,"'In the Linux kernel 5.0.21 and 5.3.11, mounting a crafted btrfs filesystem image, performing some operations, and then making a syncfs system call can lead to a use-after-free in try_merge_free_space in fs/btrfs/free-space-cache.c because the pointer to a left data structure can be the same as the pointer to a right data structure.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19448High
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2019-19377,High,2019-11-29T16:15:10.517,"'In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image, performing some operations, and unmounting can lead to a use-after-free in btrfs_queue_work in fs/btrfs/async-thread.c.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2019-19377High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19074,High,2019-11-18T06:15:13.280,"'A memory leak in the ath9k_wmi_cmd() function in drivers/net/wireless/ath/ath9k/wmi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-728c1e2a05e4.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19074High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19061,High,2019-11-18T06:15:12.403,"'A memory leak in the adis_update_scan_mode_burst() function in drivers/iio/imu/adis_buffer.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-9c0530e898f3.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19061High
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-0145,High,2019-11-14T19:15:12.207,'Buffer overflow in i40e driver for Intel(R) Ethernet 700 Series Controllers versions before 7.0 may allow an authenticated user to potentially enable an escalation of privilege via local access.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-0145High
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2013-7445,High,2015-10-16T01:59:00.120,"'The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.'",linux-libc-dev4.19.132-1(won't fix)debCVE-2013-7445High
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-45863,Medium,2023-10-14T21:15:45.233,"'An issue was discovered in lib/kobject.c in the Linux kernel before 6.2.3. With root access, an attacker can trigger a race condition that results in a fill_kobj_path out-of-bounds write.'",linux-libc-dev4.19.132-1 debCVE-2023-45863Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4569,Medium,2023-08-28T22:15:10.487,"'A memory leak flaw was found in nft_set_catchall_flush in net/netfilter/nf_tables_api.c in the Linux Kernel. This issue may allow a local attacker to cause double-deactivations of catchall elements, which can result in a memory leak.'",linux-libc-dev4.19.132-1 debCVE-2023-4569Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2023-4459,Medium,2023-08-21T19:15:09.373,'A NULL pointer dereference flaw was found in vmxnet3_rq_cleanup in drivers/net/vmxnet3/vmxnet3_drv.c in the networking sub-component in vmxnet3 in the Linux Kernel. This issue may allow a local attacker with normal user privilege to cause a denial of service due to a missing sanity check during cleanup.',linux-libc-dev4.19.132-14.19.249-1debCVE-2023-4459Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-42755,Medium,2023-10-05T19:15:11.497,"'A flaw was found in the IPv4 Resource Reservation Protocol (RSVP) classifier in the Linux kernel. The xprt pointer may go beyond the linear part of the skb, leading to an out-of-bounds read in the `rsvp_classify` function. This issue may allow a local user to crash the system and cause a denial of service.'",linux-libc-dev4.19.132-1 debCVE-2023-42755Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-42754,Medium,2023-10-05T19:15:11.413,"'A NULL pointer dereference flaw was found in the Linux kernel ipv4 stack. The socket buffer (skb) was assumed to be associated with a device before calling __ip_options_compile, which is not always the case if the skb is re-routed by ipvs. This issue may allow a local user with CAP_NET_ADMIN privileges to crash the system.'",linux-libc-dev4.19.132-1 debCVE-2023-42754Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4273,Medium,2023-08-09T15:15:09.823,"'A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.'",linux-libc-dev4.19.132-1 debCVE-2023-4273Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4194,Medium,2023-08-07T14:15:11.743,"'A flaw was found in the Linux kernel\'s TUN/TAP functionality. This issue could allow a local user to bypass network filters and gain unauthorized access to some resources. The original patches fixing CVE-2023-1076 are incorrect or incomplete. The problem is that the following upstream commits - a096ccca6e50 (""tun: tun_chr_open(): correctly initialize socket uid""), - 66b2c338adce (""tap: tap_open(): correctly initialize socket uid""), pass ""inode->i_uid"" to sock_init_data_uid() as the last parameter and that turns out to not be accurate.'",linux-libc-dev4.19.132-1 debCVE-2023-4194Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4133,Medium,2023-08-03T15:15:33.940,"'A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.'",linux-libc-dev4.19.132-1 debCVE-2023-4133Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4132,Medium,2023-08-03T15:15:32.833,"'A use-after-free vulnerability was found in the siano smsusb module in the Linux kernel. The bug occurs during device initialization when the siano device is plugged in. This flaw allows a local user to crash the system, causing a denial of service condition.'",linux-libc-dev4.19.132-1 debCVE-2023-4132Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-4010,Medium,2023-07-31T17:15:10.277,"'A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.'",linux-libc-dev4.19.132-1 debCVE-2023-4010Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-39194,Medium,2023-10-09T18:15:10.367,"'A flaw was found in the XFRM subsystem in the Linux kernel. The specific flaw exists within the processing of state filters, which can result in a read past the end of an allocated buffer. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, potentially leading to an information disclosure.'",linux-libc-dev4.19.132-1 debCVE-2023-39194Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-39193,Medium,2023-10-09T18:15:10.303,"'A flaw was found in the Netfilter subsystem in the Linux kernel. The sctp_mt_check did not validate the flag_count field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.'",linux-libc-dev4.19.132-1 debCVE-2023-39193Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-39192,Medium,2023-10-09T18:15:10.233,"'A flaw was found in the Netfilter subsystem in the Linux kernel. The xt_u32 module did not validate the fields in the xt_u32 structure. This flaw allows a local privileged attacker to trigger an out-of-bounds read by setting the size fields with a value beyond the array boundaries, leading to a crash or information disclosure.'",linux-libc-dev4.19.132-1 debCVE-2023-39192Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-39189,Medium,2023-10-09T18:15:10.160,"'A flaw was found in the Netfilter subsystem in the Linux kernel. The nfnl_osf_add_callback function did not validate the user mode controlled opt_num field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.'",linux-libc-dev4.19.132-1 debCVE-2023-39189Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3863,Medium,2023-07-24T15:15:09.397,'A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.',linux-libc-dev4.19.132-1 debCVE-2023-3863Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3772,Medium,2023-07-25T16:15:11.660,"'A flaw was found in the Linux kernels IP framework for transforming packets (XFRM subsystem). This issue may allow a malicious user with CAP_NET_ADMIN privileges to directly dereference a NULL pointer in xfrm_update_ae_params(), leading to a possible kernel crash and denial of service.'",linux-libc-dev4.19.132-1 debCVE-2023-3772Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-37454,Medium,2023-07-06T17:15:14.240,'An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.',linux-libc-dev4.19.132-1 debCVE-2023-37454Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-37453,Medium,2023-07-06T17:15:14.187,'An issue was discovered in the USB subsystem in the Linux kernel through 6.4.2. There is an out-of-bounds and crash in read_descriptors in drivers/usb/core/sysfs.c.',linux-libc-dev4.19.132-1 debCVE-2023-37453Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-34256,Medium,2023-05-31T20:15:10.817,"'An issue was discovered in the Linux kernel before 6.3.3. There is an out-of-bounds read in crc16 in lib/crc16.c when called from fs/ext4/super.c because ext4_group_desc_csum does not properly check an offset. NOTE: this is disputed by third parties because the kernel is not intended to defend against attackers with the stated ""When modifying the block device while it is mounted by the filesystem"" access.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-34256Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-3358,Medium,2023-06-28T22:15:09.647,"""A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.""",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-3358Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-3338,Medium,2023-06-30T22:15:10.270,"""A null pointer dereference flaw was found in the Linux kernel's DECnet networking protocol. This issue could allow a remote user to crash the system.""",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-3338Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-33288,Medium,2023-05-22T03:15:09.797,'An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.',linux-libc-dev4.19.132-1 debCVE-2023-33288Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-33203,Medium,2023-05-18T08:15:08.723,'The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/net/ethernet/qualcomm/emac/emac.c if a physically proximate attacker unplugs an emac based device.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-33203Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-32269,Medium,2023-05-05T17:15:09.623,"'An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-32269Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-3220,Medium,2023-06-20T20:15:09.737,'An issue was discovered in the Linux kernel through 6.1-rc8. dpu_crtc_atomic_check in drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c lacks check of the return value of kzalloc() and will cause the NULL Pointer Dereference.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-3220Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3212,Medium,2023-06-23T20:15:09.563,'A NULL pointer dereference issue was found in the gfs2 file system in the Linux kernel. It occurs on corrupt gfs2 file systems when the evict code tries to reference the journal descriptor structure after it has been freed and set to NULL. A privileged local user could use this flaw to cause a kernel panic.',linux-libc-dev4.19.132-1 debCVE-2023-3212Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-3161,Medium,2023-06-12T20:15:12.910,"'A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-3161Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2023-3159,Medium,2023-06-12T21:15:22.937,'A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.',linux-libc-dev4.19.132-14.19.249-1debCVE-2023-3159Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-31084,Medium,2023-04-24T06:15:07.997,"'An issue was discovered in drivers/media/dvb-core/dvb_frontend.c in the Linux kernel 6.2. There is a blocking operation when a task is in !TASK_RUNNING. In dvb_frontend_get_event, wait_event_interruptible is called; the condition is dvb_frontend_test_event(fepriv,events). In dvb_frontend_test_event, down(&fepriv->sem) is called. However, wait_event_interruptible would put the process to sleep, and down(&fepriv->sem) may block the process.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-31084Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-31083,Medium,2023-04-24T06:15:07.890,"'An issue was discovered in drivers/bluetooth/hci_ldisc.c in the Linux kernel 6.2. In hci_uart_tty_ioctl, there is a race condition between HCIUARTSETPROTO and HCIUARTGETPROTO. HCI_UART_PROTO_SET is set before hu->proto is set. A NULL pointer dereference may occur.'",linux-libc-dev4.19.132-1 debCVE-2023-31083Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-31082,Medium,2023-04-24T06:15:07.783,"'An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel.'",linux-libc-dev4.19.132-1 debCVE-2023-31082Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-30772,Medium,2023-04-16T04:15:08.573,'The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/power/supply/da9150-charger.c if a physically proximate attacker unplugs a device.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-30772Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-30456,Medium,2023-04-10T02:15:06.853,'An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-30456Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-3022,Medium,2023-06-19T18:15:09.870,"'A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.'",linux-libc-dev4.19.132-1 debCVE-2023-3022Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2023-3006,Medium,2023-05-31T20:15:11.127,"""A known cache speculation vulnerability, known as Branch History Injection (BHI) or Spectre-BHB, becomes actual again for the new hw AmpereOne. Spectre-BHB is similar to Spectre v2, except that malicious code uses the shared branch history (stored in the CPU Branch History Buffer, or BHB) to influence mispredicted branches within the victim's hardware context. Once that occurs, speculation caused by the mispredicted branches can cause cache allocation. This issue leads to obtaining information that should not be accessible.""",linux-libc-dev4.19.132-1(won't fix)debCVE-2023-3006Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-2985,Medium,2023-06-01T01:15:17.970,'A use after free flaw was found in hfsplus_put_super in fs/hfsplus/super.c in the Linux Kernel. This flaw could allow a local user to cause a denial of service problem.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-2985Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2023-28772,Medium,2023-03-23T15:15:12.177,'An issue was discovered in the Linux kernel before 5.13.3. lib/seq_buf.c has a seq_buf_putmem_hex buffer overflow.',linux-libc-dev4.19.132-14.19.208-1debCVE-2023-28772Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2023-2860,Medium,2023-07-24T16:15:11.293,"'An out-of-bounds read vulnerability was found in the SR-IPv6 implementation in the Linux kernel. The flaw exists within the processing of seg6 attributes. The issue results from the improper validation of user-supplied data, which can result in a read past the end of an allocated buffer. This flaw allows a privileged local user to disclose sensitive information on affected installations of the Linux kernel.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2023-2860Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-28328,Medium,2023-04-19T23:15:07.163,'A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-28328Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-26545,Medium,2023-02-25T04:15:10.127,"'In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-26545Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2023-2513,Medium,2023-05-08T21:15:11.077,"""A use-after-free vulnerability was found in the Linux kernel's ext4 filesystem in the way it handled the extra inode size for extended attributes. This flaw could allow a privileged local user to cause a system crash or other undefined behaviors.""",linux-libc-dev4.19.132-14.19.260-1debCVE-2023-2513Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-23455,Medium,2023-01-12T07:15:09.953,'atm_tc_enqueue in net/sched/sch_atm.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-23455Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-23454,Medium,2023-01-12T07:15:08.193,'cbq_classify in net/sched/sch_cbq.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service (slab-out-of-bounds read) because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-23454Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-2269,Medium,2023-04-25T21:15:10.627,"'A denial of service problem was found, due to a possible recursive locking scenario, resulting in a deadlock in table_clear in drivers/md/dm-ioctl.c in the Linux Kernel Device Mapper-Multipathing sub-component.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-2269Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-2194,Medium,2023-04-20T21:15:09.047,"'An out-of-bounds write vulnerability was found in the Linux kernel\'s SLIMpro I2C device driver. The userspace ""data->block[0",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-2194Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-2177,Medium,2023-04-20T21:15:08.997,"'A null pointer dereference issue was found in the sctp network protocol in net/sctp/stream_sched.c in Linux Kernel. If stream_in allocation is failed, stream_out is freed which would further be accessed. A local user could use this flaw to crash the system or potentially cause a denial of service.'",linux-libc-dev4.19.132-1 debCVE-2023-2177Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-2162,Medium,2023-04-19T20:15:12.307,'A use-after-free vulnerability was found in iscsi_sw_tcp_session_create in drivers/scsi/iscsi_tcp.c in SCSI sub-component in the Linux Kernel. In this flaw an attacker could leak kernel internal information.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-2162Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-20593,Medium,2023-07-24T20:15:10.237,"'\nAn issue in Zen 2 CPUs, under specific microarchitectural circumstances, may allow an attacker to potentially access sensitive information.\n\n\n\n\n\n\n'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-20593Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2023-20569,Medium,2023-08-08T18:15:11.530,"'\n\n\nA side channel vulnerability on some of the AMD CPUs may allow an attacker to influence the return address prediction. This may result in speculative execution at an attacker-controlled\u202faddress, potentially leading to information disclosure.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'",linux-libc-dev4.19.132-1(won't fix)debCVE-2023-20569Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2023-2002,Medium,2023-05-26T17:15:14.113,"'A vulnerability was found in the HCI sockets implementation due to a missing capability check in net/bluetooth/hci_sock.c in the Linux Kernel. This flaw allows an attacker to unauthorized execution of management commands, compromising the confidentiality, integrity, and availability of Bluetooth communication.'",linux-libc-dev4.19.132-14.19.289-1debCVE-2023-2002Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1998,Medium,2023-04-21T15:15:07.080,"'The Linux kernel allows userspace processes to enable mitigations by calling prctl with PR_SET_SPECULATION_CTRL which disables the speculation feature as well as by using seccomp. We had noticed that on VMs of at least one major cloud provider, the kernel still left the victim process exposed to attacks in some cases even after enabling the spectre-BTI mitigation with prctl. The same behavior can be observed on a bare-metal machine when forcing the mitigation to IBRS on boot command line.\n\nThis happened because when plain IBRS was enabled (not enhanced IBRS), the kernel had some logic that determined that STIBP was not needed. The IBRS bit implicitly protects against cross-thread branch target injection. However, with legacy IBRS, the IBRS bit was cleared on returning to userspace, due to performance reasons, which disabled the implicit STIBP and left userspace threads vulnerable to cross-thread branch target injection against which STIBP protects.\n\n\n'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1998Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1990,Medium,2023-04-12T20:15:07.233,'A use-after-free flaw was found in ndlc_remove in drivers/nfc/st-nci/ndlc.c in the Linux Kernel. This flaw could allow an attacker to crash the system due to a race problem.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1990Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1859,Medium,2023-05-17T23:15:09.100,"'A use-after-free flaw was found in xen_9pfs_front_removet in net/9p/trans_xen.c in Xen transport for 9pfs in the Linux Kernel. This flaw could allow a local attacker to crash the system due to a race problem, possibly leading to a kernel information leak.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1859Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1855,Medium,2023-04-05T20:15:07.817,'A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1855Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1582,Medium,2023-04-05T20:15:07.663,'A race problem was found in fs/proc/task_mmu.c in the memory management sub-component in the Linux kernel. This issue may allow a local attacker with user privilege to cause a denial of service.',linux-libc-dev4.19.132-1 debCVE-2023-1582Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2023-1382,Medium,2023-04-19T23:15:06.903,"'A data race flaw was found in the Linux kernel, between where con is allocated and con->sock is set. This issue leads to a NULL pointer dereference when accessing con->sock->sk in net/tipc/topsrv.c in the tipc protocol in the Linux kernel.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2023-1382Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1249,Medium,2023-03-23T21:15:19.217,"'A use-after-free flaw was found in the Linux kernels core dump subsystem. This flaw allows a local user to crash the system. Only if patch 390031c94211 (""coredump: Use the vma snapshot in fill_files_note"") not applied yet, then kernel could be affected.'",linux-libc-dev4.19.132-1 debCVE-2023-1249Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1206,Medium,2023-06-30T22:15:09.747,'A hash collision flaw was found in the IPv6 connection lookup table in the Linux kernels IPv6 functionality when a user makes a new kind of SYN flood attack. A user located in the local network or with a high bandwidth connection can increase the CPU usage of the server that accepts IPV6 connections up to 95%.',linux-libc-dev4.19.132-1 debCVE-2023-1206Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1192,Medium,2023-11-01T20:15:08.597,"'A use-after-free flaw was found in smb2_is_status_io_timeout() in CIFS in the Linux Kernel. After CIFS transfers response data to a system call, there are still local variable points to the memory region, and if the system call frees it faster than CIFS uses it, CIFS will access a free memory region, leading to a denial of service.'",linux-libc-dev4.19.132-1 debCVE-2023-1192Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2023-1095,Medium,2023-02-28T23:15:11.460,"'In nf_tables_updtable, if nf_tables_table_enable returns an error, nft_trans_destroy is called to free the transaction object. nft_trans_destroy() calls list_del(), but the transaction was never placed on a list -- the list head is all zeroes, this results in a NULL pointer dereference.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2023-1095Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1079,Medium,2023-03-27T21:15:10.573,"'A flaw was found in the Linux kernel. A use-after-free may be triggered in asus_kbd_backlight_set when plugging/disconnecting in a malicious USB device, which advertises itself as an Asus device. Similarly to the previous known CVE-2023-25012, but in asus devices, the work_struct may be scheduled by the LED controller while the device is disconnecting, triggering a use-after-free on the struct asus_kbd_leds *led structure. A malicious USB device may exploit the issue to cause memory corruption with controlled data.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1079Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-1076,Medium,2023-03-27T21:15:10.423,"'A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.'",linux-libc-dev4.19.132-1 debCVE-2023-1076Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1074,Medium,2023-03-27T21:15:10.330,"""A memory leak flaw was found in the Linux kernel's Stream Control Transmission Protocol. This issue may occur when a user starts a malicious networking service and someone connects to this service. This could allow a local user to starve resources, causing a denial of service.""",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1074Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1073,Medium,2023-03-27T21:15:10.287,'A memory corruption flaw was found in the Linux kernels human interface device (HID) subsystem in how a user inserts a malicious USB device. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1073Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-0615,Medium,2023-02-06T23:15:09.933,"'A memory leak flaw and potential divide by zero and Integer overflow was found in the Linux kernel V4L2 and vivid test code functionality. This issue occurs when a user triggers ioctls, such as VIDIOC_S_DV_TIMINGS ioctl. This could allow a local user to crash the system if vivid test code enabled.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-0615Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-0597,Medium,2023-02-23T20:15:12.927,'A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.',linux-libc-dev4.19.132-1 debCVE-2023-0597Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-0590,Medium,2023-03-23T21:15:19.150,"'A use-after-free flaw was found in qdisc_graft in net/sched/sch_api.c in the Linux Kernel due to a race problem. This flaw leads to a denial of service issue. If patch ebda44da44f6 (""net: sched: fix race condition in qdisc_graft()"") not applied yet, then kernel could be affected.'",linux-libc-dev4.19.132-1 debCVE-2023-0590Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-0459,Medium,2023-05-25T14:15:09.603,"'Copy_from_user on 64-bit versions of the Linux kernel does not implement the __uaccess_begin_nospec allowing a user to bypass the ""access_ok"" check and pass a kernel pointer to copy_from_user(). This would allow an attacker to leak information. We recommend upgrading beyond commit\xa074e19ef0ff8061ef55957c3abd71614ef0f42f47'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-0459Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-0458,Medium,2023-04-26T19:15:08.720,"""A speculative pointer dereference problem exists in the Linux Kernel on the do_prlimit() function. The resource argument value is controlled and is used in pointer arithmetic for the 'rlim' variable and can be used to leak the contents. We recommend upgrading past version 6.1.8 or commit\xa0739790605705ddcf18f21782b9c99ad7d53a8c11""",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-0458Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-0394,Medium,2023-01-26T21:18:07.490,'A NULL pointer dereference flaw was found in rawv6_push_pending_frames in net/ipv6/raw.c in the network subcomponent in the Linux kernel. This flaw causes the system to crash.',linux-libc-dev4.19.132-14.19.282-1debCVE-2023-0394Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-0160,Medium,2023-07-18T17:15:11.313,'A deadlock flaw was found in the Linux kernels BPF subsystem. This flaw allows a local user to potentially crash the system.',linux-libc-dev4.19.132-1 debCVE-2023-0160Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-47929,Medium,2023-01-17T21:15:14.590,"'In the Linux kernel before 6.1.6, a NULL pointer dereference bug in the traffic control subsystem allows an unprivileged user to trigger a denial of service (system crash) via a crafted traffic control configuration that is set up with ""tc qdisc"" and ""tc class"" commands. This affects qdisc_graft in net/sched/sch_api.c.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2022-47929Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-4662,Medium,2022-12-22T22:15:16.940,'A flaw incorrect access control in the Linux kernel USB core subsystem was found in the way user attaches usb device. A local user could use this flaw to crash the system.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-4662Medium
linux-libc-dev,4.19.132-1,4.19.289-1,deb,CVE-2022-45887,Medium,2022-11-25T04:15:09.317,'An issue was discovered in the Linux kernel through 6.0.9. drivers/media/usb/ttusb-dec/ttusb_dec.c has a memory leak because of the lack of a dvb_frontend_detach call.',linux-libc-dev4.19.132-14.19.289-1debCVE-2022-45887Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-4543,Medium,2023-01-11T15:15:09.673,"'A flaw named ""EntryBleed"" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.'",linux-libc-dev4.19.132-1 debCVE-2022-4543Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-4382,Medium,2023-01-10T22:15:14.183,'A use-after-free flaw caused by a race among the superblock operations in the gadgetfs Linux driver was found. It could be triggered by yanking out a device that is running the gadgetfs side.',linux-libc-dev4.19.132-1 debCVE-2022-4382Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-43750,Medium,2022-10-26T04:15:13.990,"""drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15 and 6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal memory.""",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-43750Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-42895,Medium,2022-11-23T15:15:10.557,"""There is an infoleak vulnerability in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_parse_conf_req function which can be used to leak kernel pointers remotely.\nWe recommend upgrading past commit\xa0 https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e https://www.google.com/url \n\n""",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-42895Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-42703,Medium,2022-10-09T23:15:09.523,'mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-42703Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-4269,Medium,2022-12-05T16:15:10.283,"'A flaw was found in the Linux kernel Traffic Control (TC) subsystem. Using a specific networking configuration (redirecting egress packets to ingress using TC action ""mirred"") a local unprivileged user could trigger a CPU soft lockup (ABBA deadlock) when the transport protocol in use (TCP or SCTP) does a retransmission, resulting in a denial of service condition.'",linux-libc-dev4.19.132-1 debCVE-2022-4269Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-42329,Medium,2022-12-07T01:15:11.323,'Guests can trigger deadlock in Linux netback driver T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.,linux-libc-dev4.19.132-14.19.269-1debCVE-2022-42329Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-42328,Medium,2022-12-07T01:15:11.273,'Guests can trigger deadlock in Linux netback driver T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.,linux-libc-dev4.19.132-14.19.269-1debCVE-2022-42328Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-41850,Medium,2022-09-30T06:15:12.537,'roccat_report_event in drivers/hid/hid-roccat.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free in certain situations where a report is received while copying a report->value is in progress.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-41850Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-41849,Medium,2022-09-30T06:15:12.110,"'drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-41849Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-4129,Medium,2022-11-28T22:15:11.180,"""A flaw was found in the Linux kernel's Layer 2 Tunneling Protocol (L2TP). A missing lock when clearing sk_user_data can lead to a race condition and NULL pointer dereference. A local user could use this flaw to potentially crash the system causing a denial of service.""",linux-libc-dev4.19.132-1 debCVE-2022-4129Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-41218,Medium,2022-09-21T07:15:08.643,"'In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2022-41218Medium
linux-libc-dev,4.19.132-1,4.19.289-2,deb,CVE-2022-40982,Medium,2023-08-11T03:15:14.823,'Information exposure through microarchitectural state after transient execution in certain vector execution units for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.289-2debCVE-2022-40982Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-40768,Medium,2022-09-18T05:15:08.860,'drivers/scsi/stex.c in the Linux kernel through 5.19.9 allows local users to obtain sensitive information from kernel memory because stex_queuecommand_lck lacks a memset for the PASSTHRU_CMD case.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-40768Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-40307,Medium,2022-09-09T05:15:07.877,'An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-40307Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-39842,Medium,2022-09-05T07:15:08.170,"'An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-39842Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-39188,Medium,2022-09-02T05:15:07.650,"'An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-39188Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3903,Medium,2022-11-14T21:15:17.637,"'An incorrect read request flaw was found in the Infrared Transceiver USB driver in the Linux kernel. This issue occurs when a user attaches a malicious USB device. A local user could use this flaw to starve the resources, causing denial of service or potentially crashing the system.'",linux-libc-dev4.19.132-1 debCVE-2022-3903Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-3707,Medium,2023-03-06T23:15:10.933,"'A double-free memory flaw was found in the Linux kernel. The Intel GVT-g graphics driver triggers VGA card system resource overload, causing a fail in the intel_gvt_dma_map_guest_page function. This issue could allow a local user to crash the system.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2022-3707Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-36879,Medium,2022-07-27T04:15:10.740,'An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-36879Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3646,Medium,2022-10-21T18:15:10.103,"'A vulnerability, which was classified as problematic, has been found in Linux Kernel. This issue affects the function nilfs_attach_log_writer of the file fs/nilfs2/segment.c of the component BPF. The manipulation leads to memory leak. The attack may be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211961 was assigned to this vulnerability.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3646Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3643,Medium,2022-12-07T01:15:11.207,"'Guests can trigger NIC interface reset/abort/crash via netback It is possible for a guest to trigger a NIC interface reset/abort/crash in a Linux based network backend by sending certain kinds of packets. It appears to be an (unwritten?) assumption in the rest of the Linux network stack that packet protocol headers are all contained within the linear section of the SKB and some NICs behave badly if this is not the case. This has been reported to occur with Cisco (enic) and Broadcom NetXtrem II BCM5780 (bnx2x) though it may be an issue with other NICs/drivers as well. In case the frontend is sending requests with split headers, netback will forward those violating above mentioned assumption to the networking core, resulting in said misbehavior.'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3643Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-36280,Medium,2022-09-09T15:15:10.497,"""An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).""",linux-libc-dev4.19.132-14.19.282-1debCVE-2022-36280Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3628,Medium,2023-01-12T19:15:24.213,'A buffer overflow flaw was found in the Linux kernel Broadcom Full MAC Wi-Fi driver. This issue occurs when a user connects to a malicious USB device. This can allow a local user to crash the system or escalate their privileges.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3628Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3621,Medium,2022-10-20T20:15:09.770,'A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_bmap_lookup_at_level of the file fs/nilfs2/inode.c of the component nilfs2. The manipulation leads to null pointer dereference. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211920.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3621Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3594,Medium,2022-10-18T20:15:09.620,'A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function intr_callback of the file drivers/net/usb/r8152.c of the component BPF. The manipulation leads to logging of excessive data. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211363.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3594Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-3586,Medium,2022-10-19T18:15:13.113,"'A flaw was found in the Linux kernels networking code. A use-after-free was found in the way the sch_sfb enqueue function used the socket buffer (SKB) cb field after the same SKB had been enqueued (and freed) into a child qdisc. This flaw allows a local, unprivileged user to crash the system, causing a denial of service.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-3586Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3567,Medium,2022-10-17T19:15:10.400,'A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.',linux-libc-dev4.19.132-1 debCVE-2022-3567Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3524,Medium,2022-10-16T10:15:10.273,'A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function ipv6_renew_options of the component IPv6 Handler. The manipulation leads to memory leak. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211021 was assigned to this vulnerability.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3524Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3523,Medium,2022-10-16T10:15:10.193,'A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.',linux-libc-dev4.19.132-1 debCVE-2022-3523Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-33744,Medium,2022-07-05T13:15:08.653,"""Arm guests can cause Dom0 DoS via PV devices When mapping pages of guests on Arm, dom0 is using an rbtree to keep track of the foreign mappings. Updating of that rbtree is not always done completely with the related lock held, resulting in a small race window, which can be used by unprivileged guests via PV devices to cause inconsistencies of the rbtree. These inconsistencies can lead to Denial of Service (DoS) of dom0, e.g. by causing crashes or the inability to perform further mappings of other guests' memory pages.""",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-33744Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3344,Medium,2022-10-25T17:15:57.087,"""A flaw was found in the KVM's AMD nested virtualization (SVM). A malicious L1 guest could purposely fail to intercept the shutdown of a cooperative nested guest (L2), possibly leading to a page fault and kernel panic in the host (L0).""",linux-libc-dev4.19.132-1 debCVE-2022-3344Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3303,Medium,2022-09-27T23:15:15.783,"'A race condition flaw was found in the Linux kernel sound subsystem due to improper locking. It could lead to a NULL pointer dereference while handling the SNDCTL_DSP_SYNC ioctl. A privileged local user (root or member of the audio group) could use this flaw to crash the system, resulting in a denial of service condition'",linux-libc-dev4.19.132-1 debCVE-2022-3303Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3169,Medium,2022-09-09T15:15:15.067,"'A flaw was found in the Linux kernel. A denial of service flaw may occur if there is a consecutive request of the NVME_IOCTL_RESET and the NVME_IOCTL_SUBSYS_RESET through the device file of the driver, resulting in a PCIe link disconnect.'",linux-libc-dev4.19.132-1 debCVE-2022-3169Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3115,Medium,2022-12-14T21:15:12.917,'An issue was discovered in the Linux kernel through 5.16-rc6. malidp_crtc_reset in drivers/gpu/drm/arm/malidp_crtc.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.',linux-libc-dev4.19.132-1 debCVE-2022-3115Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-3111,Medium,2022-12-14T21:15:12.407,"'An issue was discovered in the Linux kernel through 5.16-rc6. free_charger_irq() in drivers/power/supply/wm8350_power.c lacks free of WM8350_IRQ_CHG_FAST_RDY, which is registered in wm8350_init_charger().'",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-3111Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3108,Medium,2022-12-14T21:15:12.087,'An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().',linux-libc-dev4.19.132-1 debCVE-2022-3108Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-3107,Medium,2022-12-14T21:15:11.943,'An issue was discovered in the Linux kernel through 5.16-rc6. netvsc_get_ethtool_stats in drivers/net/hyperv/netvsc_drv.c lacks check of the return value of kvmalloc_array() and will cause the null pointer dereference.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-3107Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-3061,Medium,2022-09-01T18:15:09.340,"""Found Linux Kernel flaw in the i740 driver. The Userspace program could pass any values to the driver through ioctl() interface. The driver doesn't check the value of 'pixclock', so it may cause a divide by zero error.""",linux-libc-dev4.19.132-1 debCVE-2022-3061Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-2991,Medium,2022-08-25T18:15:10.363,"""A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.""",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-2991Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-29901,Medium,2022-07-12T19:15:08.437,'Intel microprocessor generations 6 to 8 are affected by a new Spectre variant that is able to bypass their retpoline mitigation in the kernel to leak arbitrary data. An attacker with unprivileged user access can hijack return instructions to achieve arbitrary speculative code execution under certain microarchitecture-dependent conditions.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-29901Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2022-2873,Medium,2022-08-22T15:15:15.770,'An out-of-bounds memory access flaw was found in the Linux kernel Intels iSMT SMBus host controller driver in the way a user triggers the I2C_SMBUS_BLOCK_DATA (with the ioctl I2C_SMBUS) with malicious input data. This flaw allows a local user to crash the system.',linux-libc-dev4.19.132-14.19.282-1debCVE-2022-2873Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-28389,Medium,2022-04-03T21:15:08.120,'mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-28389Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-28388,Medium,2022-04-03T21:15:08.070,'usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-28388Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-28356,Medium,2022-04-02T21:15:09.363,"'In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-28356Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-2663,Medium,2022-09-01T21:15:09.653,'An issue was found in the Linux kernel in nf_conntrack_irc where the message handling can be confused and incorrectly matches the message. A firewall may be able to be bypassed when users are using unencrypted IRC with nf_conntrack_irc configured.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-2663Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-26373,Medium,2022-08-18T20:15:11.000,'Non-transparent sharing of return predictor targets between contexts in some Intel(R) Processors may allow an authorized user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-26373Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-25375,Medium,2022-02-20T20:15:18.117,'An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-25375Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-25258,Medium,2022-02-16T20:15:07.517,'An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-25258Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-2503,Medium,2022-08-12T11:15:07.933,"'Dm-verity is used for extending root-of-trust to root filesystems. LoadPin builds on this property to restrict module/firmware loads to just the trusted root filesystem. Device-mapper table reloads currently allow users with root privileges to switch out the target with an equivalent dm-linear target and bypass verification till reboot. This allows root to bypass LoadPin and can be used to load untrusted and unverified kernel modules and firmware, which implies arbitrary kernel execution and persistence for peripherals that do not verify firmware updates. We recommend upgrading past commit 4caae58406f8ceb741603eee460d79bacca9b1b5'",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-2503Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-24959,Medium,2022-02-11T06:15:06.800,'An issue was discovered in the Linux kernel before 5.16.5. There is a memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-24959Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-23960,Medium,2022-03-13T00:15:07.990,"'Certain Arm Cortex and Neoverse processors through 2022-03-08 do not properly restrict cache speculation, aka Spectre-BHB. An attacker can leverage the shared branch history in the Branch History Buffer (BHB) to influence mispredicted branches. Then, cache allocation can allow the attacker to obtain sensitive information.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-23960Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-2380,Medium,2022-07-13T19:15:09.727,'The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.',linux-libc-dev4.19.132-14.19.249-1debCVE-2022-2380Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-2318,Medium,2022-07-06T19:15:08.310,'There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-2318Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-2153,Medium,2022-08-31T16:15:10.837,"'A flaw was found in the Linux kernels KVM when attempting to set a SynIC IRQ. This issue makes it possible for a misbehaving VMM to write to SYNIC/STIMER MSRs, causing a NULL pointer dereference. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-2153Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2022-21499,Medium,2022-06-09T21:15:07.657,"'KGDB and KDB allow read and write access to kernel memory, and thus should be restricted during lockdown. An attacker with access to a serial port could trigger the debugger so it is important that the debugger respect the lockdown mode when/if it is triggered. CVSS 3.1 Base Score 6.7 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H).'",linux-libc-dev4.19.132-1(won't fix)debCVE-2022-21499Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-20572,Medium,2022-12-16T16:15:19.720,"'In verity_target of dm-verity-target.c, there is a possible way to modify read-only files due to a missing permission check. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-234475629References: Upstream kernel'",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-20572Medium
linux-libc-dev,4.19.132-1,4.19.249-1,deb,CVE-2022-20423,Medium,2022-10-11T20:15:12.840,"'In rndis_set_response of rndis.c, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege if a malicious USB device is attached with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-239842288References: Upstream kernel'",linux-libc-dev4.19.132-14.19.249-1debCVE-2022-20423Medium
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-20369,Medium,2022-08-11T15:15:10.593,"'In v4l2_m2m_querybuf of v4l2-mem2mem.c, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-223375145References: Upstream kernel'",linux-libc-dev4.19.132-14.19.269-1debCVE-2022-20369Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-20154,Medium,2022-06-15T14:15:11.650,"'In lock_sock_nested of sock.c, there is a possible use after free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-174846563References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-20154Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-20132,Medium,2022-06-15T13:15:08.763,"'In lg_probe and related functions of hid-lg.c and other USB HID files, there is a possible out of bounds read due to improper input validation. This could lead to local information disclosure if a malicious USB HID device were plugged in, with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-188677105References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-20132Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-20008,Medium,2022-05-10T20:15:09.023,"'In mmc_blk_read_single of block.c, there is a possible way to read kernel heap memory due to uninitialized data. This could lead to local information disclosure if reading from an SD card that triggers errors, with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-216481035References: Upstream kernel'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-20008Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1975,Medium,2022-08-31T16:15:10.063,'There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker to crash the Linux kernel by simulating a nfc device from user-space.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1975Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1974,Medium,2022-08-31T16:15:10.007,"""A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.""",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1974Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1516,Medium,2022-05-05T15:15:07.953,'A NULL pointer dereference flaw was found in the Linux kernels X.25 set of standardized network protocols functionality in the way a user terminates their session using a simulated Ethernet card and continued usage of this connection. This flaw allows a local user to crash the system.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1516Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-1462,Medium,2022-06-02T14:15:32.637,'An out-of-bounds read flaw was found in the Linux kernels TeleTYpe subsystem. The issue occurs in how a user triggers a race condition using ioctls TIOCSPTLCK and TIOCGPTPEER and TIOCSTI and TCXONC with leakage of memory in the flush_to_ldisc function. This flaw allows a local user to crash the system or read unauthorized random data from memory.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-1462Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-1280,Medium,2022-04-13T18:15:09.723,'A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.',linux-libc-dev4.19.132-1 debCVE-2022-1280Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1205,Medium,2022-08-31T16:15:09.110,'A NULL pointer dereference flaw was found in the Linux kernels Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1205Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1204,Medium,2022-08-29T15:15:10.587,'A use-after-free flaw was found in the Linux kernels Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1204Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1198,Medium,2022-08-29T15:15:10.467,'A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1198Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1195,Medium,2022-04-29T16:15:08.687,'A use-after-free vulnerability was found in the Linux kernel in drivers/net/hamradio. This flaw allows a local attacker with a user privilege to cause a denial of service (DOS) when the mkiss or sixpack device is detached and reclaim resources early.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1195Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-1184,Medium,2022-08-29T15:15:10.413,'A use-after-free flaw was found in fs/ext4/namei.c:dx_insert_block() in the Linux kernels filesystem sub-component. This flaw allows a local attacker with a user privilege to cause a denial of service.',linux-libc-dev4.19.132-1 debCVE-2022-1184Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-1016,Medium,2022-08-29T15:15:10.143,"""A flaw was found in the Linux kernel in net/netfilter/nf_tables_core.c:nft_do_chain, which can cause a use-after-free. This issue needs to handle 'return' with proper preconditions, as it can lead to a kernel information leak problem caused by a local, unprivileged attacker.""",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-1016Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-0854,Medium,2022-03-23T20:15:10.423,"'A memory leak flaw was found in the Linux kernels DMA subsystem, in the way a user calls DMA_FROM_DEVICE. This flaw allows a local user to read random memory from the kernel space.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-0854Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-0812,Medium,2022-08-29T15:15:09.863,'An information leak flaw was found in NFS over RDMA in the net/sunrpc/xprtrdma/rpc_rdma.c in the Linux Kernel. This flaw allows an attacker with normal user privileges to leak kernel information.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-0812Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0617,Medium,2022-02-16T17:15:11.577,'A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0617Medium
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-0494,Medium,2022-03-25T19:15:10.160,'A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-0494Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0487,Medium,2022-02-04T23:15:12.890,"'A use-after-free vulnerability was found in rtsx_usb_ms_drv_remove in drivers/memstick/host/rtsx_usb_ms.c in memstick in the Linux kernel. In this flaw, a local attacker with a user privilege may impact system Confidentiality. This flaw affects kernel versions prior to 5.14 rc1.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0487Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2022-0480,Medium,2022-08-29T15:15:09.477,'A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.',linux-libc-dev4.19.132-1(won't fix)debCVE-2022-0480Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0322,Medium,2022-03-25T19:15:09.967,"'A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0322Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0002,Medium,2022-03-11T18:15:25.373,'Non-transparent sharing of branch predictor within a context in some Intel(R) Processors may allow an authorized user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0002Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-0001,Medium,2022-03-11T18:15:25.143,'Non-transparent sharing of branch predictor selectors between contexts in some Intel(R) Processors may allow an authorized user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.232-1debCVE-2022-0001Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-45868,Medium,2022-03-18T07:15:06.597,"'In the Linux kernel before 5.15.3, fs/quota/quota_tree.c does not validate the block number in the quota tree (on disk). This can, for example, lead to a kernel/locking/rwsem.c use-after-free if there is a corrupted quota file.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-45868Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-45480,Medium,2021-12-24T23:15:07.237,'An issue was discovered in the Linux kernel before 5.15.11. There is a memory leak in the __rds_conn_create() function in net/rds/connection.c in a certain combination of circumstances.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-45480Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-45095,Medium,2021-12-16T04:15:06.803,'pep_sock_accept in net/phonet/pep.c in the Linux kernel through 5.15.8 has a refcount leak.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-45095Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-44879,Medium,2022-02-14T12:15:15.697,"'In gc_data_segment in fs/f2fs/gc.c in the Linux kernel before 5.16.3, special files are not considered, leading to a move_data_page NULL pointer dereference.'",linux-libc-dev4.19.132-1 debCVE-2021-44879Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-43976,Medium,2021-11-17T17:15:08.537,"'In the Linux kernel through 5.15.2, mwifiex_usb_recv in drivers/net/wireless/marvell/mwifiex/usb.c allows an attacker (who can connect a crafted USB device) to cause a denial of service (skb_over_panic).'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-43976Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-43975,Medium,2021-11-17T17:15:08.477,"'In the Linux kernel through 5.15.2, hw_atl_utils_fw_rpc_wait in drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c allows an attacker (who can introduce a crafted device) to trigger an out-of-bounds write via a crafted length value.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-43975Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-43389,Medium,2021-11-04T19:15:07.623,'An issue was discovered in the Linux kernel before 5.14.15. There is an array-index-out-of-bounds flaw in the detach_capi_ctr function in drivers/isdn/capi/kcapi.c.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-43389Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-42739,Medium,2021-10-20T07:15:09.140,"'A heap-based buffer overflow flaw was found in the Linux kernel FireDTV media card driver, where the user calls the CA_SEND_MSG ioctl. This flaw allows a local user of the host machine to crash the system or escalate privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-42739Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4203,Medium,2022-03-25T19:15:09.833,"'A use-after-free read flaw was found in sock_getsockopt() in net/core/sock.c due to SO_PEERCRED and SO_PEERGROUPS race with listen() (and connect()) in the Linux kernel. In this flaw, an attacker with a user privileges may crash the system or leak internal kernel information.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4203Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2021-4159,Medium,2022-08-24T16:15:09.713,"""A vulnerability was found in the Linux kernel's EBPF verifier when handling internal data structures. Internal memory locations could be returned to userspace. A local attacker with the permissions to insert eBPF code to the kernel can use this to leak internal kernel memory details defeating some of the exploit mitigations in place for the kernel.""",linux-libc-dev4.19.132-14.19.260-1debCVE-2021-4159Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4155,Medium,2022-08-24T16:15:09.607,'A data leak flaw was found in the way XFS_IOC_ALLOCSP IOCTL in the XFS filesystem allowed for size increase of files with unaligned size. A local attacker could use this flaw to leak data on the XFS filesystem otherwise not accessible to them.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4155Medium
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2021-4149,Medium,2022-03-23T20:15:09.997,"'A vulnerability was found in btrfs_alloc_tree_b in fs/btrfs/extent-tree.c in the Linux kernel due to an improper lock operation in btrfs. In this flaw, a user with a local privilege may cause a denial of service (DOS) due to a deadlock problem.'",linux-libc-dev4.19.132-14.19.235-1debCVE-2021-4149Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4135,Medium,2022-07-14T20:15:08.360,"""A memory leak vulnerability was found in the Linux kernel's eBPF for the Simulated networking device driver in the way user uses BPF for the device such that function nsim_map_alloc_elem being called. A local user could use this flaw to get unauthorized access to some data.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4135Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-4002,Medium,2022-03-03T22:15:08.527,"""A memory leak flaw in the Linux kernel's hugetlbfs memory usage was found in the way the user maps some regions of memory twice using shmget() which are aligned to PUD alignment with the fault of some of the memory pages. A local user could use this flaw to get unauthorized access to some data.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-4002Medium
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2021-39657,Medium,2021-12-15T19:15:15.827,"'In ufshcd_eh_device_reset_handler of ufshcd.c, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-194696049References: Upstream kernel'",linux-libc-dev4.19.132-14.19.171-1debCVE-2021-39657Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-39656,Medium,2021-12-15T19:15:15.787,"'In __configfs_open_file of file.c, there is a possible use-after-free due to improper locking. This could lead to local escalation of privilege in the kernel with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-174049066References: Upstream kernel'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-39656Medium
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2021-39648,Medium,2021-12-15T19:15:15.490,"'In gadget_dev_desc_UDC_show of configfs.c, there is a possible disclosure of kernel heap memory due to a race condition. This could lead to local information disclosure with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-160822094References: Upstream kernel'",linux-libc-dev4.19.132-14.19.171-1debCVE-2021-39648Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-39633,Medium,2022-01-14T20:15:11.200,"'In gre_handle_offloads of ip_gre.c, there is a possible page fault due to an invalid memory access. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-150694665References: Upstream kernel'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-39633Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-38208,Medium,2021-08-08T20:15:07.387,'net/nfc/llcp_sock.c in the Linux kernel before 5.12.10 allows local unprivileged users to cause a denial of service (NULL pointer dereference and BUG) by making a getsockname call after a certain type of failure of a bind call.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-38208Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-38204,Medium,2021-08-08T20:15:07.250,'drivers/usb/host/max3421-hcd.c in the Linux kernel before 5.13.6 allows physically proximate attackers to cause a denial of service (use-after-free and panic) by removing a MAX-3421 USB device in certain situations.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-38204Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-38199,Medium,2021-08-08T20:15:07.073,"'fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-38199Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-38198,Medium,2021-08-08T20:15:07.027,"'arch/x86/kvm/mmu/paging_tmpl.h in the Linux kernel before 5.12.11 incorrectly computes the access permissions of a shadow page, leading to a missing guest protection page fault.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-38198Medium
linux-libc-dev,4.19.132-1,4.19.235-1,deb,CVE-2021-3772,Medium,2022-03-02T23:15:09.127,'A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.',linux-libc-dev4.19.132-14.19.235-1debCVE-2021-3772Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3764,Medium,2022-08-23T16:15:09.837,"""A memory leak flaw was found in the Linux kernel's ccp_run_aes_gcm_cmd() function that allows an attacker to cause a denial of service. The vulnerability is similar to the older CVE-2019-18808. The highest threat from this vulnerability is to system availability.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3764Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3759,Medium,2022-08-23T16:15:09.737,"'A memory overflow vulnerability was found in the Linux kernels ipc functionality of the memcg subsystem, in the way a user calls the semget function multiple times, creating semaphores. This flaw allows a local user to starve the resources, causing a denial of service. The highest threat from this vulnerability is to system availability.'",linux-libc-dev4.19.132-1 debCVE-2021-3759Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3753,Medium,2022-02-16T19:15:08.647,"'A race problem was seen in the vt_k_ioctl in drivers/tty/vt/vt_ioctl.c in the Linux kernel, which may cause an out of bounds read in vt as the write access to vc_mode is not protected by lock-in vt_ioctl (KDSETMDE). The highest threat from this vulnerability is to data confidentiality.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3753Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3744,Medium,2022-03-04T16:15:08.817,"'A memory leak flaw was found in the Linux kernel in the ccp_run_aes_gcm_cmd() function in drivers/crypto/ccp/ccp-ops.c, which allows attackers to cause a denial of service (memory consumption). This vulnerability is similar with the older CVE-2019-18808.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3744Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3732,Medium,2022-03-10T17:42:59.287,"""A flaw was found in the Linux kernel's OverlayFS subsystem in the way the user mounts the TmpFS filesystem with OverlayFS. This flaw allows a local user to gain access to hidden files that should not be accessible.""",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3732Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-37159,Medium,2021-07-21T15:16:20.777,"'hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-37159Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3679,Medium,2021-08-05T20:15:09.627,'A lack of CPU resource in the Linux kernel tracing module functionality in versions prior to 5.14-rc3 was found in the way user uses trace ring buffer in a specific way. Only privileged local users (with CAP_SYS_ADMIN capability) could use this flaw to starve the resources causing denial of service.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3679Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3669,Medium,2022-08-26T16:15:09.273,'A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.',linux-libc-dev4.19.132-1 debCVE-2021-3669Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-3659,Medium,2022-08-22T15:15:13.690,'A NULL pointer dereference flaw was found in the Linux kernels IEEE 802.15.4 wireless networking subsystem in the way the user closes the LR-WPAN connection. This flaw allows a local user to crash the system. The highest threat from this vulnerability is to system availability.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-3659Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-3573,Medium,2021-08-13T14:15:07.617,"'A use-after-free in function hci_sock_bound_ioctl() of the Linux kernel HCI subsystem was found in the way user calls ioct HCIUNBLOCKADDR or other way triggers race condition of the call hci_unregister_dev() together with one of the calls hci_sock_blacklist_add(), hci_sock_blacklist_del(), hci_get_conn_info(), hci_get_auth_info(). A privileged local user could use this flaw to crash the system or escalate their privileges on the system. This flaw affects the Linux kernel versions prior to 5.13-rc5.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-3573Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-3564,Medium,2021-06-08T12:15:11.753,'A flaw double-free memory corruption in the Linux kernel HCI device initialization subsystem was found in the way user attach malicious HCI TTY Bluetooth device. A local user could use this flaw to crash the system. This flaw affects all the Linux kernel versions starting from 3.13.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-3564Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-35477,Medium,2021-08-02T04:15:07.790,"'In the Linux kernel through 5.13.7, an unprivileged BPF program can obtain sensitive information from kernel memory via a Speculative Store Bypass side-channel attack because a certain preempting store operation does not necessarily occur before a store operation that has an attacker-controlled value.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-35477Medium
linux-libc-dev,4.19.132-1,4.19.194-3,deb,CVE-2021-34693,Medium,2021-06-14T22:15:20.820,'net/can/bcm.c in the Linux kernel through 5.12.10 allows local users to obtain sensitive information from kernel stack memory because parts of a data structure are uninitialized.',linux-libc-dev4.19.132-14.19.194-3debCVE-2021-34693Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-34556,Medium,2021-08-02T05:15:07.663,"'In the Linux kernel through 5.13.7, an unprivileged BPF program can obtain sensitive information from kernel memory via a Speculative Store Bypass side-channel attack because the protection mechanism neglects the possibility of uninitialized memory locations on the BPF stack.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-34556Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-3428,Medium,2022-03-04T18:15:08.130,"'A flaw was found in the Linux kernel. A denial of service problem is identified if an extent tree is corrupted in a crafted ext4 filesystem in fs/ext4/extents.c in ext4_es_cache_extent. Fabricating an integer overflow, A local attacker with a special user privilege may cause a system crash problem which can lead to an availability threat.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-3428Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2021-33656,Medium,2022-07-18T15:15:08.043,"'When setting font with malicous data by ioctl cmd PIO_FONT,kernel will write memory out of bounds.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2021-33656Medium
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2021-33655,Medium,2022-07-18T15:15:07.990,"'When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.'",linux-libc-dev4.19.132-14.19.260-1debCVE-2021-33655Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-33624,Medium,2021-06-23T16:15:07.957,"'In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-33624Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-33098,Medium,2021-11-17T20:15:10.117,'Improper input validation in the Intel(R) Ethernet ixgbe driver for Linux before version 3.17.3 may allow an authenticated user to potentially enable denial of service via local access.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-33098Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-33061,Medium,2022-02-09T23:15:15.193,'Insufficient control flow management for the Intel(R) 82599 Ethernet Controllers and Adapters may allow an authenticated user to potentially enable denial of service via local access.',linux-libc-dev4.19.132-1 debCVE-2021-33061Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-31916,Medium,2021-05-06T17:15:08.143,'An out-of-bounds (OOB) memory write flaw was found in list_devices in drivers/md/dm-ioctl.c in the Multi-device driver module in the Linux kernel before 5.12. A bound check failure allows an attacker with special user (CAP_SYS_ADMIN) privilege to gain access to out-of-bounds memory leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-31916Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-31829,Medium,2021-05-06T16:15:07.493,"'kernel/bpf/verifier.c in the Linux kernel through 5.12.1 performs undesirable speculative loads, leading to disclosure of stack content via side-channel attacks, aka CID-801c6058d14a. The specific concern is not protecting the BPF stack area against speculative loads. Also, the BPF stack can contain uninitialized data that might represent sensitive information previously operated on by the kernel.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-31829Medium
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2021-3178,Medium,2021-01-19T07:15:13.443,"'fs/nfsd/nfs3xdr.c in the Linux kernel through 5.10.8, when there is an NFS export of a subdirectory of a filesystem, allows remote attackers to traverse to other parts of the filesystem via READDIRPLUS. NOTE: some parties argue that such a subdirectory export is not intended to prevent this attack; see also the exports(5) no_subtree_check default behavior'",linux-libc-dev4.19.132-14.19.171-1debCVE-2021-3178Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-30002,Medium,2021-04-02T05:15:12.767,"'An issue was discovered in the Linux kernel before 5.11.3 when a webcam device exists. video_usercopy in drivers/media/v4l2-core/v4l2-ioctl.c has a memory leak for large arguments, aka CID-fb18802a338b.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-30002Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-29650,Medium,2021-03-30T21:15:14.593,"'An issue was discovered in the Linux kernel before 5.11.11. The netfilter subsystem allows attackers to cause a denial of service (panic) because net/netfilter/x_tables.c and include/linux/netfilter/x_tables.h lack a full memory barrier upon the assignment of a new table value, aka CID-175e476b8cdf.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-29650Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-29647,Medium,2021-03-30T21:15:14.157,"'An issue was discovered in the Linux kernel before 5.11.11. qrtr_recvmsg in net/qrtr/qrtr.c allows attackers to obtain sensitive information from kernel memory because of a partially uninitialized data structure, aka CID-50535249f624.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-29647Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-29265,Medium,2021-03-26T22:15:13.087,"'An issue was discovered in the Linux kernel before 5.11.7. usbip_sockfd_store in drivers/usb/usbip/stub_dev.c allows attackers to cause a denial of service (GPF) because the stub-up sequence has race conditions during an update of the local and shared status, aka CID-9380afd6df70.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-29265Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-29264,Medium,2021-03-26T22:15:13.023,"'An issue was discovered in the Linux kernel through 5.11.10. drivers/net/ethernet/freescale/gianfar.c in the Freescale Gianfar Ethernet driver allows attackers to cause a system crash because a negative fragment size is calculated in situations involving an rx queue overrun when jumbo packets are used and NAPI is enabled, aka CID-d8861bab48b6.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-29264Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-29155,Medium,2021-04-20T16:15:10.547,"'An issue was discovered in the Linux kernel through 5.11.x. kernel/bpf/verifier.c performs undesirable out-of-bounds speculation on pointer arithmetic, leading to side-channel attacks that defeat Spectre mitigations and obtain sensitive information from kernel memory. Specifically, for sequences of pointer arithmetic operations, the pointer modification performed by the first operation is not correctly accounted for when restricting subsequent operations.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-29155Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-28972,Medium,2021-03-22T17:15:15.200,"""In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.""",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-28972Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-28971,Medium,2021-03-22T17:15:15.137,"'In intel_pmu_drain_pebs_nhm in arch/x86/events/intel/ds.c in the Linux kernel through 5.11.8 on some Haswell CPUs, userspace applications (such as perf-fuzzer) can cause a system crash because the PEBS status in a PEBS record is mishandled, aka CID-d88d05a9e0b6.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-28971Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-28964,Medium,2021-03-22T09:15:13.517,"'A race condition was discovered in get_old_root in fs/btrfs/ctree.c in the Linux kernel through 5.11.8. It allows attackers to cause a denial of service (BUG) because of a lack of locking on an extent buffer before a cloning operation, aka CID-dbcc7d57bffc.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-28964Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28950,Medium,2021-03-20T20:15:13.100,"'An issue was discovered in fs/fuse/fuse_i.h in the Linux kernel before 5.11.8. A ""stall on CPU"" can occur because a retry loop continually finds the same bad inode, aka CID-775c5033a0d1.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28950Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28715,Medium,2022-01-06T18:15:07.813,"""Guest can force Linux netback driver to hog large amounts of kernel memory T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28715Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28714,Medium,2022-01-06T18:15:07.760,"""Guest can force Linux netback driver to hog large amounts of kernel memory T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28714Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28713,Medium,2022-01-05T17:15:09.120,'Rogue backends can cause DoS of guests via high frequency events T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.,linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28713Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28712,Medium,2022-01-05T17:15:09.070,'Rogue backends can cause DoS of guests via high frequency events T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.,linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28712Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-28711,Medium,2022-01-05T17:15:09.017,'Rogue backends can cause DoS of guests via high frequency events T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.,linux-libc-dev4.19.132-14.19.232-1debCVE-2021-28711Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-28688,Medium,2021-04-06T19:15:14.863,"""The fix for XSA-365 includes initialization of pointers such that subsequent cleanup code wouldn't use uninitialized or stale values. This initialization went too far and may under certain conditions also overwrite pointers which are in need of cleaning up. The lack of cleanup would result in leaking persistent grants. The leak in turn would prevent fully cleaning up after a respective guest has died, leaving around zombie domains. All Linux versions having the fix for XSA-365 applied are vulnerable. XSA-365 was classified to affect versions back to at least 3.11.""",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-28688Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-28038,Medium,2021-03-05T18:15:13.127,"'An issue was discovered in the Linux kernel through 5.11.3, as used with Xen PV. A certain part of the netback driver lacks necessary treatment of errors such as failed memory allocations (as a result of changes to the handling of grant mapping errors). A host OS denial of service may occur during misbehavior of a networking frontend driver. NOTE: this issue exists because of an incomplete fix for CVE-2021-26931.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-28038Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2021-27363,Medium,2021-03-07T04:15:13.330,"""An issue was discovered in the Linux kernel through 5.11.3. A kernel pointer leak can be used to determine the address of the iscsi_transport structure. When an iSCSI transport is registered with the iSCSI subsystem, the transport's handle is available to unprivileged users via the sysfs file system, at /sys/class/iscsi_transport/$TRANSPORT_NAME/handle. When read, the show_transport_handle function (in drivers/scsi/scsi_transport_iscsi.c) is called, which leaks the handle. This handle is actually the pointer to an iscsi_transport struct in the kernel module's global variables.""",linux-libc-dev4.19.132-14.19.181-1debCVE-2021-27363Medium
linux-libc-dev,4.19.132-1,4.19.177-1,deb,CVE-2021-26931,Medium,2021-02-17T02:15:12.987,"""An issue was discovered in the Linux kernel 2.6.39 through 5.10.16, as used in Xen. Block, net, and SCSI backends consider certain errors a plain bug, deliberately causing a kernel crash. For errors potentially being at least under the influence of guests (such as out of memory conditions), it isn't correct to assume a plain bug. Memory allocations potentially causing such crashes occur only when Linux is running in PV mode, though. This affects drivers/block/xen-blkback/blkback.c and drivers/xen/xen-scsiback.c.""",linux-libc-dev4.19.132-14.19.177-1debCVE-2021-26931Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-26401,Medium,2022-03-11T18:15:11.327,'LFENCE/JMP (mitigation V2-2) may not sufficiently mitigate CVE-2017-5715 on some AMD CPUs.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-26401Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-20321,Medium,2022-02-18T18:15:08.947,'A race condition accessing file object in the Linux kernel OverlayFS subsystem was found in the way users do rename in specific way with OverlayFS. A local user could use this flaw to crash the system.',linux-libc-dev4.19.132-14.19.232-1debCVE-2021-20321Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-20320,Medium,2022-02-18T18:15:08.877,"'A flaw was found in s390 eBPF JIT in bpf_jit_insn in arch/s390/net/bpf_jit_comp.c in the Linux kernel. In this flaw, a local attacker with special user privilege can circumvent the verifier and may lead to a confidentiality problem.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-20320Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-20317,Medium,2021-09-27T11:15:07.357,"'A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-20317Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2021-20292,Medium,2021-05-28T11:15:08.130,"'There is a flaw reported in the Linux kernel in versions before 5.9 in drivers/gpu/drm/nouveau/nouveau_sgdma.c in nouveau_sgdma_create_ttm in Nouveau DRM subsystem. The issue results from the lack of validating the existence of an object prior to performing operations on the object. An attacker with a local account with a root privilege, can leverage this vulnerability to escalate privileges and execute code in the context of the kernel.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2021-20292Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2021-20177,Medium,2021-05-26T21:15:08.157,"""A flaw was found in the Linux kernel's implementation of string matching within a packet. A privileged user (with root or CAP_NET_ADMIN) when inserting iptables rules could insert a rule which can panic the system. Kernel before kernel 5.5-rc1 is affected.""",linux-libc-dev4.19.132-14.19.171-2debCVE-2021-20177Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-0941,Medium,2021-10-25T14:15:09.883,"'In bpf_skb_change_head of filter.c, there is a possible out of bounds read due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-154177719References: Upstream kernel'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-0941Medium
linux-libc-dev,4.19.132-1,4.19.171-1,deb,CVE-2021-0938,Medium,2021-10-25T14:15:09.760,"'In memzero_explicit of compiler-clang.h, there is a possible bypass of defense in depth due to uninitialized data. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-171418586References: Upstream kernel'",linux-libc-dev4.19.132-14.19.171-1debCVE-2021-0938Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-0920,Medium,2021-12-15T19:15:11.017,"'In unix_scm_to_skb of af_unix.c, there is a possible use after free bug due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-196926917References: Upstream kernel'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-0920Medium
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2021-0605,Medium,2021-06-22T12:15:09.730,"'In pfkey_dump of af_key.c, there is a possible out-of-bounds read due to a missing bounds check. This could lead to local information disclosure in the kernel with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-110373476'",linux-libc-dev4.19.132-14.19.152-1debCVE-2021-0605Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-0129,Medium,2021-06-09T20:15:08.830,'Improper access control in BlueZ may allow an authenticated user to potentially enable information disclosure via adjacent access.',linux-libc-dev4.19.132-14.19.194-1debCVE-2021-0129Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-8694,Medium,2020-11-12T18:15:16.567,'Insufficient access control in the Linux kernel driver for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-8694Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-4788,Medium,2020-11-20T04:15:11.063,"'IBM Power9 (AIX 7.1, 7.2, and VIOS 3.1) processors could allow a local user to obtain sensitive information from the data in the L1 cache under extenuating circumstances. IBM X-Force ID: 189296.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-4788Medium
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2020-3702,Medium,2020-09-08T10:15:16.340,"""u'Specifically timed and handcrafted traffic can cause internal errors in a WLAN device that lead to improper layer 2 Wi-Fi encryption with a consequent possibility of information disclosure over the air for a discrete set of traffic' in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking in APQ8053, IPQ4019, IPQ8064, MSM8909W, MSM8996AU, QCA9531, QCN5502, QCS405, SDX20, SM6150, SM7150""",linux-libc-dev4.19.132-14.19.208-1debCVE-2020-3702Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-36694,Medium,2023-05-21T23:15:08.960,"'An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.'",linux-libc-dev4.19.132-1 debCVE-2020-36694Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-36691,Medium,2023-03-24T17:15:07.313,'An issue was discovered in the Linux kernel before 5.8. lib/nlattr.c allows attackers to cause a denial of service (unbounded recursion) via a nested Netlink policy with a back reference.',linux-libc-dev4.19.132-1 debCVE-2020-36691Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2020-36516,Medium,2022-02-26T04:15:06.933,"""An issue was discovered in the Linux kernel through 5.16.11. The mixed IPID assignment method with the hash-based IPID assignment policy allows an off-path attacker to inject data into a victim's TCP session or terminate that session.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2020-36516Medium
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2020-36322,Medium,2021-04-14T06:15:12.437,"'An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2020-36322Medium
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-36312,Medium,2021-04-07T00:15:13.227,"'An issue was discovered in the Linux kernel before 5.8.10. virt/kvm/kvm_main.c has a kvm_io_bus_unregister_dev memory leak upon a kmalloc failure, aka CID-f65886606c2d.'",linux-libc-dev4.19.132-14.19.152-1debCVE-2020-36312Medium
linux-libc-dev,4.19.132-1,4.19.194-3,deb,CVE-2020-36311,Medium,2021-04-07T00:15:13.150,"'An issue was discovered in the Linux kernel before 5.9. arch/x86/kvm/svm/sev.c allows attackers to cause a denial of service (soft lockup) by triggering destruction of a large SEV VM (which requires unregistering many encrypted regions), aka CID-7be74942f184.'",linux-libc-dev4.19.132-14.19.194-3debCVE-2020-36311Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-36310,Medium,2021-04-07T00:15:13.087,"'An issue was discovered in the Linux kernel before 5.8. arch/x86/kvm/svm/svm.c allows a set_memory_region_test infinite loop for certain nested page faults, aka CID-e72436bc3a52.'",linux-libc-dev4.19.132-1 debCVE-2020-36310Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-36158,Medium,2021-01-05T05:15:10.737,"'mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-36158Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-35508,Medium,2021-03-26T17:15:12.203,'A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-35508Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-29660,Medium,2020-12-09T17:15:31.743,"'A locking inconsistency issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_io.c and drivers/tty/tty_jobctrl.c may allow a read-after-free attack against TIOCGSID, aka CID-c8bcd9c5be24.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-29660Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-29568,Medium,2020-12-15T17:15:14.660,"'An issue was discovered in Xen through 4.14.x. Some OSes (such as Linux, FreeBSD, and NetBSD) are processing watch events using a single thread. If the events are received faster than the thread is able to handle, they will get queued. As the queue is unbounded, a guest may be able to trigger an OOM in the backend. All systems with a FreeBSD, Linux, or NetBSD (any version) dom0 are vulnerable.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-29568Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-28974,Medium,2020-11-20T18:15:12.120,"'A slab-out-of-bounds read in fbcon in the Linux kernel before 5.9.7 could be used by local attackers to read privileged information or potentially crash the kernel, aka CID-3c4e0dff2095. This occurs because KD_FONT_OP_COPY in drivers/tty/vt/vt.c can be used for manipulations such as font height.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-28974Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-28941,Medium,2020-11-19T19:15:11.797,"'An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-28941Medium
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-28915,Medium,2020-11-18T08:15:12.180,"'A buffer over-read (at the framebuffer layer) in the fbcon code in the Linux kernel before 5.8.15 could be used by local attackers to read kernel memory, aka CID-6735b4632def.'",linux-libc-dev4.19.132-14.19.152-1debCVE-2020-28915Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-28097,Medium,2021-06-24T12:15:07.780,"'The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-28097Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-27835,Medium,2021-01-07T18:15:13.137,'A use after free in the Linux kernel infiniband hfi1 driver in versions prior to 5.10-rc6 was found in the way user calls Ioctl after open dev file and fork. A local user could use this flaw to crash the system.',linux-libc-dev4.19.132-1 debCVE-2020-27835Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-27830,Medium,2021-05-13T15:15:07.577,"'A vulnerability was found in Linux Kernel where in the spk_ttyio_receive_buf2() function, it would dereference spk_ttyio_synth without checking whether it is NULL or not, and may lead to a NULL-ptr deref crash.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-27830Medium
linux-libc-dev,4.19.132-1,4.19.171-2,deb,CVE-2020-27825,Medium,2020-12-11T19:15:12.607,"'A use-after-free flaw was found in kernel/trace/ring_buffer.c in Linux kernel (before 5.10-rc1). There was a race problem in trace_open and resize of cpu buffer running parallely on different cpus, may cause a denial of service problem (DOS). This flaw could even allow a local attacker with special user privilege to a kernel information leak threat.'",linux-libc-dev4.19.132-14.19.171-2debCVE-2020-27825Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-27784,Medium,2022-09-01T18:15:08.467,"'A vulnerability was found in the Linux kernel, where accessing a deallocated instance in printer_ioctl() printer_ioctl() tries to access of a printer_dev instance. However, use-after-free arises because it had been freed by gprinter_free().'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-27784Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-27777,Medium,2020-12-15T17:15:14.333,'A flaw was found in the way RTAS handled memory accesses in userspace to kernel communication. On a locked down (usually due to Secure Boot) guest system running on top of PowerVM or KVM hypervisors (pseries platform) a root like local user could use this flaw to further increase their privileges to that of a running kernel.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-27777Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-27675,Medium,2020-10-22T21:15:14.153,"'An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-27675Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-27673,Medium,2020-10-22T21:15:14.013,"'An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. Guest OS users can cause a denial of service (host OS hang) via a high rate of events to dom0, aka CID-e99502f76271.'",linux-libc-dev4.19.132-14.19.160-1debCVE-2020-27673Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2020-27171,Medium,2021-03-20T22:15:12.000,"'An issue was discovered in the Linux kernel before 5.11.8. kernel/bpf/verifier.c has an off-by-one error (with a resultant integer underflow) affecting out-of-bounds speculation on pointer arithmetic, leading to side-channel attacks that defeat Spectre mitigations and obtain sensitive information from kernel memory, aka CID-10d2bb2e6b1d.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2020-27171Medium
linux-libc-dev,4.19.132-1,4.19.181-1,deb,CVE-2020-27170,Medium,2021-03-20T22:15:11.940,"'An issue was discovered in the Linux kernel before 5.11.8. kernel/bpf/verifier.c performs undesirable out-of-bounds speculation on pointer arithmetic, leading to side-channel attacks that defeat Spectre mitigations and obtain sensitive information from kernel memory, aka CID-f232326f6966. This affects pointer types that do not define a ptr_limit.'",linux-libc-dev4.19.132-14.19.181-1debCVE-2020-27170Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-26558,Medium,2021-05-24T18:15:07.930,"'Bluetooth LE and BR/EDR secure pairing in Bluetooth Core Specification 2.1 through 5.2 may permit a nearby man-in-the-middle attacker to identify the Passkey used during pairing (in the Passkey authentication procedure) by reflection of the public key and the authentication evidence of the initiating device, potentially permitting this attacker to complete authenticated pairing with the responding device using the correct Passkey for the pairing session. The attack methodology determines the Passkey value one bit at a time.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-26558Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-26541,Medium,2020-10-02T19:15:13.900,'The Linux kernel through 5.8.13 does not properly enforce the Secure Boot Forbidden Signature Database (aka dbx) protection mechanism. This affects certs/blacklist.c and certs/system_keyring.c.',linux-libc-dev4.19.132-1 debCVE-2020-26541Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-26147,Medium,2021-05-11T20:15:08.947,"'An issue was discovered in the Linux kernel 5.8.9. The WEP, WPA, WPA2, and WPA3 implementations reassemble fragments even though some of them were sent in plaintext. This vulnerability can be abused to inject packets and/or exfiltrate selected fragments when another device sends fragmented frames and the WEP, CCMP, or GCMP data-confidentiality protocol is used.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-26147Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-26145,Medium,2021-05-11T20:15:08.873,"'An issue was discovered on Samsung Galaxy S3 i9305 4.4.4 devices. The WEP, WPA, WPA2, and WPA3 implementations accept second (or subsequent) broadcast fragments even when sent in plaintext and process them as full unfragmented frames. An adversary can abuse this to inject arbitrary network packets independent of the network configuration.'",linux-libc-dev4.19.132-1 debCVE-2020-26145Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-26141,Medium,2021-05-11T20:15:08.727,'An issue was discovered in the ALFA Windows 10 driver 6.1316.1209 for AWUS036H. The Wi-Fi implementation does not verify the Message Integrity Check (authenticity) of fragmented TKIP frames. An adversary can abuse this to inject and possibly decrypt packets in WPA or WPA2 networks that support the TKIP data-confidentiality protocol.',linux-libc-dev4.19.132-1 debCVE-2020-26141Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-26139,Medium,2021-05-11T20:15:08.647,'An issue was discovered in the kernel in NetBSD 7.1. An Access Point (AP) forwards EAPOL frames to other clients even though the sender has not yet successfully authenticated to the AP. This might be abused in projected Wi-Fi networks to launch denial-of-service attacks against connected clients and makes it easier to exploit other vulnerabilities in connected clients.',linux-libc-dev4.19.132-14.19.194-1debCVE-2020-26139Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-26088,Medium,2020-09-24T15:15:15.267,"'A missing CAP_NET_RAW check in NFC socket creation in net/nfc/rawsock.c in the Linux kernel before 5.8.2 could be used by local attackers to create raw sockets, bypassing security mechanisms, aka CID-26896f01467a.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-26088Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-25704,Medium,2020-12-02T01:15:12.670,'A flaw memory leak in the Linux kernel performance monitoring subsystem was found in the way if using PERF_EVENT_IOC_SET_FILTER. A local user could use this flaw to starve the resources causing denial of service.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-25704Medium
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-25673,Medium,2021-05-26T11:15:08.580,'A vulnerability was found in Linux kernel where non-blocking socket in llcp_sock_connect() leads to leak and eventually hanging-up the system.',linux-libc-dev4.19.132-14.19.194-1debCVE-2020-25673Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2020-25656,Medium,2020-12-02T01:15:12.607,'A flaw was found in the Linux kernel. A use-after-free was found in the way the console subsystem was using ioctls KDGKBSENT and KDSKBSENT. A local user could use this flaw to get read memory access out of bounds. The highest threat from this vulnerability is to data confidentiality.',linux-libc-dev4.19.132-14.19.160-1debCVE-2020-25656Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-25641,Medium,2020-10-06T14:15:12.603,"""A flaw was found in the Linux kernel's implementation of biovecs in versions before 5.9-rc7. A zero-length biovec request issued by the block subsystem could cause the kernel to enter an infinite loop, causing a denial of service. This flaw allows a local attacker with basic privileges to issue requests to a block device, resulting in a denial of service. The highest threat from this vulnerability is to system availability.""",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-25641Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-25285,Medium,2020-09-13T18:15:09.990,"'A race condition between hugetlb sysctl handlers in mm/hugetlb.c in the Linux kernel before 5.8.8 could be used by local attackers to corrupt memory, cause a NULL pointer dereference, or possibly have unspecified other impact, aka CID-17743798d812.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-25285Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-25284,Medium,2020-09-13T18:15:09.833,"'The rbd block device driver in drivers/block/rbd.c in the Linux kernel through 5.8.9 used incomplete permission checking for access to rbd devices, which could be leveraged by local attackers to map or unmap rbd block devices, aka CID-f44d04e696fe.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-25284Medium
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-25211,Medium,2020-09-09T16:15:12.003,"'In the Linux kernel through 5.8.7, local attackers able to inject conntrack netlink configuration could overflow a local buffer, causing crashes or triggering use of incorrect protocol numbers in ctnetlink_parse_tuple_filter in net/netfilter/nf_conntrack_netlink.c, aka CID-1cc5ef91d2ff.'",linux-libc-dev4.19.132-14.19.152-1debCVE-2020-25211Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-24490,Medium,2021-02-02T22:15:12.150,'Improper buffer restrictions in BlueZ may allow an unauthenticated user to potentially enable denial of service via adjacent access. This affects all Linux kernel versions that support BlueZ.',linux-libc-dev4.19.132-14.19.146-1debCVE-2020-24490Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-16120,Medium,2021-02-10T20:15:15.150,"'Overlayfs did not properly perform permission checking when copying up files in an overlayfs and could be exploited from within a user namespace, if, for example, unprivileged user namespaces were allowed. It was possible to have a file not readable by an unprivileged user to be copied to a mountpoint controlled by the user, like a removable device. This was introduced in kernel version 4.19 by commit d1d04ef (""ovl: stack file ops""). This was fixed in kernel version 5.8 by commits 56230d9 (""ovl: verify permissions in ovl_path_open()""), 48bd024 (""ovl: switch to mounter creds in readdir"") and 05acefb (""ovl: check permission to open real file""). Additionally, commits 130fdbc (""ovl: pass correct flags for opening real directory"") and 292f902 (""ovl: call secutiry hook in ovl_real_ioctl()"") in kernel 5.8 might also be desired or necessary. These additional commits introduced a regression in overlay mounts within user namespaces which prevented access to files with ownership outside of the user namespace. This regression was mitigated by subsequent commit b6650da (""ovl: do not fail because of O_NOATIMEi"") in kernel 5.11.'",linux-libc-dev4.19.132-1 debCVE-2020-16120Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-15780,Medium,2020-07-15T22:15:14.047,"'An issue was discovered in drivers/acpi/acpi_configfs.c in the Linux kernel before 5.7.7. Injection of malicious ACPI tables via configfs could be used by attackers to bypass lockdown and secure boot restrictions, aka CID-75b0cea7bf30.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-15780Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-15437,Medium,2020-11-23T21:15:11.890,'The Linux kernel before version 5.8 is vulnerable to a NULL pointer dereference in drivers/tty/serial/8250/8250_core.c:serial8250_isa_init_ports() that allows local users to cause a denial of service by using the p->serial_in pointer which uninitialized.',linux-libc-dev4.19.132-14.19.146-1debCVE-2020-15437Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-14390,Medium,2020-09-18T18:15:16.503,"'A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-14390Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-14385,Medium,2020-09-15T22:15:13.223,"'A flaw was found in the Linux kernel before 5.9-rc4. A failure of the file system metadata validator in XFS can cause an inode with a valid, user-creatable extended attribute to be flagged as corrupt. This can lead to the filesystem being shutdown, or otherwise rendered inaccessible until it is remounted, leading to a denial of service. The highest threat from this vulnerability is to system availability.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-14385Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-14331,Medium,2020-09-15T19:15:12.667,"'A flaw was found in the Linux kernels implementation of the invert video code on VGA consoles when a local attacker attempts to resize the console, calling an ioctl VT_RESIZE, which causes an out-of-bounds write to occur. This flaw allows a local user with access to the VGA console to crash the system, potentially escalating their privileges on the system. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-14331Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2020-14304,Medium,2020-09-15T20:15:13.103,"""A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.""",linux-libc-dev4.19.132-1(won't fix)debCVE-2020-14304Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-12888,Medium,2020-05-15T18:15:13.650,'The VFIO PCI driver in the Linux kernel through 5.6.13 mishandles attempts to access disabled memory space.',linux-libc-dev4.19.132-14.19.146-1debCVE-2020-12888Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2020-12364,Medium,2021-02-17T14:15:15.233,'Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-1(won't fix)debCVE-2020-12364Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2020-12363,Medium,2021-02-17T14:15:15.187,'Improper input validation in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-1(won't fix)debCVE-2020-12363Medium
linux-libc-dev,4.19.132-1,4.19.152-1,deb,CVE-2020-12352,Medium,2020-11-23T17:15:12.313,'Improper access control in BlueZ may allow an unauthenticated user to potentially enable information disclosure via adjacent access.',linux-libc-dev4.19.132-14.19.152-1debCVE-2020-12352Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-10781,Medium,2020-09-16T13:15:10.987,"'A flaw was found in the Linux Kernel before 5.8-rc6 in the ZRAM kernel module, where a user with a local account and the ability to read the /sys/class/zram-control/hot_add file can create ZRAM device nodes in the /dev/ directory. This read allocates kernel memory and is not accounted for a user that triggers the creation of that ZRAM device. With this vulnerability, continually reading the device may consume a large amount of system memory and cause the Out-of-Memory (OOM) killer to activate and terminate random userspace processes, possibly making the system inoperable.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-10781Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-0465,Medium,2020-12-14T22:15:14.223,"'In various methods of hid-multitouch.c, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-162844689References: Upstream kernel'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-0465Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-3874,Medium,2019-03-25T19:29:01.993,'The SCTP socket buffer used by a userspace application is not accounted by the cgroups subsystem. An attacker can use this flaw to cause a denial of service attack. Kernel 3.10.x and 4.18.x branches are believed to be vulnerable.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-3874Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2019-20794,Medium,2020-05-09T18:15:11.157,"""An issue was discovered in the Linux kernel 4.18 through 5.6.11 when unprivileged user namespaces are allowed. A user can create their own PID namespace, and mount a FUSE filesystem. Upon interaction with this FUSE filesystem, if the userspace component is terminated via a kill of the PID namespace's pid 1, it will result in a hung task, and resources being permanently locked up until system reboot. This can result in resource exhaustion.""",linux-libc-dev4.19.132-1(won't fix)debCVE-2019-20794Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19813,Medium,2019-12-17T06:15:12.780,"'In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image, performing some operations, and then making a syncfs system call can lead to a use-after-free in __mutex_lock in kernel/locking/mutex.c. This is related to mutex_can_spin_on_owner in kernel/locking/mutex.c, __btrfs_qgroup_free_meta in fs/btrfs/qgroup.c, and btrfs_insert_delayed_items in fs/btrfs/delayed-inode.c.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19813Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19318,Medium,2019-11-28T00:15:11.143,"'In the Linux kernel 5.3.11, mounting a crafted btrfs image twice can cause an rwsem_down_write_slowpath use-after-free because (in rwsem_can_spin_on_owner in kernel/locking/rwsem.c) rwsem_owner_flags returns an already freed pointer,'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19318Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19082,Medium,2019-11-18T06:15:13.827,"'Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19082Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19073,Medium,2019-11-18T06:15:13.187,"'Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19073Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19072,Medium,2019-11-18T06:15:13.123,"'A memory leak in the predicate_parse() function in kernel/trace/trace_events_filter.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-96c5c6e6a5b6.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19072Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19067,Medium,2019-11-18T06:15:12.797,"'Four memory leaks in the acp_hw_init() function in drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption) by triggering mfd_add_hotplug_devices() or pm_genpd_add_device() failures, aka CID-57be09c6e874. NOTE: third parties dispute the relevance of this because the attacker must already have privileges for module loading'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19067Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-19054,Medium,2019-11-18T06:15:11.967,"'A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-19054Medium
linux-libc-dev,4.19.132-1,4.19.160-1,deb,CVE-2019-19039,Medium,2019-11-21T02:15:23.337,"""__btrfs_free_extent in fs/btrfs/extent-tree.c in the Linux kernel through 5.3.12 calls btrfs_print_leaf in a certain ENOENT case, which allows local users to obtain potentially sensitive information about register values via the dmesg program. NOTE: The BTRFS development team disputes this issues as not being a vulnerability because 1) The kernel provide facilities to restrict access to dmesg - dmesg_restrict=1 sysctl option. So it's really up to the system administrator to judge whether dmesg access shall be disallowed or not. 2) WARN/WARN_ON are widely used macros in the linux kernel. If this CVE is considered valid this would mean there are literally thousands CVE lurking in the kernel - something which clearly is not the case.""",linux-libc-dev4.19.132-14.19.160-1debCVE-2019-19039Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-18808,Medium,2019-11-07T16:15:11.373,"'A memory leak in the ccp_run_sha_cmd() function in drivers/crypto/ccp/ccp-ops.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-128c66429247.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2019-18808Medium
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2019-16089,Medium,2019-09-06T23:15:12.277,'An issue was discovered in the Linux kernel through 5.2.13. nbd_genl_status in drivers/block/nbd.c does not check the nla_nest_start_noflag return value.',linux-libc-dev4.19.132-1(won't fix)debCVE-2019-16089Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-15794,Medium,2020-04-24T00:15:11.933,"'Overlayfs in the Linux kernel and shiftfs, a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series, both replace vma->vm_file in their mmap handlers. On error the original value is not restored, and the reference is put for the file to which vm_file points. On upstream kernels this is not an issue, as no callers dereference vm_file following after call_mmap() returns an error. However, the aufs patchs change mmap_region() to replace the fput() using a local variable with vma_fput(), which will fput() vm_file, leading to a refcount underflow.'",linux-libc-dev4.19.132-1 debCVE-2019-15794Medium
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-15213,Medium,2019-08-19T22:15:11.253,'An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.',linux-libc-dev4.19.132-1 debCVE-2019-15213Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-0149,Medium,2019-11-14T19:15:12.533,'Insufficient input validation in i40e driver for Intel(R) Ethernet 700 Series Controllers versions before 2.8.43 may allow an authenticated user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-0149Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-0148,Medium,2019-11-14T19:15:12.457,'Resource leak in i40e driver for Intel(R) Ethernet 700 Series Controllers versions before 7.0 may allow an authenticated user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-0148Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-0147,Medium,2019-11-14T19:15:12.393,'Insufficient input validation in i40e driver for Intel(R) Ethernet 700 Series Controllers versions before 7.0 may allow an authenticated user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-0147Medium
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2019-0146,Medium,2019-11-14T19:15:12.300,'Resource leak in i40e driver for Intel(R) Ethernet 700 Series Controllers versions before 2.8.43 may allow an authenticated user to potentially enable a denial of service via local access.',linux-libc-dev4.19.132-14.19.146-1debCVE-2019-0146Medium
linux-libc-dev,4.19.132-1,4.19.282-1,deb,CVE-2023-1513,Low,2023-03-23T21:15:19.427,"'A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit systems, there might be some uninitialized portions of the kvm_debugregs structure that could be copied to userspace, causing an information leak.'",linux-libc-dev4.19.132-14.19.282-1debCVE-2023-1513Low
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-3629,Low,2022-10-21T06:15:09.710,'A vulnerability was found in Linux Kernel. It has been declared as problematic. This vulnerability affects the function vsock_connect of the file net/vmw_vsock/af_vsock.c. The manipulation leads to memory leak. The complexity of an attack is rather high. The exploitation appears to be difficult. It is recommended to apply a patch to fix this issue. VDB-211930 is the identifier assigned to this vulnerability.',linux-libc-dev4.19.132-14.19.260-1debCVE-2022-3629Low
linux-libc-dev,4.19.132-1,4.19.269-1,deb,CVE-2022-3521,Low,2022-10-16T10:15:09.740,'A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function kcm_tx_work of the file net/kcm/kcmsock.c of the component kcm. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211018 is the identifier assigned to this vulnerability.',linux-libc-dev4.19.132-14.19.269-1debCVE-2022-3521Low
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-33981,Low,2022-06-18T16:15:08.227,"'drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-33981Low
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-32296,Low,2022-06-05T22:15:08.797,"'The Linux kernel before 5.17.9 allows TCP servers to identify clients by observing what source ports are used. This occurs because of use of Algorithm 4 (""Double-Hash Port Selection Algorithm"") of RFC 6056.'",linux-libc-dev4.19.132-14.19.249-2debCVE-2022-32296Low
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2022-24448,Low,2022-02-04T20:15:08.723,"'An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2022-24448Low
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-45486,Low,2021-12-25T02:15:06.710,"'In the IPv4 implementation in the Linux kernel before 5.12.4, net/ipv4/route.c has an information leak because the hash table is very small.'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-45486Low
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2021-3923,Low,2023-03-27T21:15:09.980,"""A flaw was found in the Linux kernel's implementation of RDMA over infiniband. An attacker with a privileged local account can leak kernel stack information when issuing commands to the /dev/infiniband/rdma_cm device node. While this access is unlikely to leak sensitive user information, it can be further used to defeat existing kernel protection mechanisms.""",linux-libc-dev4.19.132-14.19.232-1debCVE-2021-3923Low
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2021-38209,Low,2021-08-08T20:15:07.423,"'net/netfilter/nf_conntrack_standalone.c in the Linux kernel before 5.12.2 allows observation of changes in any net namespace because these changes are leaked into all other net namespaces. This is related to the NF_SYSCTL_CT_MAX, NF_SYSCTL_CT_EXPECT_MAX, and NF_SYSCTL_CT_BUCKETS sysctls.'",linux-libc-dev4.19.132-14.19.194-1debCVE-2021-38209Low
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-38205,Low,2021-08-08T20:15:07.283,"'drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).'",linux-libc-dev4.19.132-14.19.208-1debCVE-2021-38205Low
linux-libc-dev,4.19.132-1,4.19.208-1,deb,CVE-2021-3655,Low,2021-08-05T21:15:13.707,'A vulnerability was found in the Linux kernel in versions prior to v5.14-rc1. Missing size validations on inbound SCTP packets may allow the kernel to read uninitialized memory.',linux-libc-dev4.19.132-14.19.208-1debCVE-2021-3655Low
linux-libc-dev,4.19.132-1,4.19.177-1,deb,CVE-2021-21781,Low,2021-08-18T15:15:07.733,"'An information disclosure vulnerability exists in the ARM SIGPAGE functionality of Linux Kernel v5.4.66 and v5.4.54. The latest version (5.11-rc4) seems to still be vulnerable. A userland application can read the contents of the sigpage, which can leak kernel memory contents. An attacker can read a processs memory at a specific offset to trigger this vulnerability. This was fixed in kernel releases: 4.14.222 4.19.177 5.4.99 5.10.17 5.11'",linux-libc-dev4.19.132-14.19.177-1debCVE-2021-21781Low
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-36766,Low,2023-09-18T09:15:07.693,"'An issue was discovered in the Linux kernel before 5.8.6. drivers/media/cec/core/cec-api.c leaks one byte of kernel memory on specific hardware to unprivileged users, because of directly assigning log_addrs with a hole in the struct.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-36766Low
linux-libc-dev,4.19.132-1,4.19.232-1,deb,CVE-2020-29374,Low,2020-11-28T07:15:11.960,"'An issue was discovered in the Linux kernel before 5.7.3, related to mm/gup.c and mm/huge_memory.c. The get_user_pages (aka gup) implementation, when used for a copy-on-write page, does not properly consider the semantics of read operations and therefore can grant unintended write access, aka CID-17839856fd58.'",linux-libc-dev4.19.132-14.19.232-1debCVE-2020-29374Low
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-29371,Low,2020-11-28T07:15:11.663,"'An issue was discovered in romfs_dev_read in fs/romfs/storage.c in the Linux kernel before 5.8.4. Uninitialized memory leaks to userspace, aka CID-bcf85fcedfdd.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-29371Low
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-24588,Low,2021-05-11T20:15:08.613,"""The 802.11 standard that underpins Wi-Fi Protected Access (WPA, WPA2, and WPA3) and Wired Equivalent Privacy (WEP) doesn't require that the A-MSDU flag in the plaintext QoS header field is authenticated. Against devices that support receiving non-SSP A-MSDU frames (which is mandatory as part of 802.11n), an adversary can abuse this to inject arbitrary network packets.""",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-24588Low
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-24587,Low,2021-05-11T20:15:08.580,"""The 802.11 standard that underpins Wi-Fi Protected Access (WPA, WPA2, and WPA3) and Wired Equivalent Privacy (WEP) doesn't require that all fragments of a frame are encrypted under the same key. An adversary can abuse this to decrypt selected fragments when another device sends fragmented frames and the WEP, CCMP, or GCMP encryption key is periodically renewed.""",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-24587Low
linux-libc-dev,4.19.132-1,4.19.194-1,deb,CVE-2020-24586,Low,2021-05-11T20:15:08.537,"""The 802.11 standard that underpins Wi-Fi Protected Access (WPA, WPA2, and WPA3) and Wired Equivalent Privacy (WEP) doesn't require that received fragments be cleared from memory after (re)connecting to a network. Under the right circumstances, when another device sends fragmented frames encrypted using WEP, CCMP, or GCMP, this can be abused to inject arbitrary network packets and/or exfiltrate user data.""",linux-libc-dev4.19.132-14.19.194-1debCVE-2020-24586Low
linux-libc-dev,4.19.132-1,4.19.146-1,deb,CVE-2020-16166,Low,2020-07-30T21:15:11.533,"'The Linux kernel through 5.7.11 allows remote attackers to make observations that help to obtain sensitive information about the internal state of the network RNG, aka CID-f227e3ec3b5c. This is related to drivers/char/random.c and kernel/time/timer.c.'",linux-libc-dev4.19.132-14.19.146-1debCVE-2020-16166Low
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2018-12928,Low,2018-06-28T14:29:00.353,"'In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.'",linux-libc-dev4.19.132-1(won't fix)debCVE-2018-12928Low
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-31085,Negligible,2023-04-24T06:15:08.093,"'An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd->erasesize), used indirectly by ctrl_cdev_ioctl, when mtd->erasesize is 0.'",linux-libc-dev4.19.132-1 debCVE-2023-31085Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-26242,Negligible,2023-02-21T01:15:11.423,'afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.',linux-libc-dev4.19.132-1 debCVE-2023-26242Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-23039,Negligible,2023-02-22T17:15:11.997,"'An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().'",linux-libc-dev4.19.132-1 debCVE-2023-23039Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-23003,Negligible,2023-03-01T20:15:14.233,"'In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.'",linux-libc-dev4.19.132-1 debCVE-2023-23003Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-23000,Negligible,2023-03-01T19:15:25.967,"'In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.'",linux-libc-dev4.19.132-1 debCVE-2023-23000Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-20588,Negligible,2023-08-08T18:15:11.653,'\nA division-by-zero error on some AMD processors can potentially return speculative data resulting in loss of confidentiality.\xa0\n\n\n\n\n\n\n\n',linux-libc-dev4.19.132-1 debCVE-2023-20588Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-45885,Negligible,2022-11-25T04:15:09.230,'An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.',linux-libc-dev4.19.132-1 debCVE-2022-45885Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-45884,Negligible,2022-11-25T04:15:09.180,"'An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.'",linux-libc-dev4.19.132-1 debCVE-2022-45884Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-44034,Negligible,2022-10-30T01:15:08.937,"'An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().'",linux-libc-dev4.19.132-1 debCVE-2022-44034Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-44033,Negligible,2022-10-30T01:15:08.880,"'An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().'",linux-libc-dev4.19.132-1 debCVE-2022-44033Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-41848,Negligible,2022-09-30T06:15:11.580,"'drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.'",linux-libc-dev4.19.132-1 debCVE-2022-41848Negligible
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-33742,Negligible,2022-07-05T13:15:08.570,"""Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-33742Negligible
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-33741,Negligible,2022-07-05T13:15:08.517,"""Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-33741Negligible
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-33740,Negligible,2022-07-05T13:15:08.477,"""Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-33740Negligible
linux-libc-dev,4.19.132-1,(won't fix),deb,CVE-2022-29900,Negligible,2022-07-12T19:15:08.383,'Mis-trained branch predictions for return instructions may allow arbitrary speculative code execution under certain microarchitecture-dependent conditions.',linux-libc-dev4.19.132-1(won't fix)debCVE-2022-29900Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-2961,Negligible,2022-08-29T15:15:10.810,'A use-after-free flaw was found in the Linux kernels PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.',linux-libc-dev4.19.132-1 debCVE-2022-2961Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-27672,Negligible,2023-03-01T08:15:10.343,"'\nWhen SMT is enabled, certain AMD processors may speculatively execute instructions using a target\nfrom the sibling thread after an SMT mode switch potentially resulting in information disclosure.\n\n\n'",linux-libc-dev4.19.132-1 debCVE-2022-27672Negligible
linux-libc-dev,4.19.132-1,4.19.260-1,deb,CVE-2022-26365,Negligible,2022-07-05T13:15:08.270,"""Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.",linux-libc-dev4.19.132-14.19.260-1debCVE-2022-26365Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-25265,Negligible,2022-02-16T21:15:08.017,"'In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.'",linux-libc-dev4.19.132-1 debCVE-2022-25265Negligible
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-21166,Negligible,2022-06-15T21:15:09.100,'Incomplete cleanup in specific special register write operations for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-21166Negligible
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-21125,Negligible,2022-06-15T20:15:17.547,'Incomplete cleanup of microarchitectural fill buffers on some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-21125Negligible
linux-libc-dev,4.19.132-1,4.19.249-2,deb,CVE-2022-21123,Negligible,2022-06-15T20:15:17.503,'Incomplete cleanup of multi-core shared buffers for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.',linux-libc-dev4.19.132-14.19.249-2debCVE-2022-21123Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-1247,Negligible,2022-08-31T16:15:09.177,"'An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh->use to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their count and use are zero.'",linux-libc-dev4.19.132-1 debCVE-2022-1247Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2022-0400,Negligible,2022-08-29T15:15:09.423,"'An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.'",linux-libc-dev4.19.132-1 debCVE-2022-0400Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-3714,Negligible,2022-08-23T16:15:09.600,'A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.',linux-libc-dev4.19.132-1 debCVE-2021-3714Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-32078,Negligible,2021-06-17T15:15:07.613,"""An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative, e.g., access to element -2 of an array, aka CID-298a58e165e4.""",linux-libc-dev4.19.132-1 debCVE-2021-32078Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-26934,Negligible,2021-02-17T02:15:13.143,"""An issue was discovered in the Linux kernel 4.18 through 5.10.16, as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration, but this wasn't stated accordingly in its support status entry.""",linux-libc-dev4.19.132-1 debCVE-2021-26934Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2021-0929,Negligible,2021-12-15T19:15:11.383,"'In ion_dma_buf_end_cpu_access and related functions of ion.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-187527909References: Upstream kernel'",linux-libc-dev4.19.132-1 debCVE-2021-0929Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-35501,Negligible,2022-03-30T16:15:08.673,"'A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem'",linux-libc-dev4.19.132-1 debCVE-2020-35501Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-27820,Negligible,2021-11-03T00:15:07.550,"'A vulnerability was found in Linux kernel, where a use-after-frees in nouveau\'s postclose() handler could happen if removing device (that is not common to remove video card physically without power-off, but same happens if ""unbind"" the driver).'",linux-libc-dev4.19.132-1 debCVE-2020-27820Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2020-11725,Negligible,2020-04-12T22:15:11.900,"'snd_ctl_elem_add in sound/core/control.c in the Linux kernel through 5.6.3 has a count=info->owner line, which later affects a private_size*count multiplication for unspecified ""interesting side effects."" NOTE: kernel engineers dispute this finding, because it could be relevant only if new callers were added that were unfamiliar with the misuse of the info->owner field to represent data unrelated to the ""owner"" concept. The existing callers, SNDRV_CTL_IOCTL_ELEM_ADD and SNDRV_CTL_IOCTL_ELEM_REPLACE, have been designed to misuse the info->owner field in a safe way'",linux-libc-dev4.19.132-1 debCVE-2020-11725Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-19378,Negligible,2019-11-29T17:15:11.840,"'In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.'",linux-libc-dev4.19.132-1 debCVE-2019-19378Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-19083,Negligible,2019-11-18T06:15:13.890,"'Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.'",linux-libc-dev4.19.132-1 debCVE-2019-19083Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-19070,Negligible,2019-11-18T06:15:12.983,"'A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began'",linux-libc-dev4.19.132-1 debCVE-2019-19070Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-19064,Negligible,2019-11-18T06:15:12.607,"'A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time'",linux-libc-dev4.19.132-1 debCVE-2019-19064Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16234,Negligible,2019-09-11T16:15:11.770,"'drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.'",linux-libc-dev4.19.132-1 debCVE-2019-16234Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16233,Negligible,2019-09-11T16:15:11.647,"'drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.'",linux-libc-dev4.19.132-1 debCVE-2019-16233Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16232,Negligible,2019-09-11T16:15:11.457,"'drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.'",linux-libc-dev4.19.132-1 debCVE-2019-16232Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16231,Negligible,2019-09-11T16:15:11.317,"'drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.'",linux-libc-dev4.19.132-1 debCVE-2019-16231Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16230,Negligible,2019-09-11T16:15:11.130,"'drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely'",linux-libc-dev4.19.132-1 debCVE-2019-16230Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-16229,Negligible,2019-09-11T16:15:10.957,"'drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id'",linux-libc-dev4.19.132-1 debCVE-2019-16229Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12615,Negligible,2019-06-03T22:29:00.337,"'An issue was discovered in get_vdev_port_node_info in arch/sparc/kernel/mdesc.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup_const of node_info->vdev_port.name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).'",linux-libc-dev4.19.132-1 debCVE-2019-12615Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12456,Negligible,2019-05-30T14:29:01.890,"'An issue was discovered in the MPT3COMMAND case in _ctl_ioctl_main in drivers/scsi/mpt3sas/mpt3sas_ctl.c in the Linux kernel through 5.1.5. It allows local users to cause a denial of service or possibly have unspecified other impact by changing the value of ioc_number between two kernel reads of that value, aka a ""double fetch"" vulnerability. NOTE: a third party reports that this is unexploitable because the doubly fetched value is not used'",linux-libc-dev4.19.132-1 debCVE-2019-12456Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12455,Negligible,2019-05-30T04:29:02.103,"'An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because The memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.'",linux-libc-dev4.19.132-1 debCVE-2019-12455Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12382,Negligible,2019-05-28T03:29:00.467,"'An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference'",linux-libc-dev4.19.132-1 debCVE-2019-12382Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12381,Negligible,2019-05-28T03:29:00.403,"'An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL'",linux-libc-dev4.19.132-1 debCVE-2019-12381Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12380,Negligible,2019-05-28T03:29:00.357,"'**DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because All the code touched by the referenced commit runs only at boot, before any user processes are started. Therefore, there is no possibility for an unprivileged user to control it..'",linux-libc-dev4.19.132-1 debCVE-2019-12380Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12379,Negligible,2019-05-28T03:29:00.293,'An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue',linux-libc-dev4.19.132-1 debCVE-2019-12379Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-12378,Negligible,2019-05-28T03:29:00.247,"'An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue'",linux-libc-dev4.19.132-1 debCVE-2019-12378Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2019-11191,Negligible,2019-04-12T00:29:00.310,"'The Linux kernel through 5.0.7, when CONFIG_IA32_AOUT is enabled and ia32_aout is loaded, allows local users to bypass ASLR on setuid a.out programs (if any exist) because install_exec_creds() is called too late in load_aout_binary() in fs/binfmt_aout.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat. NOTE: the software maintainer disputes that this is a vulnerability because ASLR for a.out format executables has never been supported'",linux-libc-dev4.19.132-1 debCVE-2019-11191Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2018-17977,Negligible,2018-10-08T17:29:00.653,"'The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages, IPPROTO_AH packets, and IPPROTO_IP packets, which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications, as demonstrated on CentOS 7.'",linux-libc-dev4.19.132-1 debCVE-2018-17977Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2018-1121,Negligible,2018-06-13T20:29:00.337,"""procps-ng, procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order, a process occupying a high PID can use inotify events to determine when the process list is being scanned, and fork/exec to obtain a lower PID, thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15, newer versions might be affected also.""",linux-libc-dev4.19.132-1 debCVE-2018-1121Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2017-13694,Negligible,2017-08-25T08:29:00.320,"'The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.'",linux-libc-dev4.19.132-1 debCVE-2017-13694Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2017-13693,Negligible,2017-08-25T08:29:00.273,"'The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.'",linux-libc-dev4.19.132-1 debCVE-2017-13693Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2017-0630,Negligible,2017-05-12T15:29:02.657,"'An information disclosure vulnerability in the kernel trace subsystem could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-34277115.'",linux-libc-dev4.19.132-1 debCVE-2017-0630Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2016-8660,Negligible,2016-10-16T21:59:14.333,"'The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program, related to a ""page lock order bug in the XFS seek hole/data implementation.""'",linux-libc-dev4.19.132-1 debCVE-2016-8660Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2016-10723,Negligible,2018-06-21T13:29:00.210,"'An issue was discovered in the Linux kernel through 4.17.2. Since the page allocator does not yield CPU resources to the owner of the oom_lock mutex, a local unprivileged user can trivially lock up the system forever by wasting CPU resources from the page allocator (e.g., via concurrent page fault events) when the global OOM killer is invoked. NOTE: the software maintainer has not accepted certain proposed patches, in part because of a viewpoint that ""the underlying problem is non-trivial to handle.'",linux-libc-dev4.19.132-1 debCVE-2016-10723Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2015-2877,Negligible,2017-03-03T11:59:00.147,"'Kernel Samepage Merging (KSM) in the Linux kernel 2.6.32 through 4.x does not prevent use of a write-timing side channel, which allows guest OS users to defeat the ASLR protection mechanism on other guest OS instances via a Cross-VM ASL INtrospection (CAIN) attack.  NOTE: the vendor states ""Basically if you care about this attack vector, disable deduplication."" Share-until-written approaches for memory conservation among mutually untrusting tenants are inherently detectable for information disclosure, and can be classified as potentially misunderstood behaviors rather than vulnerabilities'",linux-libc-dev4.19.132-1 debCVE-2015-2877Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2014-9900,Negligible,2016-08-06T10:59:44.983,"'The ethtool_get_wol function in net/core/ethtool.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not initialize a certain data structure, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28803952 and Qualcomm internal bug CR570754.'",linux-libc-dev4.19.132-1 debCVE-2014-9900Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2014-9892,Negligible,2016-08-06T10:59:35.717,"'The snd_compr_tstamp function in sound/core/compress_offload.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize a timestamp data structure, which allows attackers to obtain sensitive information via a crafted application, aka Android internal bug 28770164 and Qualcomm internal bug CR568717.'",linux-libc-dev4.19.132-1 debCVE-2014-9892Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2012-4542,Negligible,2013-02-28T19:55:01.107,"'block/scsi_ioctl.c in the Linux kernel through 3.8 does not properly consider the SCSI device class during authorization of SCSI commands, which allows local users to bypass intended access restrictions via an SG_IO ioctl call that leverages overlapping opcodes.'",linux-libc-dev4.19.132-1 debCVE-2012-4542Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2011-4917,Negligible,2022-04-18T17:15:11.937,'In the Linux kernel through 3.1 there is an information disclosure issue via /proc/stat.',linux-libc-dev4.19.132-1 debCVE-2011-4917Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2011-4916,Negligible,2022-07-12T21:15:09.147,'Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /dev/pts/ and /dev/tty*.',linux-libc-dev4.19.132-1 debCVE-2011-4916Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2011-4915,Negligible,2020-02-20T18:15:11.137,'fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.',linux-libc-dev4.19.132-1 debCVE-2011-4915Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2010-4563,Negligible,2012-02-02T17:55:00.847,"'The Linux kernel, when using IPv6, allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent, as demonstrated by thcping.'",linux-libc-dev4.19.132-1 debCVE-2010-4563Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2008-4609,Negligible,2008-10-20T17:59:26.163,"'The TCP implementation in (1) Linux, (2) platforms based on BSD Unix, (3) Microsoft Windows, (4) Cisco products, and probably other operating systems allows remote attackers to cause a denial of service (connection queue exhaustion) via multiple vectors that manipulate information in the TCP state table, as demonstrated by sockstress.'",linux-libc-dev4.19.132-1 debCVE-2008-4609Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2008-2544,Negligible,2021-05-27T13:15:07.753,"'Mounting /proc filesystem via chroot command silently mounts it in read-write mode. The user could bypass the chroot environment and gain write access to files, he would never have otherwise.'",linux-libc-dev4.19.132-1 debCVE-2008-2544Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2007-3719,Negligible,2007-07-12T16:30:00.000,"'The process scheduler in the Linux kernel 2.6.16 gives preference to ""interactive"" processes that perform voluntary sleeps, which allows local users to cause a denial of service (CPU consumption), as described in ""Secretly Monopolizing the CPU Without Superuser Privileges.""'",linux-libc-dev4.19.132-1 debCVE-2007-3719Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2005-3660,Negligible,2005-12-22T23:03:00.000,"'Linux kernel 2.4 and 2.6 allows attackers to cause a denial of service (memory exhaustion and panic) by creating a large number of connected file descriptors or socketpairs and setting a large data transfer buffer, then preventing Linux from being able to finish the transfer by causing the process to become a zombie, or closing the file descriptor without closing an associated reference.'",linux-libc-dev4.19.132-1 debCVE-2005-3660Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2004-0230,Negligible,2004-08-18T04:00:00.000,"'TCP, when using a large Window Size, makes it easier for remote attackers to guess sequence numbers and cause a denial of service (connection loss) to persistent TCP connections by repeatedly injecting a TCP RST packet, especially in protocols that use long-lived connections, such as BGP.'",linux-libc-dev4.19.132-1 debCVE-2004-0230Negligible
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-47233,Unknown,2023-11-03T21:15:17.360,"'The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this ""could be exploited in a real world scenario."" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.'",linux-libc-dev4.19.132-1 debCVE-2023-47233Unknown
linux-libc-dev,4.19.132-1, ,deb,CVE-2023-46813,Unknown,2023-10-27T03:15:08.270,"'An issue was discovered in the Linux kernel before 6.5.9, exploitable by local users with userspace access to MMIO registers. Incorrect access checking in the #VC handler and instruction emulation of the SEV-ES emulation of MMIO accesses could lead to arbitrary write access to kernel memory (and thus privilege escalation). This depends on a race condition through which userspace can replace an instruction before the #VC handler reads it.'",linux-libc-dev4.19.132-1 debCVE-2023-46813Unknown
openssh-client,1:7.9p1-10+deb10u2,1:7.9p1-10+deb10u3,deb,CVE-2023-38408,Critical,2023-07-20T03:15:10.170,"'The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.'",openssh-client1:7.9p1-10+deb10u21:7.9p1-10+deb10u3debCVE-2023-38408Critical
openssh-client,1:7.9p1-10+deb10u2,(won't fix),deb,CVE-2021-41617,High,2021-09-26T19:15:07.263,"'sshd in OpenSSH 6.2 through 8.x before 8.8, when certain non-default configurations are used, allows privilege escalation because supplemental groups are not initialized as expected. Helper programs for AuthorizedKeysCommand and AuthorizedPrincipalsCommand may run with privileges associated with group memberships of the sshd process, if the configuration specifies running the command as a different user.'",openssh-client1:7.9p1-10+deb10u2(won't fix)debCVE-2021-41617High
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2021-36368,Negligible,2022-03-13T00:15:07.937,"'An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user\'s behalf. NOTE: the vendor\'s position is ""this is not an authentication bypass, since nothing is being bypassed.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2021-36368Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2020-15778,Negligible,2020-07-24T14:15:12.450,"'scp in OpenSSH through 8.3p1 allows command injection in the scp.c toremote function, as demonstrated by backtick characters in the destination argument. NOTE: the vendor reportedly has stated that they intentionally omit validation of ""anomalous argument transfers"" because that could ""stand a great chance of breaking existing workflows.""'",openssh-client1:7.9p1-10+deb10u2 debCVE-2020-15778Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2020-14145,Negligible,2020-06-29T18:15:11.940,'The client side in OpenSSH 5.7 through 8.4 has an Observable Discrepancy leading to an information leak in the algorithm negotiation. This allows man-in-the-middle attackers to target initial connection attempts (where no host key for the server has been cached by the client). NOTE: some reports state that 8.5 and 8.6 are also affected.',openssh-client1:7.9p1-10+deb10u2 debCVE-2020-14145Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2020-12062,Negligible,2020-06-01T16:15:14.260,"'The scp client in OpenSSH 8.2 incorrectly sends duplicate responses to the server upon a utimes system call failure, which allows a malicious unprivileged user on the remote server to overwrite arbitrary files in the client\'s download directory by creating a crafted subdirectory anywhere on the remote server. The victim must use the command scp -rp to download a file hierarchy containing, anywhere inside, this crafted subdirectory. NOTE: the vendor points out that ""this attack can achieve no more than a hostile peer is already able to achieve within the scp protocol"" and ""utimes does not fail under normal circumstances.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2020-12062Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2019-6110,Negligible,2019-01-31T18:29:00.807,"'In OpenSSH 7.9, due to accepting and displaying arbitrary stderr output from the server, a malicious server (or Man-in-The-Middle attacker) can manipulate the client output, for example to use ANSI control codes to hide additional files being transferred.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2019-6110Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2019-16905,Negligible,2019-10-09T20:15:23.503,"'OpenSSH 7.7 through 7.9 and 8.x before 8.1, when compiled with an experimental key type, has a pre-authentication integer overflow if a client or server is configured to use a crafted XMSS key. This leads to memory corruption and local code execution because of an error in the XMSS key parsing algorithm. NOTE: the XMSS implementation is considered experimental in all released OpenSSH versions, and there is no supported way to enable it when building portable OpenSSH.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2019-16905Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2018-15919,Negligible,2018-08-28T08:29:00.207,"'Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states \'We understand that the OpenSSH developers do not want to treat such a username enumeration (or ""oracle"") as a vulnerability.\''",openssh-client1:7.9p1-10+deb10u2 debCVE-2018-15919Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2016-20012,Negligible,2021-09-15T20:15:07.310,"'OpenSSH through 8.7 allows remote attackers, who have a suspicion that a certain combination of username and public key is known to an SSH server, to test whether this suspicion is correct. This occurs because a challenge is sent only when that combination could be valid for a login session. NOTE: the vendor does not recognize user enumeration as a vulnerability for this product'",openssh-client1:7.9p1-10+deb10u2 debCVE-2016-20012Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2008-3234,Negligible,2008-07-18T16:41:00.000,"'sshd in OpenSSH 4 on Debian GNU/Linux, and the 20070303 OpenSSH snapshot, allows remote authenticated users to obtain access to arbitrary SELinux roles by appending a :/ (colon slash) sequence, followed by the role name, to the username.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2008-3234Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2007-2768,Negligible,2007-05-21T20:30:00.000,"'OpenSSH, when using OPIE (One-Time Passwords in Everything) for PAM, allows remote attackers to determine the existence of certain user accounts, which displays a different response if the user account exists and is configured to use one-time passwords (OTP), a similar issue to CVE-2007-2243.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2007-2768Negligible
openssh-client,1:7.9p1-10+deb10u2, ,deb,CVE-2007-2243,Negligible,2007-04-25T16:19:00.000,"'OpenSSH 4.6 and earlier, when ChallengeResponseAuthentication is enabled, allows remote attackers to determine the existence of user accounts by attempting to authenticate via S/KEY, which displays a different response if the user account exists, a similar issue to CVE-2001-1483.'",openssh-client1:7.9p1-10+deb10u2 debCVE-2007-2243Negligible
python-certifi,2018.8.24-1, ,deb,CVE-2023-37920,Negligible,2023-07-25T21:15:10.827,"'Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi prior to version 2023.07.22 recognizes ""e-Tugra"" root certificates. e-Tugra\'s root certificates were subject to an investigation prompted by reporting of security issues in their systems. Certifi 2023.07.22 removes root certificates from ""e-Tugra"" from the root store.'",python-certifi2018.8.24-1 debCVE-2023-37920Negligible
python3-certifi,2018.8.24-1, ,deb,CVE-2023-37920,Negligible,2023-07-25T21:15:10.827,"'Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi prior to version 2023.07.22 recognizes ""e-Tugra"" root certificates. e-Tugra\'s root certificates were subject to an investigation prompted by reporting of security issues in their systems. Certifi 2023.07.22 removes root certificates from ""e-Tugra"" from the root store.'",python3-certifi2018.8.24-1 debCVE-2023-37920Negligible
python-certifi,2018.8.24-1, ,deb,CVE-2022-23491,Negligible,2022-12-07T22:15:09.870,"'Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi 2022.12.07 removes root certificates from ""TrustCor"" from the root store. These are in the process of being removed from Mozilla\'s trust store. TrustCor\'s root certificates are being removed pursuant to an investigation prompted by media reporting that TrustCor\'s ownership also operated a business that produced spyware. Conclusions of Mozilla\'s investigation can be found in the linked google group discussion.'",python-certifi2018.8.24-1 debCVE-2022-23491Negligible
python3-certifi,2018.8.24-1, ,deb,CVE-2022-23491,Negligible,2022-12-07T22:15:09.870,"'Certifi is a curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. Certifi 2022.12.07 removes root certificates from ""TrustCor"" from the root store. These are in the process of being removed from Mozilla\'s trust store. TrustCor\'s root certificates are being removed pursuant to an investigation prompted by media reporting that TrustCor\'s ownership also operated a business that produced spyware. Conclusions of Mozilla\'s investigation can be found in the linked google group discussion.'",python3-certifi2018.8.24-1 debCVE-2022-23491Negligible
python-requests,2.21.0-1,2.21.0-1+deb10u1,deb,CVE-2023-32681,Medium,2023-05-26T18:15:14.147,"'Requests is a HTTP library. Since Requests 2.3.0, Requests has been leaking Proxy-Authorization headers to destination servers when redirected to an HTTPS endpoint. This is a product of how we use `rebuild_proxies` to reattach the `Proxy-Authorization` header to requests. For HTTP connections sent through the tunnel, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into the tunneled request. This results in Requests forwarding proxy credentials to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate sensitive information. This issue has been patched in version 2.31.0.\n\n'",python-requests2.21.0-12.21.0-1+deb10u1debCVE-2023-32681Medium
python3-requests,2.21.0-1,2.21.0-1+deb10u1,deb,CVE-2023-32681,Medium,2023-05-26T18:15:14.147,"'Requests is a HTTP library. Since Requests 2.3.0, Requests has been leaking Proxy-Authorization headers to destination servers when redirected to an HTTPS endpoint. This is a product of how we use `rebuild_proxies` to reattach the `Proxy-Authorization` header to requests. For HTTP connections sent through the tunnel, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into the tunneled request. This results in Requests forwarding proxy credentials to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate sensitive information. This issue has been patched in version 2.31.0.\n\n'",python3-requests2.21.0-12.21.0-1+deb10u1debCVE-2023-32681Medium
python-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2023-43804,High,2023-10-04T17:15:10.163,"""urllib3 is a user-friendly HTTP client library for Python. urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly. This issue has been patched in urllib3 version 1.26.17 or 2.0.5.""",python-urllib31.24.1-11.24.1-1+deb10u1debCVE-2023-43804High
python3-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2023-43804,High,2023-10-04T17:15:10.163,"""urllib3 is a user-friendly HTTP client library for Python. urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly. This issue has been patched in urllib3 version 1.26.17 or 2.0.5.""",python3-urllib31.24.1-11.24.1-1+deb10u1debCVE-2023-43804High
python-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2019-11324,High,2019-04-18T21:29:00.883,"'The urllib3 library before 1.24.2 for Python mishandles certain cases where the desired set of CA certificates is different from the OS store of CA certificates, which results in SSL connections succeeding in situations where a verification failure is the correct outcome. This is related to use of the ssl_context, ca_certs, or ca_certs_dir argument.'",python-urllib31.24.1-11.24.1-1+deb10u1debCVE-2019-11324High
python3-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2019-11324,High,2019-04-18T21:29:00.883,"'The urllib3 library before 1.24.2 for Python mishandles certain cases where the desired set of CA certificates is different from the OS store of CA certificates, which results in SSL connections succeeding in situations where a verification failure is the correct outcome. This is related to use of the ssl_context, ca_certs, or ca_certs_dir argument.'",python3-urllib31.24.1-11.24.1-1+deb10u1debCVE-2019-11324High
python-urllib3,1.24.1-1, ,deb,CVE-2023-45803,Medium,2023-10-17T20:15:10.070,"""urllib3 is a user-friendly HTTP client library for Python. urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 301, 302, or 303 after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although this behavior is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers. Because the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable. Both of the following conditions must be true to be affected by this vulnerability: 1. Using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON) and 2. The origin service is compromised and starts redirecting using 301, 302, or 303 to a malicious peer or the redirected-to service becomes compromised. This issue has been addressed in versions 1.26.18 and 2.0.7 and users are advised to update to resolve this issue. Users unable to update should disable redirects for services that aren't expecting to respond with redirects with `redirects=False` and disable automatic redirects with `redirects=False` and handle 301, 302, and 303 redirects manually by stripping the HTTP request body.\n""",python-urllib31.24.1-1 debCVE-2023-45803Medium
python3-urllib3,1.24.1-1, ,deb,CVE-2023-45803,Medium,2023-10-17T20:15:10.070,"""urllib3 is a user-friendly HTTP client library for Python. urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 301, 302, or 303 after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although this behavior is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers. Because the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable. Both of the following conditions must be true to be affected by this vulnerability: 1. Using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON) and 2. The origin service is compromised and starts redirecting using 301, 302, or 303 to a malicious peer or the redirected-to service becomes compromised. This issue has been addressed in versions 1.26.18 and 2.0.7 and users are advised to update to resolve this issue. Users unable to update should disable redirects for services that aren't expecting to respond with redirects with `redirects=False` and disable automatic redirects with `redirects=False` and handle 301, 302, and 303 redirects manually by stripping the HTTP request body.\n""",python3-urllib31.24.1-1 debCVE-2023-45803Medium
python-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2020-26137,Medium,2020-09-30T18:15:26.773,"'urllib3 before 1.25.9 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of putrequest(). NOTE: this is similar to CVE-2020-26116.'",python-urllib31.24.1-11.24.1-1+deb10u1debCVE-2020-26137Medium
python3-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2020-26137,Medium,2020-09-30T18:15:26.773,"'urllib3 before 1.25.9 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of putrequest(). NOTE: this is similar to CVE-2020-26116.'",python3-urllib31.24.1-11.24.1-1+deb10u1debCVE-2020-26137Medium
python-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2019-11236,Medium,2019-04-15T15:29:00.637,"'In the urllib3 library through 1.24.1 for Python, CRLF injection is possible if the attacker controls the request parameter.'",python-urllib31.24.1-11.24.1-1+deb10u1debCVE-2019-11236Medium
python3-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2019-11236,Medium,2019-04-15T15:29:00.637,"'In the urllib3 library through 1.24.1 for Python, CRLF injection is possible if the attacker controls the request parameter.'",python3-urllib31.24.1-11.24.1-1+deb10u1debCVE-2019-11236Medium
python-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2018-25091,Medium,2023-10-15T19:15:09.213,"'urllib3 before 1.24.2 does not remove the authorization HTTP header when following a cross-origin redirect (i.e., a redirect that differs in host, port, or scheme). This can allow for credentials in the authorization header to be exposed to unintended hosts or transmitted in cleartext. NOTE: this issue exists because of an incomplete fix for CVE-2018-20060 (which was case-sensitive).'",python-urllib31.24.1-11.24.1-1+deb10u1debCVE-2018-25091Medium
python3-urllib3,1.24.1-1,1.24.1-1+deb10u1,deb,CVE-2018-25091,Medium,2023-10-15T19:15:09.213,"'urllib3 before 1.24.2 does not remove the authorization HTTP header when following a cross-origin redirect (i.e., a redirect that differs in host, port, or scheme). This can allow for credentials in the authorization header to be exposed to unintended hosts or transmitted in cleartext. NOTE: this issue exists because of an incomplete fix for CVE-2018-20060 (which was case-sensitive).'",python3-urllib31.24.1-11.24.1-1+deb10u1debCVE-2018-25091Medium
